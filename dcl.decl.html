
<cxx-clause id="dcl.decl" number="8">
  <h1>Declarators</h1>

  Modify <cxx-ref in="cxx" to="dcl.decl"></cxx-ref>/1 as follows:

  <p class="quoted">
  A declarator declares a single variable, function, or type within a 
  declaration. The <cxx-grammarterm>init-declarator-list</cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which may
  <del>have an initializer</del>
  <ins>have constraints, an initializer, or both</ins>.
  <bnf-grammar>
    <bnf-rule>init-declarator</bnf-rule>
      <bnf-alt>
        declarator
        <ins><bnf-opt>requires-clause</bnf-opt></ins>
        <bnf-opt>initializer</bnf-opt>
      </bnf-alt>
  </bnf-grammar>
  </p>

  Insert the following paragraphs.

  <p class="quoted">
  A <cxx-grammarterm>requires-clause</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm> shall only appear
  with a function declarator (<cxx-ref to="dcl.fct"></cxx-ref>).

  <cxx-example class="inline">
  <cxx-codeblock>
template<typename T> concept bool C = true;

void f1(auto x) requires C&lt;decltype(x)&gt;; // <i>OK</i>
void f2(int x) requires C&lt;int&gt;;          // <i>OK</i>
auto n requires C&lt;decltype(n)&gt; = 'a';    // <i>error: constrained variable declaration</i>
  </cxx-codeblock>
  </cxx-example>

  </p>

  <p class="quoted"> 
  If present, the <cxx-grammarterm>requires-clause</cxx-grammarterm> associates its
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> with the declared
  function (<cxx-ref to="temp"></cxx-ref>).
  </p>

  <cxx-section id="dcl.meaning" number="3">
    <h1>Meaning of declarators</h1>

    <cxx-section id="dcl.fct" number="5">
      <h1>Functions</h1>

      <!-- TODO: Add to /15 a rule that disambiguates the ... (without
      a preceeding ',' for constrained-type-specifiers). If it's needed.

      The "or contains auto" will need to be updated. -->


      Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>/14.

      <p number="15">
      An abbreviated function (<cxx-ref to="dcl.spec.auto"></cxx-ref>)
      is equivalent a function template (<cxx-ref to="temp.fct"></cxx-ref>) whose
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
      includes one invented type <cxx-grammarterm>template-parameter</cxx-grammarterm>
      for each occurrence of a placeholder type, designated by either 
      the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
      (<cxx-ref to="dcl.spec.auto">"</cxx-ref>)
      or by a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      (<cxx-ref to="dcl.spec.constr"></cxx-ref>),
      in the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
      in order of appearance. 

      The invented type <cxx-grammarterm>template-parameter</cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
      declares a function parameter pack (<cxx-ref to="dcl.fct"></cxx-ref>)
      and the type of the parameter contains only one placeholder type.
      If the type of the function parameter that declares a function
      parameter pack contains more than one placeholder type, the program
      is ill-formed.

      The adjusted function parameters of an abbreviated function are derived 
      from the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> 
      by replacing each occurrence of a placeholder type with the  name of the 
      corresponding invented type <cxx-grammarterm>template-parameter</cxx-grammarterm>.

      <!-- TODO: Write examples with concepts -->
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(const auto&amp;, auto);
void f2(Vec&lt;auto*&gt;...);
void f3(auto (auto::*)(auto));

template&lt;typename T, typename U&gt; 
  void f1(const T&, U);       // <i>equivalent to</i> f1(const auto&amp;, auto)
template&lt;typename... T&gt; 
  void f2(Vec&lt;T*>...);       // <i>equivalent to</i> f2(Vec&lt;auto*&gt;...)
template&lt;typename T, typename U, typename V&gt;
  void f3(T (U::*)(V));      // <i>equivalent to</i> f3(auto (auto::*)(auto))

void foo(Pair&lt;auto, auto&gt;...) // <i>error: multiple placeholder types in a parameter pack</i>
      </cxx-codeblock>
      </cxx-example>
  
      <cxx-example>
      An abbreviated function whose parameter types include
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s can
      be equivalently declared using 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>s
      (<cxx-ref to="temp"></cxx-ref>).
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = true;
template&lt;typename T, typename U&gt; concept bool D = true;

void g1(const C1*, C2&amp;);
void g2(Vec&lt;C1&gt;&amp;);
void g3(C1&amp;...);
void g4(Vec&lt;D&lt;int&gt;&gt;);

template&lt;C1 T, C2 U&gt; void g1(const T*, U&amp;); // <i>equivalent to</i> g1(const C1*, C2&amp;)
template&lt;C1 T&gt; void g2(Vec&lt;T&gt;&amp;);            // <i>equivalent to</i> g2(Vec&lt;C1&gt;&amp;)
template&lt;C1... Ts&gt; void g3(Ts...&amp;);         // <i>equivalent to</i> g3(C1&amp;...)
template&lt;D&lt;int&gt; T&gt; void g4(Vec&lt;T&gt;);         // <i>equivalent to</i> g4(Vec&lt;D&lt;int&gt;>)
      </cxx-codeblock>
      </cxx-example>
      </p>


      <!-- TODO: This moves into dcl.fct -->
      <p> All placeholder types introduced using the same 
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> have the 
      same invented template type parameter.
      <cxx-example class="inline">
      <cxx-codeblock>
namespace N {
  template&lt;typename T&gt; concept bool C = true;
}
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int&gt; concept D = true;
template&lt;typename, int = 0&gt; E = true;

void f0(C a, C b);
      </cxx-codeblock>
      The types of <code>a</code> and <code>b</code> are the same invented template
      type parameter.
      <cxx-codeblock>
void f1(C& a, C* b);
      </cxx-codeblock>
      The type of <code>a</code> is a reference to an invented template type parameter 
      (call it <code>T</code>), and the type of <code>b</code> is a pointer to 
      <code>T</code>.
      <cxx-codeblock>
void f2(N::C a, C b);
void f3(D&lt;0&gt; a, D&lt;1&gt; b);
      </cxx-codeblock>
      In both functions, the parameters <code>a</code> and
      <code>b</code> have different invented template type parameters.
      <cxx-codeblock>
void f4(E a, E&lt;&gt; b, E&lt;0&gt; c)
      </cxx-codeblock>
      The types of <code>a</code>, <code>b</code>, and <code>c</code> are
      distinct invented template type parameters even though the constraints 
      associated by the each of the 
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
      (<cxx-ref to="dcl.spec.constr"></cxx-ref>) are equivalent.
      <cxx-codeblock>
template&lt;typename...&gt; struct Tuple;

void f5(Tuple&lt;C&amp;, C*, N::C&gt; p);
      </cxx-codeblock>
      The type of <code>p</code> is <code>Tuple&lt;T&, T*, U&gt;</code> where 
      <code>T</code> and <code>U</code> are the invented template type parameters
      corresponding to <code>C</code> and <code>N::C</code>, respectively.
      </cxx-example>
      </p>

      <!-- TODO: Move into temp.fct? -->
      <p> A function template can be an abbreviated function. The
      invented <cxx-grammarterm>template-parameter</cxx-grammarterm>s are
      added to the <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm>template-parameter</cxx-grammarterm>s.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: Equivalent to f(Array&lt;auto, N&gt;*)
      </cxx-codeblock>
      </cxx-example>
      </p>


    </cxx-section> <!-- dcl.fct -->
  </cxx-section> <!-- dcl.meaning -->

  <cxx-section id="dcl.fct.def">
    <h1>Function definitions</h1>

    <cxx-section id="dcl.fct.def.general">
      <h1>In general</h1>
    
      Modify the <cxx-grammarterm>function-definition</cxx-grammarterm>
      syntax in <cxx-ref in="cxx" to="dcl.fct.def.general">/1</cxx-ref>
      to include a <cxx-grammarterm>requires-clause</cxx-grammarterm>.

      <p class="quoted">
      <bnf-grammar>
        <bnf-rule>function-definition</bnf-rule>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt>
            <bnf-opt>decl-specifier-seq</bnf-opt>
            declarator
            <bnf-opt>virt-specifier-seq</bnf-opt>
            <ins><bnf-opt>requires-clause</bnf-opt></ins>
            function-body
          </bnf-alt>
      </bnf-grammar>
      </p>

      Add the following paragraph.

      <p number="9" class="quoted">
      <ins> If present, the <cxx-grammarterm>requires-clause</cxx-grammarterm>
      associates its <cxx-grammarterm>constraint-expression</cxx-grammarterm>
      with the function (<cxx-ref to="temp"></cxx-ref>).
      </p>

    </cxx-section> <!-- dcl.fct.def.general -->
  </cxx-section> <!-- dcl.fct.def -->
</cxx-clause> <!-- dcl.decl -->
