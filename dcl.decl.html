
<cxx-clause id="dcl.decl" number="8">
  <h1>Declarators</h1>

  <p>Modify <cxx-ref in="cxx" to="dcl.decl"></cxx-ref>/1 as follows:</p>

  <p>A declarator declares a single variable, function, or type, within a 
  declaration. The <cxx-grammarterm>init-declarator-list</cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which can 
  <del>have an initializer</del>
  <ins>have constraints, an initializer, or both</ins>.
  <bnf-grammar>
    <bnf-rule>init-declarator</bnf-rule>
      <bnf-alt>
        declarator
        <bnf-opt>requires-clause</bnf-opt>
        <bnf-opt>initializer</bnf-opt>
      </bnf-alt>
  </bnf-grammar>
  </p>

  Insert the following paragraph after 
  <cxx-ref in="cxx" to="dcl.decl"></cxx-ref>/1.

  <p> A <cxx-grammarterm>requires-clause</cxx-grammarterm> 
  (<cxx-ref to="temp"></cxx-ref>) shall only be present if the
  <cxx-grammarterm>declarator</cxx-grammarterm> declares a generic
  function (<cxx-ref to="dcl.fct"></cxx-ref>).
  <cxx-example class="inline">
  <cxx-codeblock>
template<typename T> concept bool C = true;

void f1(auto x) requires C&lt;decltype(x)&gt;;// <i>OK</i>
void f2(int x) requires C&lt;int&gt;;         // <i>OK</i>
auto n requires C&lt;decltype(n)&gt; = g();   // <i>error: cannot constrain variable declaration</i>
struct S { } requires C&lt;S&gt;;             // <i>error: cannot constrain a class definition</i>
  </cxx-codeblock>
  </cxx-example>
  </p>


  <cxx-section id="dcl.meaning" number="3">
    <h1>Meaning of declarators</h1>

    <cxx-section id="dcl.fct" number="5">
      <h1>Functions</h1>

      <!-- NOTE: Removal pending discussion of constrained-parameters.
           My feeling is that this will go. -->
      <!-- 
      Refactor the <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
      grammar in <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>/3 to separate
      the declaration of a parameter from its default argument.

      <bnf-grammar>
        <ins>
        <bnf-rule>basic-parameter-declaration</bnf-rule>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq declarator
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq <bnf-opt>abstract-declarator</bnf-opt>
          </bnf-alt>
        </ins>

        <bnf-rule>parameter-declaration</bnf-rule>
          <del>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq declarator
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq declarator <bnf-terminal>=</bnf-terminal> initializer-clause
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq <bnf-opt>abstract-declarator</bnf-opt>
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq <bnf-opt>abstract-declarator</bnf-opt> <bnf-terminal>=</bnf-terminal> initializer-clause
          </bnf-alt>
          </del>
          
          <ins>
          <bnf-alt>basic-parameter-declaration <bnf-terminal>=</bnf-terminal> initializer-clause</bnf-alt>
          </ins>
      </bnf-grammar>
      -->
      
    
      <!-- TODO: Add to /15 a rule that disambiguates the ... (without
      a preceeding ',' for constrained-type-specifiers). If it's needed.

      The "or contains auto" will need to be updated. -->

      Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>/14.

      <!-- TODO: Extend this to support constrained-type-specifiers -->
      
      <p number="15">
      An abbreviated function (<cxx-ref to="dcl.spec.auto"></cxx-ref>)
      (call it <code>F</code>) is equivalent to a 
      function template (<cxx-ref to="temp.fct"></cxx-ref>) (call it 
      <code>T</code>) whose 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
      includes one invented type <cxx-grammarterm>template-parameter</cxx-grammarterm>
      for each occurrence of <code>auto</code> in the 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
      <code>F</code>, in order of appearance. 

<!--
      The invented type <cxx-grammarterm>template-parameter</cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
      declares a function parameter pack. 
 -->

      The function parameters of <code>T</code> are derived from the
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
      <code>F</code> by replacing each occurrence of <code>auto</code> with the 
      name of the corresponding invented 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>.
      
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(auto);
void f2(auto&amp;, auto);
auto f3(void (*)(auto));
void f4(auto (*)(int));
void f5(Vec&lt;auto&gt;&amp;);
void f6(Pair&lt;const auto&amp;, auto*&gt;);

template&lt;typename T&gt; void g1(T);           // <i>OK: Equivalent to</i> f1(auto)
template&lt;typename T1, typename T2&gt; 
  void g2(T1&amp;, T2);                        // <i>OK: Equivalent to</i> f2(auto&amp;, auto)
template&lt;typename T&gt; void g3(void (*)(T)); // <i>OK: Equivalent to</i> f3(void (*)(auto))
template&lt;typenaem T&gt; void g4(T (*)(int));  // <i>OK: Equivalent to</i> f4(auto (*)(int))
template&lt;typename T&gt; void g5(Vec&lt;T&gt;&amp;);     // <i>OK: Equivalent to</i> f5(Vec&lt;auto&gt;&amp;)
template&lt;typename T1, typename T2&gt; 
  void g6(Pair&lt;const T1&amp;, T2*&gt;);           // <i>OK: Equivalent to</i> f6(Pair&lt;const auto&amp;, auto*&gt;)
      </cxx-codeblock>
      </cxx-example>
      </p>

      <!-- TODO: Variadics are broken. We're allowed to use multiple autos
           per parameter type. If the parameter declares a function
           parameter pack, the there must be at most one auto specifiers.

           void f(vector<auto>... Ts); // Ok?
       -->


      <!-- TODO: Move into temp.fct? -->
      <p> A function template can be an abbreviated function. The
      invented <cxx-grammarterm>template-parameter</cxx-grammarterm>s are
      added to the <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm>template-parameter</cxx-grammarterm>s.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: Equivalent to f(Array&lt;auto, N&gt;*)
      </cxx-codeblock>
      </cxx-example>
      </p>

      <!--

      <p>A <defn>generic function</defn> is a function template whose
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> has a 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> whose 
      <cxx-grammarterm>type-specifier</cxx-grammarterm> is either 
      <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.
      </p>

      <p>The declaration of a generic function has a 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> that 
      consists of one invented type 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> for each
      occurrence of <code>auto</code> or each unique occurrence of a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
      in the function's
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
      in order of appearance. 
      
      The invented type of 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> is a parameter 
      pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> declares 
      a function parameter pack (<cxx-ref in="cxx" to="dcl.fct"></cxx-ref>).
      
      If the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of the 
      corresponding <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
      includes a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      the invented type parameter is a 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, whose
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> matches
      that of the <cxx-grammarterm>parameter-declaration</cxx-grammarterm>.
      (<cxx-ref to="temp.param"></cxx-ref>).</ins>

      <cxx-example class="inline">
      The following generic function declarations are equivalent:
      <cxx-codeblock>
template&lt;typenaem T&gt;
  conxtexpr bool C() { ... }

auto f(auto x, const C&amp; y);

template&lt;typename T1, C T2&gt;
  auto f(T1 x, const T2&amp; y);
      </cxx-codeblock>
      The type of <code>y</code> is a type parameter constrained by
      <code>C</code>.
      </cxx-example>
      </p>

      <p>All placeholder types introduced using the same 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm> have the 
      same invented template parameter.
      <cxx-example class="inline">
      The following generic function declarations are equivalent:
      <cxx-codeblock>
auto g(C a, C* b);

template&lt;C T&gt;
  auto g(T a, T* b);
      </cxx-codeblock>
      </cxx-example>
      </p>
      -->

    </cxx-section> <!-- dcl.fct -->
  </cxx-section> <!-- dcl.meaning -->

  <cxx-section id="dcl.fct.def">
    <h1>Function definitions</h1>

    <cxx-section id="dcl.fct.def.general">
      <h1>In general</h1>
    
      <p>Modify the <cxx-grammarterm>function-definition</cxx-grammarterm>
      syntax in <cxx-ref in="cxx" to="dcl.fct.def.general">/1</cxx-ref>
      to include a <cxx-grammarterm>requires-clause</cxx-grammarterm>.</p>

      <bnf-grammar>
        <bnf-rule>function-definition</bnf-rule>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt>
            <bnf-opt>decl-specifier-seq</bnf-opt>
            declarator
            <bnf-opt>virt-specifier-seq</bnf-opt>
            <ins><bnf-opt>requires-clause</bnf-opt></ins>
            function-body
          </bnf-alt>
      </bnf-grammar>

      <p>Add the following paragraph at the end of
      <cxx-ref in="cxx" to="dcl.fct.def.general">/1</cxx-ref>.</p>

      <p>A <cxx-grammarterm>requires-clause</cxx-grammarterm> 
      (<cxx-ref to="temp"></cxx-ref>) shall only be present if the
      <cxx-grammarterm>declarator</cxx-grammarterm> declares a generic
      function (<cxx-ref to="dcl.fct"></cxx-ref>) or a member function
      definition (<cxx-ref to="class.mem"></cxx-ref>).
      <cxx-note>
      Constraints for a function template or member function template are
      written after the <cxx-grammarterm>template-parameter-list</cxx-grammarterm>.
      </cxx-note>
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = ...;
template&lt;typename T&gt; concept bool C2 = ...;
template&lt;typename T, typename U&gt; concept bool D = ...;

void f(C1 a, C2 b) requires D&lt;decltype(a), decltype(b)&gt; { } // Ok

template&lt;typename T&gt;
  void f(const T& x) requires C&lt;T&gt;; // Error: f is declared as a template

template&lt;typename T&gt;
  struct S1 {
    S1(T&) requires C1&lt;T&gt; { }   // Defines a constrained constructor
    void f() requires C2&lt;T&gt; { } // Defines a constrained member function
  };

struct S2 {
  void g(auto x) requires D&lt;decltype(x)&gt; { } // Ok
};
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>A <cxx-grammarterm>function-definition</cxx-grammarterm>
      shall not declare a destructor (<cxx-ref in="cxx" to="class.dtor"></cxx-ref>)
      with a <cxx-grammarterm>requires-clause</cxx-grammarterm>.
    </cxx-section> <!-- dcl.fct.def.general -->
  </cxx-section> <!-- dcl.fct.def -->

</cxx-clause> <!-- dcl.decl -->
