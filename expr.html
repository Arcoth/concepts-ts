<cxx-clause id="expr" number="5">
  <h1>Expressions</h1>

  <!-- ===================
       Primary expressions
       =================== -->

  <cxx-section id="expr.prim">
    <h1>Primary expressions</h1>

    <p>In <cxx-ref in="cxx" to="expr.prim.general"></cxx-ref>, add
    <cxx-grammarterm>requires-expression</cxx-grammarterm> to the
    rule, <cxx-grammarterm>primary-expression</cxx-grammarterm>.</p>
    
    <bnf-grammar>
      <bnf-rule>primary-expression</bnf-rule>
        <ins><bnf-alt>requires-expression</bnf-alt></ins>
    </bnf-grammar>


  <!-- ==================
       Lambda expressions
       ================== -->

    <cxx-section id="expr.prim.lambda" number="2">
      <h1>Lambda expressions</h1>

      Insert the following paragraph after paragraph 4 to define the
      term "generic lambda". 

      <p number="5" class="quoted">
      A <dfn>generic lambda</dfn> is a 
      <cxx-grammarterm>lambda-expression</cxx-grammarterm> where either the
      <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.auto"></cxx-ref>)
      or a
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.constr"></cxx-ref>)
      appears in a parameter type of the
      <cxx-grammarterm>lambda-declarator</cxx-grammarterm>.
      </p>

      Modify paragraph 5 so that the meaning of a generic lambda is defined 
      in terms of its abbreviated member function call operator.

      <p number="6" class="quoted">
      The closure type for a non-generic
      <cxx-grammarterm>lambda-expression</cxx-grammarterm> has a public inline 
      function call operator (<cxx-ref in="cxx" to="over.call"></cxx-ref>)
      whose parameters and return type are described by the 
      <cxx-grammarterm>lambda-expression</cxx-grammarterm>’s 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> and 
      <cxx-grammarterm>trailing-return-type</cxx-grammarterm> respectively. 

      <del>
      For a generic lambda, the closure type has a public inline function call
      operator member template (<cxx-ref to="temp.mem"></cxx-ref>) whose 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> consists of 
      one invented type <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      for each occurrence of <code>auto</code> in the lambda’s 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, in order 
      of appearance.

      The invented type <cxx-grammarter>template-parameter</cxx-grammarter> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm>parameter-declaration declares</cxx-grammarterm> a 
      function parameter pack (<cxx-ref to="dcl.fct"></cxx-ref>). 

      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm>lambda-expression</cxx-grammarterm>’s 
      <cxx-grammarterm>trailing-return-type</cxx-grammarterm> and 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> by 
      replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm>decl-specifier</cxx-grammarterm>s of the 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
      with the name of the corresponding invented template-parameter.
      </del>

      <ins>
      For a generic lambda, the function call operator is an abbreviated
      member function, whose parameters and return type are derived according
      to the rules in <cxx-ref to="dcl.fct"></cxx-ref>.
      </ins>
      </p>

      Add the following example after those in 
      <cxx-ref in="cxx" to="expr.prim.lambda"></cxx-ref>/5. Note that
      the existing examples in the original document are omitted in this
      document.

      <p number="5" class="quoted">
      <ins>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

auto gl = [](C& a, C* b) { a = *b }; // <i>OK: denotes a generic lambda</i>

struct Fun {
    auto operator()(C& a, C* b) const { a = *b; }
} fun;
      </cxx-codeblock>
      <code>C</code> is a 
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      signifying that the lambda is generic. The generic lambda, <code>gl</code>, 
      and the function object, <code>fun</code>, have equivalent behavior when 
      called with the same arguments.
      </cxx-example>
      </ins>
      </p>

    </cxx-section> <!-- expr.prim.lambda -->

  <!-- ====================
       Requires expressions
       ==================== -->


  <cxx-section id="expr.prim.req">
    <h1>Requires expressions</h1>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    <bnf-grammar>
      <bnf-rule>requires-expression</bnf-rule>
        <bnf-alt><bnf-terminal>requires</bnf-terminal> 
          requirement-parameter-list requirement-body</bnf-alt>

    <bnf-rule>requirement-parameter-list</bnf-rule>
      <bnf-alt>
        <bnf-terminal>(</bnf-terminal> 
        <bnf-opt>parameter-declaration-clause</bnf-opt>
        <bnf-terminal>)</bnf-terminal>
      </bnf-alt>

    <bnf-rule>requirement-body</bnf-rule>
      <bnf-alt>
        <bnf-terminal>{</bnf-terminal> 
        requirement-list 
        <bnf-terminal>}</bnf-terminal> 
      </bnf-alt>

    <bnf-rule>requirement-list</bnf-rule>
      <bnf-alt>requirement <bnf-terminal>;</bnf-terminal></bnf-alt>
      <bnf-alt>requirement-list requirement</bnf-alt>

    <bnf-rule>requirement</bnf-rule>
      <bnf-alt>simple-requirement</bnf-alt>
      <bnf-alt>compound-requirement</bnf-alt>
      <bnf-alt>type-requirement</bnf-alt>
      <bnf-alt>nested-requirement</bnf-alt>
    </bnf-grammar>


    <bnf-rule>compound-requirement</bnf-rule>
      <bnf-alt>
        <bnf-opt><bnf-terminal>constexpr</bnf-terminal></bnf-opt>
        <bnf-terminal>{</bnf-terminal> expression <bnf-terminal>}</bnf-terminal>
        <bnf-opt><bnf-terminal>noexcept</bnf-terminal></bnf-opt>
        <bnf-opt>trailing-return-type</bnf-opt>
        <bnf-terminal>;</bnf-terminal>
      </bnf-alt>

    <bnf-rule>nested-requirement</bnf-rule>
      <bnf-alt>requires-clause <bnf-terminal>;</bnf-terminal></bnf-alt>
    </bnf-grammar>
    </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> has type
    <code>bool</code>. </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> shall not appear
    outside of a concept definition (<cxx-ref to="dcl.concept"></cxx-ref>) or a
    <cxx-grammarterm>requires-clause</cxx-grammarterm>. </p>

    <p>
    <cxx-example>
    The most common use of 
    <cxx-grammarterm>requires-expression</cxx-grammarterm>s is to define
    syntactic requirements in concepts (<cxx-ref to="dcl.concept"></cxx-ref>) 
    such as the one below:
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -> const A&lt;T&gt;&amp;;
    };
  }
    </cxx-codeblock>
    The concept is defined in terms of the syntactic and type requirements 
    within the <cxx-grammarterm>requires-expression</cxx-grammarterm>.
    
    A <cxx-grammarterm>requires-expression</cxx-grammarterm> can also be
    used in a <cxx-grammarterm>requires-clause</cxx-grammarterm> templates 
    as a way of writing ad hoc constraints on template arguments such as 
    the one below:
    <cxx-codeblock>
template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The <cxx-grammarterm>requires-expression</cxx-grammarterm> may introduce
    local arguments via a <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>. 
    These parameters have no linkage, storage, or lifetime.
    They are used only to write constraints within the
    <cxx-grammarterm>requirement-body</cxx-grammarterm> and are not visible
    outside the closing <code>}</code> of the 
    <cxx-grammarterm>requirement-body</cxx-grammarterm>. 
    The <cxx-grammarterm>requirement-parameter-list</cxx-grammarterm> shall
    not include an ellipsis.</p>

    <p>The <cxx-grammarterm>requirement-body</cxx-grammarterm> is a sequence of
    <cxx-grammarterm>requirement</cxx-grammarterm>s separated by semicolons.
     These <cxx-grammarterm>requirement</cxx-grammarterm>s may refer to local 
    arguments, template parameters, and any other declarations visible from the 
    enclosing context. Each <cxx-grammarterm>requirement</cxx-grammarterm> 
    introduces a conjunction of one or more atomic constraints 
    (<cxx-ref to="temp.constr"></cxx-ref>). The kinds of atomic constraints
    introduced by a <cxx-grammarterm>requirement</cxx-grammarterm> are:


    <!-- FIXME: This is wrong. Requires-expressions do not evaluate
    to true... they are normalized as constraints. -->
    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> evaluates to
    <code>true</code> if and only the atomic constraints introduced by
    each <cxx-grammarterm>requirement</cxx-grammarterm> in the 
    <cxx-grammarterm>requirement-list</cxx-grammarterm> are satisfied
    and <code>false</code> otherwise. The semantics of each kind of 
    requirement are described in the following sections.</p>


  <!-- ====================
       Simple requirements
       ==================== -->

    <cxx-section id="expr.prim.req.simple">
      <h1>Simple requirements</h1>

      <bnf-grammar>
        <bnf-rule>simple-requirement</bnf-rule>
          <bnf-alt>expression</bnf-alt>
      </bnf-grammar>

      <p>A <cxx-grammarterm>simple-requirement</cxx-grammarterm> introduces 
      an expression constraint for its 
      <cxx-grammarterm>expression</cxx-grammarterm> 
      (<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C =
  requires (T a, T b) {
    a + b;  // <i>a simple requirement</i>
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>If the expression would always result in a substitution failure, 
      the program is ill-forme  d.
      <cxx-example class="inline">
      <cxx-codeblock>
template<typenamne T> concept bool C =
  requires () {
    new T[-1];  // <i>error: the expression will never be well-formed</i>
  };
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- expr.prim.req.simple -->


  <!-- =================
       Type requirements
       ================= -->

    <cxx-section id="expr.prim.req.type">
      <h1>Type requirements</h1>

      <bnf-grammar>
        <bnf-rule>type-requirement</bnf-rule>
          <bnf-alt>
            typename-specifier
          </bnf-alt>
      </bnf-grammar>

      <p>A <cxx-grammarterm>type-requirement</cxx-grammarterm> introduces 
      type constraint for the type named by its 
      <cxx-grammarterm>typename-specifier</cxx-grammarterm>.
      
      <cxx-note>
      A type requirement requests the validity of an associated
      type, either as a nested type name, a class template specialization,
      or an alias template. It is not used to specify requirements for
      arbitrary <cxx-grammarterm>type-specifiers</cxx-grammarterm>.
      </cxx-note>
      
      <cxx-example class="inline">
      <cxx-codeblock>
template<typename T> struct S { };
templtae<typename T> using Ref = T&amp;;

template&lt;typename T&gt; concept bool C =
  requires () {
    typename T::inner;   // <i>required nested type name</i>
    template S&lt;T&gt;;   // <i>required class template specialization</i>
    typename Ref&lt;T&gt;; // <i>required alias template substitution</i>
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>If the required type will always result in a substitution failure,
      then the program is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
teplate&lt;typename T&gt; concept bool C =
  requires () {
    typename int::X;  // <i>error: int does not have class type</i>
  };
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- expr.prim.req.type -->



    <cxx-section id="expr.prim.req.nested">
      <h1>Nested requirements</h1>
      <p>A <cxx-grammarterm>nested-requirement</cxx-grammarterm> introduces
      an additional constraint expression <cxx-ref to="temp.constr"></cxx-ref> 
      to be evaluated as part of the satisfaction of the 
      <cxx-grammarterm>requires-expression</cxx-grammarterm>. 
      The requirement is satisfied if and only if the constraint evaluates to
      value <code>true</code>.
      <cxx-example class="inline"> 
      Nested requirements are generally used to provide additional constraints on 
      associated types
      within a <cxx-grammarterm>requires-expression</cxx-grammarterm>.
      <cxx-codeblock>
requires () {
  typename X<T>;
  requires C&lt;X&lt;T&gt;&gt;();
}
      </cxx-codeblock>
      These requirements are satisfied only when substitution into 
      <code>X&lt;T&gt;</code> is successful and when 
      <code>C&lt;X&lt;T&gt;&gt;()</code> evaluates to <code>true</code>.
      </cxx-example>
      </p>
    </cxx-section> <!-- expr.prim.req.nested -->



    <cxx-section id="expr.prim.req.compound">
      <h1>Compound requirements</h1>
      <p>A <cxx-grammarterm>compound-requirement</cxx-grammarterm> introduces 
      a conjunction of one or more constraints pertaining to its
      <cxx-grammarterm>expression</cxx-grammarterm>, depending on the syntax
      used. This set includes:
      <ul>
      <li>a valid expression constraint,</li>
      <li>an optional associated type constraint</li>
      <li>an optional result type constraint,</li>
      <li>an optional constant expression constraint, and </li>
      <li>an optional exception constraint.</li>
      </ul>
      A <cxx-grammarterm>compound-requirement</cxx-grammarterm> is
      satisfied if and only if every constraint in the set is satisfied.
      
      <!-- BUG: There is a core issue on this -->
      The required valid expression is an unevaluated operand
      (<cxx-ref in="cxx" to="basic.def.odr"></cxx-ref>)
      except in the case when the <code>constexpr</code> specifier is present.
      These other requirements are described in the following paragraphs.
      <!-- </p> -->

      <p>The brace-enclosed <cxx-grammarterm>expression</cxx-grammarterm> in
      a <cxx-grammarterm>compound-requirement</cxx-grammarterm> introduces
      a valid expression constraint. Let <code>E</code> be the valid expression
      resulting from successful substitution.

      <p>The presence of a
      <cxx-grammarterm>trailing-return-type</cxx-grammarterm> introduces 
      a result type constraint on <code>E</code>.</p>

      <p>If the <code>constexpr</code> specifier is present then a constant 
      expression constraint is introduced for the valid expression 
      <code>E</code>.</p>

      <p>If the <code>noexcept</code> specifier is present, then an
      exception constraint is introduced for the valid expression
      <code>E</code>.</p>

      <p>
      <cxx-example>
      <cxx-codeblock>
template&lt;typename I&gt;
  concept bool Inscrutable() { ... }

requires(T x) {
  {x++}; #1
  {*x} -> typename T::r; #2
  {f(x)} -> const Inscrutable&amp;; #3
  {g(x)} noexcept -> auto&amp;; #4
  constexpr {T::value}; #5
  constexpr {T() + T()} -> T; #6;
}
      </cxx-codeblock>
      Each of these requirements introduces a valid expression constraint
      on the expression in its enclosing braces.

      Requirement #1 introduces no additional constraints. It is equivalent to 
      a <cxx-grammarterm>simple-requirement</cxx-grammarterm> containing the 
      same expression.
      
      Requirement #2 <code>*x</code> introduces a result type constraint
      through its <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
      <code>typename T::r</code>. The required valid expression <code>*x</code> 
      must be usable as an argument to the invented function:
      <cxx-codeblock>
template&lt;class T&gt; 
  void z1(typename T::r);
      </cxx-codeblock>

      Requirement #3 also introduces a result type constraint on its required
      valid expression <code>f(x)</code>. This expression must be usable as
      an argument to the invented generic function:
      <cxx-codeblock>
void z2(const Inscrutable&amp;)
      </cxx-codeblock>
      
      Requirement #4 introduces a result type constraint and an exception 
      constraint. The required valid expression <code>g(x)</code> must
      be usable as as an argument to the invented generic function:
      <cxx-codeblock>
void z3(auto&amp;);
      </cxx-codeblock>
      Additionally, <code>g(x)</code> must not propagate exceptions.

      Requirement #5 introduces a constant expression constraint:
      <code>T::value</code> must be a constant expression. 

      The requirement in #6 introduces a result type constraint and a constant 
      expression constraint. The required valid expression 
      <code>T() + T()</code> must be usable as an argument to the invented 
      function:
      <cxx-codeblock>
template&lt;class T&gt;
  void z4(T);
      </cxx-codeblock>
      The valid expression must also be a constant expression.
      </cxx-example>
      </p>
    </cxx-section> <!-- expr.prim.req.compound -->
 
  </cxx-section> <!-- expr.prim.req -->
</cxx-clause> <!-- expr -->
