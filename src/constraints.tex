
%%
%% Template constraints
%%
\rSec1[temp.constr]{Template constraints}

Add this section after 14.8.

\begin{quote}

\pnum
\enternote
This section defines the meaning of constraints on template arguments.
% 
The abstract syntax, satisfaction rules, and equivalence rules are defined
in \ref{temp.constr.constr}. 
% 
Constraints are associated with declarations in \ref{temp.constr.decl}.
% 
Declarations are partially ordered by their associated constraints 
(\ref{temp.constr.order}).
\exitnote


%%
%% Constraints
%%
\rSec2[temp.constr.constr]{Constraints}

\pnum
A \defn{constraint} is a sequence of logical operations and 
operands that specifies requirements on template arguments.
\enternote The operands of a logical operation are constraints. \exitnote


\pnum
A constrained declaration can be used only when its associated
constraints (\ref{temp.constr.decl}) are \defn{satisfied}. 
% 
Determining if a constraint is satisfied entails the the substitution 
of template arguments into its types and expressions. If that substitution
results in an invalid type or expression, the constraint is not satisfied.
% 
The rules for determining the satisfaction of different kinds of 
constraints are defined in the following sections.

% \pnum
% After substitution, a constraint is \defn{satisfied} if and only if 
% it and all of its operands are satisfied according to the evaluation 
% rules described in \ref{temp.constr.op} and \ref{temp.constr.atom}.
% % 
% If the substitution of template arguments into a constraint fails, 
% that constraint is not satisfied.
% % 
% \enternote
% Substitution into a constraint may yield a well-formed constraint that
% contains ill-formed expressions or types. This may happen, for
% example, in the substitution into expression constraints
% (\ref{temp.constr.atom.expr}) and type constraints
% (\ref{temp.constr.atom.type}).
% \exitnote

\pnum 
In certain contexts, it is necessary to know when two constraints are equivalent
(\ref{temp.constr.decl}). Two constraints \tcode{P} and \tcode{Q} are
equivalent if and only if they are of the same kind and their their operands are
equivalent. The rules for determining the equivalence of different kinds of
constraints are defined in the following expressions.


%%
%% Logical operations
%%
\rSec3[temp.constr.op]{Logical operations}

\pnum
There are two binary logical operations on constraints: conjunction
and disjunction.
% 
\enternote 
These logical operations have no corresponding C++ syntax.
For the purpose of exposition, conjunction is spelled
using the symbol $\land$ and disjunction is spelled using the 
symbol $\lor$. 
% 
The operands of these operations are called the left 
and right operands. In the constraint \tcode{P} $land$ \tcode{Q},
\tcode{P} is the left operand and \tcode{Q} is the right operand.
% 
Grouping of constraints is shown using parentheses.
\exitnote

\pnum
A \defn{conjunction} is a logical operation taking two 
operands. A conjunction of constraints is satisfied if and only 
if both operands are satisfied. 
% 
The satisfaction of a conjunction's operands are evaluated left-to-right; 
if the left operand is not satisfied, template arguments are not 
substituted into the right operand, and the constraint is not satisfied.

\pnum
A conjunction \tcode{P} is equivalent to another conjunction \tcode{Q}
if and only if the left operands of \tcode{P} and \tcode{Q} are equivalent
and the right operands of \tcode{P} and \tcode{Q} are equivalent.

\pnum
A \defn{disjunction} is a logical operation taking two 
operands. A disjunction of constraints is satisfied if and only 
if either operand is satisfied or both operands are satisfied.
% 
The satisfaction of a disjunction's operands are evaluated left-to-right; 
if the left operand is satisfied, template arguments are not 
substituted into the right operand, and the constraint is satisfied.

\pnum
A disjunction \tcode{P} is equivalent to another disjunction \tcode{Q}
if and only if the left operands of \tcode{P} and \tcode{Q} are equivalent
and the right operands of \tcode{P} and \tcode{Q} are equivalent.


%%
%% Predicate constraints
%%
\rSec3[temp.constr.pred]{Predicate constraints}

\pnum
A \defn{predicate constraint} is a constraint that evaluates a prvalue 
constant expression \tcode{E} of type \tcode{bool} (\cxxref{expr.const}).
% 
The constraint is satisfied if and only if \tcode{E} evaluates to 
\tcode{true}.
% 
\enternote
Predicate constraints allow the definition of template requirements
in terms of constant expressions. This allows the specification 
constraints on non-type template arguments and template template 
arguments.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 4 && !true;
\end{codeblock}
Here, \tcode{sizeof(T) == 4} and \tcode{!true} are 
predicate constraints required by the concept, \tcode{C}.
\exitexample

\pnum
A predicate constraint \tcode{P} is equivalent to another predicate
\tcode{Q} if and only if the expressions of \tcode{P} and \tcode{Q}
are equivalent using the rules described in \ref{temp.over.link} to compare
expressions.

% \enterexample
% The predicate \tcode{M >= 0} does not subsume the predicate
% \tcode{M > 0} because they are not equivalent.
% \exitexample



%%
%% Expression constraints
%%
\rSec3[temp.constr.expr]{Expression constraints}

\pnum
An \defn{expression constraint} is an atomic constraint
that specifies a requirement on the formation of an
\grammarterm{expression} \tcode{E}
through substitution of template arguments.
% 
An expression constraint is satisfied if substitution 
yielding \tcode{E} did not fail. 
% 
Within an expression constraint, \tcode{E} is an unevaluated 
operand (Clause \ref{expr}).
% 
\enternote
An expression constraint is introduced by the \grammarterm{expression} in 
either a \grammarterm{simple-requirement} (\ref{expr.prim.req.simple})
or \grammarterm{compound-requirement} (\ref{expr.prim.req.compound})
of a \grammarterm{requires-expression}.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { ++t; };
\end{codeblock}
The concept \tcode{C} introduces an expression constraint for 
the expression \tcode{++t}.
% 
The type argument \tcode{int} satisfies this constraint because the
the expression \tcode{++t} is valid after substituting \tcode{int}
for \tcode{T}.
\exitexample

\pnum
An expression constraint \tcode{P} is equivalent to another expression
constraint \tcode{Q} if and only if the \tcode{expression}{}s of
\tcode{P} and \tcode{Q} are equivalent using the rules described 
in \ref{temp.over.link} to compare expressions.


%%
%% Type constraints
%%
\rSec3[temp.constr.type]{Type constraints}

\pnum
A \defn{type constraint} is an atomic constraint that specifies a requirement 
on the formation of a type \tcode{T} through the substitution of template 
arguments.
% 
A type constraint is satisfied if and only \tcode{T} is non-dependent, meaning 
that the substitution yielding \tcode{T} did not fail.
% 
\enternote
A type constraint is introduced by the \grammarterm{typename-specifier} in a
\grammarterm{type-requirement} of a \grammarterm{requires-expression}
(\ref{expr.prim.req.type}).
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires () { typename T::type; };
\end{codeblock}
The concept \tcode{C} introduces a type constraint for the 
type name \tcode{T::type}.
% 
The type \tcode{int} does not satisfy this constraint
because substitution of that type into the constraint results in a
substitution failure; \tcode{typename int::type} is ill-formed.
\exitexample

\pnum
A type constraint that names a class template specialization 
does not require that type to be complete 
(\cxxref{basic.types}).

\pnum
A type constraint \tcode{P} is equivalent to another type
constraint \tcode{Q} if and only if the types in \tcode{P}
and \tcode{Q} are equivalent according to the rules in
\cxxref{temp.type}.


%%
%% Implicit conversion constraints
%%
\rSec3[temp.constr.conv]{Implicit conversion constraints}

\pnum
An \defn{implicit conversion constraint} is an atomic constraint that 
specifies a requirement on the implicit conversion of an \grammarterm{expression}
\tcode{E} to a type \tcode{T}. 
% 
The constraint is satisfied if and only if \tcode{E} is implicitly convertible 
to \tcode{T} (Clause~\cxxref{conv}).

\enternote
A conversion constraint is introduced by a \grammarterm{trailing-return-type} 
in a \grammarterm{compound-requirement} when the 
\grammarterm{trailing-return-type} contains no placeholders 
(\ref{expr.prim.req.compound}).
\exitnote

\enterexample
\begin{codeblock}
template<typename T> concept bool C = 
  requires (T a, T b) {
    { a == b } -> bool;
  };
\end{codeblock}
The \grammarterm{compound-requirement} in the
\grammarterm{requires-expression} of \tcode{C} introduces two atomic 
constraints: an expression constraint for \tcode{a == b}, and the implicit 
conversion constraint that the expression \tcode{a == b} is implicitly 
convertible to \tcode{bool}.
\exitexample

\pnum
An implicit conversion constraint \tcode{P} is equivalent to another implicit 
conversion constraint \tcode{Q} if and only if the \grammarterm{expression}{}s 
of \tcode{P} and \tcode{Q} are equivalent using the rules in
\ref{temp.over.link} to compare expressions, and the the types
of \tcode{P} and \tcode{Q} are equivalent according to the rules in
\cxxref{temp.type}.


%%
%% Argument deduction constraints
%%
\rSec3[temp.constr.deduct]{Argument deduction constraints}

\pnum
An \defn{argument deduction constraint} is an atomic
constraint that specifies a requirement on 
the usability of an \grammarterm{expression} 
\tcode{E} as an argument to an invented abbreviated
function template \tcode{F} (\ref{dcl.fct}),
where \tcode{F} has a single parameter formed from a type that 
includes placeholders 
(\ref{dcl.spec.auto}, \ref{dcl.spec.constr}).
% 
\enternote
An argument deduction constraint is introduced by a
\grammarterm{trailing-return-type} in a
\grammarterm{compound-requirement} when the
\grammarterm{trailing-type-specifier-seq}
contains at least one placeholder
(\ref{expr.prim.req.compound}).
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T>
concept bool C1() { return true; }

template<typename T>
concept bool C2() { return requires(T t) { {*t} -> const C1& x; }; }
\end{codeblock}
The invented function template for the
\grammarterm{compound-requirement} in
\tcode{C2} is:
\begin{codeblock}
void F(const C1& x);
\end{codeblock}
\exitexample
% 
The constraint is satisfied if and only if \tcode{F}
is selected by overload resolution for the call \tcode{F(E)}
(\ref{over.match}).
% 
\enternote
Overload resolution selects \tcode{F} only when template 
argument deduction succeeds and \tcode{F}'s associated 
constraints are satisfied.
\exitnote

\pnum
An argument deduction constraint \tcode{P} is equivalent to another 
argument deduction constraint \tcode{Q} if and only if the 
\grammarterm{expression}{}s of \tcode{P} and \tcode{Q} are equivalent
using the rules in \ref{temp.over.link} to compare expressions, and the types
of \tcode{P} and \tcode{Q} are equivalent according to the rules in 
\cxxref{temp.type}).


%%
%% Exception constraints
%%
\rSec3[temp.constr.noexcept]{Exception constraints}

\pnum
An \defn{exception constraint} is an atomic constraint
for an expression \tcode{E} that is satisfied if and only
if the expression \tcode{noexcept(E)} is \tcode{true}
(\cxxref{expr.unary.noexcept}).
% 
\enternote
Constant expression constraints are introduced by a
\grammarterm{compound-requirement} that
includes the \tcode{noexcept} specifier
(\ref{expr.prim.req.compound}).
\exitnote

\pnum
An exception constraint \tcode{P} subsumes another
exception constraint \tcode{Q} if and only if the
\grammarterm{expression}{}s of \tcode{P}
and \tcode{Q} are equivalent using the rules in \ref{temp.over.link}
to compare expressions.


%%
%% Constrained declarations
%^
\rSec2[temp.constr.decl]{Constrained declarations}

\pnum
The \defn{associated constraints} of a template declaration are 
the conjunction of constraints introduced by:
% 
\begin{itemize}
\item a template introduction (\ref{temp.intro}), and

\item any constrained template parameters (\ref{temp.param}) in the 
declaration's \grammarterm{template-parameter-list}, and

\item a \grammarterm{requires-clause} following a
\grammarterm{template-parameter-list}, and

\item any \grammarterm{constrained-type-specifier}{}s in the type of a 
\grammarterm{parameter-declaration} in a function declaration 
(\ref{dcl.spec.constr}), and

\item a \grammarterm{requires-clause} appearing in the \grammarterm{declarator} 
of a function declaration (\ref{dcl.fct}).
\end{itemize}
% 
The formation of the associated constraints for a template declaration
defines the order in which constraints are compared for equivalence
(to determine when one template redeclares another) and evaluated for
satisfaction.

\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;

// all of the following declare the same function:
void f(C);
template<C T> void f(T);
C{T} void f(T);
template<typename T> requires C<T> void f(T);
template<typename T> void f(T) requires C<T>;
\end{codeblock}
\exitexample

% FIXME: This is not strong enough. It might be better to define this
% when we enumerate where associated constraints come from. That is,
% introductions, constrained parameters (in the order in which they
% appear), a requires clause after a template parameter list,
% constrained-type-specifiers (in the order in which they appear), and
% a requires clause in a function declarator.
\pnum
The order in which the subexpressions of the associated constraints
are composed is the left-to-right order in which 
\grammarterm{template-introduction}{}s,
\grammarterm{constrained-type-specifier}{}s, and
\grammarterm{requires-clause}{}s occur in the declaration.
% 
\enternote
A program containing two declarations whose associated constraints are 
functionally equivalent but not equivalent (\ref{temp.over.link}) is 
ill-formed, no diagnostic required.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = true;

C1{T} void f1(C2);                                                      // \#1
template<typename T, typename U> requires C1<T> && C2<U> void f1(T, U); // \#2
\end{codeblock}
% 
In the associated constraints of \#1, the constraint associated by the 
\grammarterm{template-introduction} \tcode{C1{T}} occurs before the 
constraint associated by the \grammarterm{constrained-type-specifier} in the
\grammarterm{parameter-declaration} \tcode{C2}.
% 
The resulting \grammarterm{constraint-expression} is equivalent to the 
\grammarterm{requires-clause} in \#2.
% 
\begin{codeblock}
C1{T} void f2(T) requires C2<T>;                        // \#1
template<typename T> requires C1<T> && C2<T> void f2(); // \#2
\end{codeblock}
The associated constraints of \#1 and \#2 are equivalent.

\begin{codeblock}
template<C1 T> requires C2<T> void f3(T);                // \#1
template<C1 T> void f3(T) requires C2<T>;                // \#2
template<typename T> requires C1<T> && C2<T> void f3(T); // \#3
template<typename T> void f3(T) requires C1<T> && C2<T>; // \#4
\end{codeblock}
The associated constraints of \#1, \#2, \#3, and \#4 are equivalent. The 
\grammarterm{constraint-expression} associated by \tcode{C1} occurs before 
the constraint associated by \tcode{C2} in each declaration.
% 
\begin{codeblock}
template<C1 T> requires C2<T> void f5();
template<C2 T> requires C1<T> void f5(); // error: constraints are functionally equivalent but not equivalent
\end{codeblock}
% 
The associated constraints of the first declaration are
\tcode{C1<T> \&\& C2<T>}, and those of the second are
\tcode{C2<T> \&\& C1<T>}.
\exitexample
\end{quote}




%%
%% Partial ordering by constraints
%%
\rSec2[temp.constr.order]{Partial ordering by constraints}

\pnum
A constraint \tcode{P} is said to \defn{subsume} another constraint \tcode{Q} 
if, informally, it can be determined that \tcode{P} implies \tcode{Q}, up to 
the equivalence of types and expressions. 
% 
\enternote
Subsumption does not determine, for example, if the predicate 
constraint (\ref{temp.constr.pred}) \tcode{N \% 2 == 1} subsumes 
\tcode{N \& 1} for some integral template argument, \tcode{N}.
\exitnote


% TODO: If I add a quantified constraint (which I will), then this
% rewriting needs to lift its conjunctions out of it.

\pnum
In order to determine if a constraint \tcode{P} subsumes a constraint
\tcode{Q}, transform \tcode{P} into disjunctive normal form, 
and transform \tcode{Q} into conjunctive normal form\footnote{
A constraint is in disjunctive normal form when it is a disjunction of
clauses where each clause is a conjunction of atomic constraints. 
% 
Similarly, a constraint is in conjunctive normal form when it is a conjunction 
of clauses where each each clause is disjunction of atomic constraints.
\enterexample
Let \tcode{A}, \tcode{B}, and \tcode{C} be atomic
constraints. 
% 
The constraint \tcode{A} $\land$ (\tcode{B} $\lor$ \tcode{C}) is in 
conjunctive normal form.
% 
Its conjunctive clauses are \tcode{A} and (\tcode{B} $\lor$ \tcode{C}).
% 
The disjunctive normal form of the constraint
\tcode{A} $\land$ (\tcode{B} $\lor$ \tcode{C}) 
is
(\tcode{A} $\land$ \tcode{B}) $\lor$ (\tcode{A} $\land$ \tcode{C}).
% 
Its disjunctive clauses are (\tcode{A} $\land$ \tcode{B}) and 
(\tcode{A} $\land$ \tcode{C}).
\exitexample
}.
% 
Then, \tcode{P} subsumes \tcode{Q} if and only if
\begin{itemize}
\item for every disjunctive clause \tcode{P$i$} in the disjunctive normal 
form of \tcode{P}, \tcode{P$i$} subsumes every conjunctive clause \tcode{Q$j$} 
in the conjuctive normal form of \tcode{Q}, where

\item a disjunctive clause \tcode{P$i$} subsumes a conjunctive clause
\tcode{Q$j$} if and only if each atomic constraint in \tcode{P$i$} subsumes 
any atomic constraint \tcode{Q$j$}, where

\item an atomic constraint \tcode{A} subsumes another atomic constraint
\tcode{B} if and only if the \tcode{A} and \tcode{B} are equivalent using the
rules described in \ref{temp.constr.constr} to compare constraints.
\end{itemize}
% 
\enterexample
Let \tcode{A} and \tcode{B} be atomic constraints (\ref{temp.constr.pred}).
% 
The constraint \tcode{A $\land$ B} subsumes \tcode{A}, 
but \tcode{A} does not subsume \tcode{A $\land$ B}. 
% 
The constraint \tcode{A} subsumes \tcode{A $\lor$ B}, but
\tcode{A $\lor$ B} does not subsume \tcode{A}. 
% 
Also note that every constraint subsumes itself.
\exitexample


\pnum
The subsumption relation defines a partial ordering on constraints. 
This partial ordering is used to determine
% 
\begin{itemize}
\item the best viable candidate of non-template functions
     (\ref{over.match.best}), 
\item the address of a non-template function
     (\ref{over.over}), 
\item the matching of template template arguments
     (\ref{temp.arg.template}), 
\item the partial ordering of class template specializations
     (\ref{temp.class.order}), and
\item the partial ordering of function templates
     (\ref{temp.func.order}).
\end{itemize}

\pnum
When two declarations \tcode{D1} and \tcode{D2} are
partially ordered by their normalized constraints, \tcode{D1} is 
\defn{more constrained} than \tcode{D2} if
% 
\begin{itemize}
\item \tcode{D1} and \tcode{D2} are both constrained
declarations and \tcode{D1}'s associated constraints subsume but 
are not subsumed by those of \tcode{D2}; or

\item \tcode{D1} is constrained and \tcode{D2} is
unconstrained. 
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = requires(T t) { --t; };
template<typename T> concept bool C2 = C1<T> && requires(T t) { *t; };

template<C1 T> void f(T);       // \#1
template<C2 T> void f(T);       // \#2
template<typename T> void g(T); // \#3
template<C1 T> void g(T);       // \#4

f(0);       // selects \#1
f((int*)0); // selects \#2
g(true);    // selects \#3 because \tcode{C1<bool>} is not satisfied
g(0);       // selects \#4
\end{codeblock}
\exitexample

\pnum
A declaration \tcode{D1} is \defn{at least as constrained}
as another declaration \tcode{D2} when \tcode{D1} is more
constrained than \tcode{D2}, and \tcode{D2} is not more
constrained than \tcode{D1}.


%%
%% Constraint expressions
%%
\rSec2[temp.constr.expr]{Constraint expressions}

\pnum
Certain contexts require expressions that can be transformed
into constraints through the process of \defn{normalization}.

\begin{bnf}
\nontermdef{constraint-expression}\br
    logical-or-expression
\end{bnf}

\pnum
A \grammarterm{constraint-expression} is \defn{normalized} by forming a 
constraint as follows.

\begin{itemize}
\item The normalized form of \tcode{(P)} is the normalized form of 
\tcode{P}.

\item The normalized form of \tcode{P || Q} is
the disjunction (\ref{temp.constr.op}) of the 
normalized form of \tcode{P} and the normalized form of 
\tcode{Q}.

If, after substitution, overload resolution 
(\ref{over.match}) selects a user-declared 
\tcode{operator||}, the program is ill-formed.

\item The normalized form of \tcode{P \&\& Q} is
the conjunction (\ref{temp.constr.op}) of the 
normalized form of \tcode{P} and the normalized form of
\tcode{Q}.

If, after substitution, overload resolution 
(\ref{over.match}) selects a user-declared 
\tcode{operator\&\&}, the program is ill-formed.

\item The normalized form of a function call of the form
\tcode{C<A$1$, A$2$, ..., A$N$>()},
where \tcode{A$1$, A$2$, ..., A$N$}
is a sequence of template arguments and \tcode{C} names a function
concept (\ref{dcl.spec.concept}), is the result of 
substituting the template arguments into the expression
returned by \tcode{C}.

\item The normalized form of an \grammarterm{id-expression}
of the form \tcode{C<A$1$, A$2$, ..., A$N$>}
where \tcode{A$1$, A$2$, ..., A$N$}
is a sequence of template arguments and \tcode{C} names a variable
concept (\ref{dcl.spec.concept}) is the result of 
substituting the template arguments into the initializer
of \tcode{C}.

\item The normalized form of a 
\grammarterm{requires-expression} 
(\ref{expr.prim.req}) is
the conjunction of constraints (\ref{temp.constr.op}) 
introduced by the body of that expression.


\item Otherwise, \tcode{E} is a predicate constraint 
(\ref{temp.constr.atom.pred}). 
% 
After substitution, \tcode{E} shall be a converted constant 
expression of type \tcode{bool}.

\end{itemize}

% Do we need a top-level conversion requirement for constraint expressions?

\enternote
A \grammarterm{constraint-expression} defines a subset of constant 
expressions over which certain logical implications can be deduced during 
translation.

The prohibition against user-defined logical operators is intended to
prevent the subversion of the logic used to partially order 
constraints (\ref{temp.constr.order}).
\exitnote

% TODO: Make this a table.
\enterexample
\begin{codeblock}
template<typename T> concept bool C1() { return sizeof(T) == 1; }
template<typename T> concept bool C2 = C1<T>() && 1 == 2;
template<typename T> concept bool C3 = requires () { typename T::type; };

// Expression      // Constraints
C2<char>           sizeof(char) == 1 /* and */ 1 == 2
C3<int>            /* type constraint for int::type */
3 + 4              // error: not a constraint
(bool)(3 + 4)      (bool)(3 + 4)
\end{codeblock}
In the normalized constraints, the expressions \tcode{sizeof(char) == 1}, 
\tcode{1 == 2}, and \tcode{(bool)(3 + 4)} are predicate 
constraints (\ref{temp.constr.atom.pred}). 

The concept \tcode{C3} is normalized to a single type constraint
(\ref{temp.constr.atom.type}) for the (ill-formed) 
type \tcode{int::type}.

The expression \tcode{3 + 4} is not a 
\grammarterm{constraint-expression} because it does
not satisfy the requirements for being normalized into a predicate 
constraint.
\exitexample


%%
%% Resolution of constrained-type-specifiers
%%
\rSec2[temp.constr.resolve]{Resolution of \grammarterm{constrained-type-specifier}{}s}

\pnum
Whenever an \grammarterm{identifier} is a \grammarterm{concept-name}, it is 
necessary to determine a single concept referred to by the use of that name.
% 
\defn{Concept resolution} is the process of selecting a concept 
from a set of concept definitions referred to by a concept name.

Concept resolution is performed when a 
\grammarterm{constrained-type-specifier} appears in
the declaration of an abbreviated function (\ref{dcl.fct})
or generic lambda (\ref{expr.prim.lambda}),
in the \grammarterm{trailing-return-type} of a
\grammarterm{compound-requirement}, the
\grammarterm{constrained-type-specifier} of a
\grammarterm{constrained-parameter}, or
in a \grammarterm{template-introduction}.

\pnum
A concept is selected from a set of concepts based on a sequence
of template argument patterns and a sequence of explicit
template arguments. 
% 
A \defn{template argument pattern} is a kind of template argument 
that is used to match the type and form of a template parameter from a 
concept definition. A template argument pattern can be a pack expansion.
% 
A concept is selected from the set by matching the template
argument patterns and explicit template arguments against the template 
parameters of that concept.

\pnum
When selecting a concept for a \grammarterm{constrained-type-specifier},
there is a single template argument pattern. 
% 
If the \grammarterm{constrained-type-specifier} appears in the declaration 
of a \grammarterm{constrained-parameter} (\ref{temp.param}) and is
followed by an ellipsis, the template argument pattern is a pack
expansion.
% 
If the \grammarterm{constrained-type-specifier}
is a \grammarterm{partial-concept-id} the explicit
\grammarterm{template-arguments} are those in
the \grammarterm{partial-concept-id}.
% 
When selecting a concept for a \grammarterm{concept-name} in a 
\grammarterm{template-introduction}, there is one template argument pattern 
for each \grammarterm{introduced-parameter}.
% 
If an \grammarterm{introduced-parameter} is
preceded by an ellipsis, its corresponding template argument pattern
is a pack expansion.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1() { return true; }
template<typename T, typename U> concept bool C1() { return true; }
template<typename... T> concept bool C2() { return true; }
% 
void f1(C1); 
void f2(C1<int>);
\end{codeblock}
% 
In the resolution of \tcode{C1} required by the declaration of \tcode{f1}, 
there is a single template argument pattern and zero explicit template 
arguments.
% 
For \tcode{f2} there is a single template argument pattern and the 
single explicit template argument, \tcode{int}.
\begin{codeblock}
C1{T} void f3(T);
C1{T, U} void f4(T);
\end{codeblock}
In the resolution required by the declaration of \tcode{f3}, there
is a single template argument pattern; there are two in the resolution
required by \tcode{f2}. There are zero explicit template arguments
in the resolutions of \tcode{f1} and \tcode{f2}.
\begin{codeblock}
C2{...T} void f5();
\end{codeblock}
There is a single template argument pattern in the resolution of
\tcode{f2}, and it is a pack expansion.
\exitexample

\pnum
For each concept \tcode{C} in the concept set, each template 
argument in the combined sequence of template argument patterns and explicit 
template arguments is matched against the corresponding template parameter
in the \grammarterm{template-parameter-list} of 
\tcode{C} as follows.
% 
A template argument pattern that is not a parameter pack matches a 
non-pack template parameter of any type and form. A template argument 
pattern that is a parameter pack matches a template parameter pack
whose pattern is any form.
% 
The remaining explicit arguments are matched against parameters
as specified in \ref{temp.arg}.
% 
If any template argument patterns or explicit template arguments do not 
match the corresponding parameter, \tcode{C} is removed from the set.
% 
If a single concept remains, it is the one selected by concept 
resolution. Otherwise, the program is ill-formed. 
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C() { return true; }             // \#1
template<typename T, typename U> concept bool C() { return true; } // \#2
template<typename T> concept bool P() { return true; }
template<int T> concept bool P() { return true; }
template<<typename... Ts> concept bool Q = true;

void f1(const C*);  // OK: \tcode{C} selects \#1
void f2(C<char>);   // OK: \tcode{C<char>} selects \#2
void f3(C<3>);      // error: no matching concept for \tcode{C<3>} (mismatched template arguments)
void g1(P);         // error: resolution of \tcode{P} is ambiguous (\tcode{P} refers to two concepts)
Q{...Ts} void q1(); // OK: selects \tcode{Q}
Q{T} void q2();     // error: no matching concept (mismatched template arguments)
\end{codeblock}
\exitexample

\pnum
For the selected template, the set of template parameters corresponding
to the matched template argument patterns are called the
\defn{selected template parameters}. 
% 
In a \grammarterm{template-introduction} (\ref{temp.intro}), these
are used to derive the declarations of introduced parameters.


%%
%% Constraint formation from constrained-type-specifiers
%%
\rSec2[temp.constr.form]{Constraint formation from \grammarterm{constrained-type-specifier}{}s}

\pnum
When a parameter of an abbreviated function template is declared
with a \grammarterm{constrained-type-specifier},
or in the declaration of a 
\grammarterm{constrained-parameter},
the \grammarterm{constrained-type-specifier}
associates a \grammarterm{constraint-expression}
with the respective function or template declaration.
% 
The formation of that \grammarterm{constraint-expression}
is derived from the \grammarterm{constrained-type-specifier},
the designated concept selected by concept resolution 
(\ref{temp.constr.resolve}), and an 
invented template parameter or a declared template parameter, called
the \defn{target template parameter}.
% 
When the \grammarterm{constrained-type-specifier}
appears in the declaration of a function parameter, the target template
parameter is the one invented for the abbreviated function template
(\ref{dcl.fct}).

When the \grammarterm{constrained-type-specifier}
appears in the declaration of a 
\grammarterm{constrained-parameter},
the target template parameter is the declared template parameter.


\pnum
Let \tcode{C} be the concept designated by the
\grammarterm{constrained-type-specifier} (including its 
\grammarterm{nested-name-specifier}, if any),
let \tcode{P} be the prototype parameter of the designated
concept, and let \tcode{X} be the target template parameter.
% 
Form a new template argument \tcode{A} from \tcode{X} as
as follows. If \tcode{X} declares a parameter pack, and
\tcode{P} declares a parameter pack, \tcode{A}
is a pack expansion of \tcode{X}. Otherwise \tcode{A} is
a template argument referring to \tcode{X}.
% 
Form a \grammarterm{template-id} \tcode{TT}
as follows. 
% 
When the \grammarterm{constrained-type-specifier} is a 
\grammarterm{partial-concept-id}, \tcode{TT} is 
\tcode{C<A, Args>} where \tcode{Args} is the sequence of 
\grammarterm{template-argument}{}s in the
\grammarterm{partial-concept-id}.
% 
Otherwise, \tcode{TT} is \tcode{C<A, Args>}.
% 
Form an expression \tcode{E} from \tcode{TT}. If \tcode{C} refers to a 
variable concept, \tcode{E} is the \grammarterm{id-expression} \tcode{TT}.
% 
If \tcode{C} refers to a function concept, \tcode{E} is the function call 
\tcode{TT()}.

\pnum
The formed constraint is the fold expression \tcode{E1 \&\& E2 \&\& ... \&\& E$N$}
when the prototype parameter \tcode{P} declares a template parameter pack and 
the target template parameter \tcode{X} does not.
% 
Otherwise, the \grammarterm{constraint-expression} is \tcode{E}.
% 
% TODO: Add examples for constrained parameters 
% TODO: Give an example with a nested name specifier.
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T, typename U> concept bool C2() { return true; }
template<typename... Ts> concept bool C3;

template<int> struct X { };

void f1(C1&);     // associates \tcode{C1<T1>} with \tcode{f1}
void f2(C2<int>); // associates \tcode{C2<T2, int>()} with \tcode{f2}
void f3(C1...);   // associates \tcode{(C1<T1> \&\& ...)} with \tcode{f3}
void f4(C3...);   // associates \tcode{C3<T1...>} with \tcode{f4}
\end{codeblock}
% 
Here, \tcode{T1} and \tcode{T2} are invented type template parameters 
corresponding to the prototype parameter of their respective designated 
concepts.

\end{quote}
