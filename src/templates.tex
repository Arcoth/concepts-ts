
%%
%% Templates
%%
\setcounter{chapter}{13}
\rSec0[temp]{Templates}


Modify the \grammarterm{template-declaration} grammar in paragraph 1 to 
allow a template declaration introduced by a concept.

\begin{quote}
\pnum

\begin{bnf}
\nontermdef{template-declaration}\br
  \terminal{template} \terminal{<} template-parameter-list \terminal{>}
    \added{requires-clause\opt} declaration\br
  \added{template-introduction declaration}

\begin{addedblock}
\nontermdef{requires-clause}\br
  \terminal{requires} constraint-expression
\end{addedblock}
\end{bnf}
\end{quote}
  
Add the following paragraphs after paragraph 6.

\begin{quote}
\setcounter{Paras}{6}
\pnum
A \grammarterm{template-declaration} is written in terms of its template 
parameters. These parameters are declared explicitly in a 
\grammarterm{template-parameter-list} (\ref{temp.param}), or they are
introduced by a \grammarterm{template-introduction} (\ref{temp.intro}).


\pnum
The \defn{associated constraints} of a \grammarterm{template-declaration} are 
defined to be a \grammarterm{constraint-expression} formed from the conjunction 
of \grammarterm{constraint-expression}{}s associated by:
% 
\begin{itemize}
\item a constraint associated by a template introduction 
(\ref{temp.intro}), and

\item any constrained template parameters (\ref{temp.param}) in the 
declaration's \grammarterm{template-parameter-list}, and

\item a \grammarterm{requires-clause} following a
\grammarterm{template-parameter-list}, and

\item any \grammarterm{constrained-type-specifier}{}s in the type of a 
\grammarterm{parameter-declaration} in a function declaration 
(\ref{dcl.spec.constr}), and

\item a \grammarterm{requires-clause} appearing in the \grammarterm{declarator} 
of a function declaration (\ref{dcl.fct}).
\end{itemize}
% 
The formation of the associated constraints for a template declaration
gives a definite ordering on subexpressions for the purpose of determining
when one template redeclares another.

\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;

// all of the following declare the same function:
void g(C);
template<C T> void g(T);
C{T} void g(T);
template<typename T> requires C<T> void g(T);

// these also declare the same function:
template<C T> void f();
template<typename T> void f() requires C<T>;
\end{codeblock}
\exitexample

% FIXME: This is not strong enough. It might be better to define this
% when we enumerate where associated constraints come from. That is,
% introductions, constrained parameters (in the order in which they
% appear), a requires clause after a template parameter list,
% constrained-type-specifiers (in the order in which they appear), and
% a requires clause in a function declarator.
\pnum
The order in which the subexpressions of the associated constraints
are composed is the left-to-right order in which 
\grammarterm{template-introduction}{}s,
\grammarterm{constrained-type-specifier}{}s, and
\grammarterm{requires-clause}{}s occur in the declaration.
% 
\enternote
A program containing two declarations whose associated constraints are 
functionally equivalent but not equivalent (\ref{temp.over.link}) is 
ill-formed, no diagnostic required.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = true;

C1{T} void f1(C2);                                                      // \#1
template<typename T, typename U> requires C1<T> && C2<U> void f1(T, U); // \#2
\end{codeblock}
% 
In the associated constraints of \#1, the constraint associated by the 
\grammarterm{template-introduction} \tcode{C1{T}} occurs before the 
constraint associated by the \grammarterm{constrained-type-specifier} in the
\grammarterm{parameter-declaration} \tcode{C2}.
% 
The resulting \grammarterm{constraint-expression} is equivalent to the 
\grammarterm{requires-clause} in \#2.
% 
\begin{codeblock}
C1{T} void f2(T) requires C2<T>;                        // \#1
template<typename T> requires C1<T> && C2<T> void f2(); // \#2
\end{codeblock}
The associated constraints of \#1 and \#2 are equivalent.

\begin{codeblock}
template<C1 T> requires C2<T> void f3(T);                // \#1
template<C1 T> void f3(T) requires C2<T>;                // \#2
template<typename T> requires C1<T> && C2<T> void f3(T); // \#3
template<typename T> void f3(T) requires C1<T> && C2<T>; // \#4
\end{codeblock}
The associated constraints of \#1, \#2, \#3, and \#4 are equivalent. The 
\grammarterm{constraint-expression} associated by \tcode{C1} occurs before 
the constraint associated by \tcode{C2} in each declaration.
% 
\begin{codeblock}
template<C1 T> requires C2<T> void f5();
template<C2 T> requires C1<T> void f5(); // error: constraints are functionally equivalent but not equivalent
\end{codeblock}
% 
The associated constraints of the first declaration are
\tcode{C1<T> \&\& C2<T>}, and those of the second are
\tcode{C2<T> \&\& C1<T>}.
\exitexample
\end{quote}


%%
%% Template parameters
%%
\rSec1[temp.param]{Template parameters}

In paragraph 1, extend the grammar for template parameters to 
constrained template parameters.

\begin{quote}
\pnum

\begin{bnf}
\nontermdef{template-parameter}\br
  \added{constrained-parameter}

\begin{addedblock}
\nontermdef{constrained-parameter}\br
  constrained-type-specifier ...\opt identifier\opt default-argument\opt\br

\nontermdef{default-argument}\br
  \terminal{=} type-id\br
  \terminal{=} id-expression\br
  \terminal{=} initializer-clause\br
\end{addedblock}
\end{bnf}
\end{quote}

Insert a new paragraph after paragraph 1.

\begin{quote}
\pnum
There is an ambiguity in the syntax of a template parameter between the
declaration of a \grammarterm{constrained-parameter} and a
\grammarterm{parameter-declaration}.
% 
If the \grammarterm{type-specifier-seq} of a \grammarterm{parameter-declaration} 
is a \grammarterm{constrained-type-specifier}, then the 
\grammarterm{template-parameter} is a \grammarterm{constrained-parameter}.
\end{quote}

Insert the following paragraphs after paragraph 8. These paragraphs
define the meaning of a constrained template parameter.

\begin{quote}
\setcounter{Paras}{8}
\pnum
A \grammarterm{constrained-parameter} declares a template parameter whose 
kind (type, non-type, template) and type match that of the prototype parameter 
of the concept designated by its \grammarterm{constrained-type-specifier}.
% 
The designated concept is selected by concept resolution 
(\ref{temp.constr.resolve}).
% 
Let \tcode{P} be the prototype parameter of the designated concept. 
% 
The declared template parameter is determined by the kind of \tcode{P} 
(type, non-type, template) and the optional ellipsis in the
\grammarterm{template-parameter} as follows:
% 
\begin{itemize}
\item If \tcode{P} is a type \grammarterm{template-parameter} the declared
parameter is a type \grammarterm{template-parameter}. 

\item If \tcode{P} is a non-type \grammarterm{template-parameter}, the declared
parameter is a non-type \grammarterm{template-parameter} having the same 
type as \tcode{P}.

\item If \tcode{P} is a template \grammarterm{template-parameter}, the declared
parameter is a template \grammarterm{template-parameter} having the same 
\grammarterm{template-parameter-list} as \tcode{P}, excluding default template 
arguments.

\item If \tcode{P} declares a template parameter pack, the 
\grammarterm{constrained-type-specifier} shall be followed by an ellipsis,
and the declared parameter is a template parameter pack. 
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<template<typename> class X> concept bool C2 = true;
template<int N> concept bool C3 = true;
template<typename... Ts> concept bool C4 = true;
template<char... Cs> concept bool C5 = true;

template<C1 T> void f1();     // OK: \tcode{T} is a type template-parameter
template<C2 X> void f2();     // OK: \tcode{X} is a template with one type-parameter
template<C3 N> void f3();     // OK: \tcode{N} has type int
template<C4... Ts> void f4(); // OK: \tcode{Ts} is a template parameter pack of types
template<C4 Ts> void f5();    // error: \tcode{Ts} must be preceded by an ellipsis
template<C5... Cs> f6();      // OK: \tcode{Cs} is a template parameter pack of \tcode{char}{}s
\end{codeblock}
\exitexample

\pnum
A \grammarterm{constrained-parameter} associates a
constraint with its \grammarterm{template-declaration}.
% 
This constraint is formed according to the rules in \ref{temp.constr.form}.
\end{quote}

Insert the following paragraph after paragraph 9 to require that the
kind of a \grammarterm{default-argument} matches the kind of its
\grammarterm{constrained-parameter}.

\begin{quote}
\setcounter{Paras}{11}
\pnum
The default \grammarterm{template-argument} of
a \grammarterm{constrained-parameter} shall match
the kind (type, non-type, template) of the declared parameter.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<int N> concept bool C2 = true;
template<template<typename> class X> concept bool C3 = true;

template<typename T> struct S0;

template<C1 T = int> struct S1; // OK
template<C2 N = 0> struct S2;   // OK
template<C3 X = S0> struct S3;  // OK
template<C1 T = 0> struct S4;   // error: default argument is not a type
\end{codeblock}
\exitexample
\end{quote}


%%
%% Introduction of template parameters
%%
\rSec1[temp.intro]{Introduction of template parameters}

Add this section after \ref{temp.param}.

\begin{quote}

\pnum
A \grammarterm{template-introduction} provides a more concise way of declaring
templates that have the same template parameters and constraints.

\begin{bnf}
\nontermdef{template-introduction}\br
  nested-name-specifier\opt concept-name \terminal{\{} introduction-list \terminal{\}}

\nontermdef{introduction-list}\br
  introduced-parameter\br
  introduction-list \terminal{,} introduced-parameter

\nontermdef{introduced-parameter}\br
    \terminal{...}\opt identifier
\end{bnf}

A \grammarterm{template-introduction} declares a sequence of 
\grammarterm{template-parameter}{}s, which are derived from a 
\grammarterm{concept-name} and the sequence of \grammarterm{identifier}{}s in
its \grammarterm{introduction-list}.

\pnum
The concept designated by the \grammarterm{concept-name} is selected by 
concept resolution (\ref{temp.constr.resolve}).

\pnum
For each \grammarterm{introduced-parameter} \tcode{I} in an
\grammarterm{introduction-list}, and for its corresponding selected template 
parameter \tcode{P} from the designated concept, declare a new template
parameter using the rules for declaring a constrained parameter in
\ref{temp.param} by using \tcode{I} as a \grammarterm{declarator-id} and 
\tcode{P} as the prototype parameter.
% 
% FIXME: This condition is broken. P shall declare a template pack?
% 
If \tcode{I} contains an ellipsis, \tcode{P} declares a template 
parameter pack.
% 
\enterexample
\begin{codeblock}
template<typename T, int N, typename... Xs> concept bool C1 = true;
template<template<typename> class X> concept bool C2 = true;

C1{A, B, ...C} // OK: \tcode{A} is declared as \tcode{typename A},
  struct s;    // \tcode{B} is declared as \tcode{int B}, and
               // \tcode{C} is declared as \tcode{typename... C}

C1{X, Y, Z} // error: \tcode{Z} must be preceded by an ellipsis
  struct t;

C2{T} // OK: \tcode{T} is declared as \tcode{template<typename> class T}
  void foo();

C2{...X} // error: the corresponding parameter is not a template parameter pack
  void bar();
\end{codeblock}
\exitexample


\pnum
\enternote
A concept referred to by a \grammarterm{concept-name} may have template 
parameters with default template arguments. An \grammarterm{introduction-list} 
may omit \grammarterm{identifier}{}s for a corresponding template
parameter if it has a default argument. 
% 
However, only the \grammarterm{introduced-parameter}{}s are declared
as template parameters. 
% 
\enterexample
\begin{codeblock}
template<typename A, typename B = bool> concept bool C() { return true; }

C{T} void f(T); // OK: \tcode{f(T)} is a function template with
                // a single template type parameter \tcode{T}
\end{codeblock}
There is no \grammarterm{introduced-parameter} that corresponds to the 
template parameter \tcode{B} in the \tcode{C} concept, so \tcode{f(T)} is 
declared with only one template parameter.
\exitexample
\exitnote


\pnum
An introduced template parameter does not have a default template argument 
even if its corresponding template parameter does.
% 
\enterexample
\begin{codeblock}
template<typename T, int N = -1> concept bool P() { return true; }

P{T, N} struct Array { };

Array<double, 0> s1; // OK
Array<double> s2;    // error: \tcode{Array} takes two template arguments
\end{codeblock}
\exitexample

%  TODO: Unify with temp.constr.form

\pnum
A \grammarterm{template-introduction} associates a constraint with its
\grammarterm{template-declaration}.
% 
The constraint is formed from the concept \tcode{C}, designated by the
\grammarterm{constrained-type-specifier} (including its
\grammarterm{nested-name-specifier}), 
and the sequence of introduced parameters.
% 
Form a sequence of \grammarterm{template-argument}{}s
\tcode{Args} from the template parameters declared by the
\grammarterm{introduced-parameter}{}s as follows. 
% 
If an introduced template parameter \tcode{T} is declared as a template 
parameter pack, its corresponding \grammarterm{template-argument} is the pack
expansion of \tcode{T}. 
% 
% FIXME: Replace type and form
% 
Otherwise, its corresponding \grammarterm{template-argument} matches the 
kind (type, non-type, template) of \tcode{T}.
% 
Let \tcode{TT} be a \grammarterm{template-id}
formed as \tcode{C<Args>}.
% 
The associated \grammarterm{constraint-expression} is
the \grammarterm{id-expression} \tcode{TT}
if \tcode{C} refers to a variable concept. 
% 
The associated \grammarterm{constraint-expression} is
the function call \tcode{TT()} if \tcode{C} refers to a function 
concept.
% 
\enterexample
\begin{codeblock}
template<typename T, typename U> concept bool C1 = true;
template<typename T, typename U> concept bool C2() { return true; }
template<typename T, typename U = char> concept bool C3 = true;
template<typename... Ts> concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&&...);

template<typename A, typename B> 
  requires C1<A, B> // constraint associated by \tcode{C1\{A, B\}}
    struct X;       // OK: redeclaration of \tcode{X}

template<typename A, typename B> 
  requires C2<A, B>()  // constraint associated by \tcode{C2\{A, B\}}
    struct Y;          // OK: redeclaration of \tcode{Y}

template<class P>
  requires C3<P> // constraint associated by \tcode{C3\{P\}}
    void f(P);   // OK: redeclaration of \tcode{f(P)}

template<typename... Qs>
  requires C4<Qs...> // constraint associated by \tcode{C4\{...Qs\}}
    void g(Qs&&...); // OK: redeclaration of \tcode{g(Qs\&\&...)}
\end{codeblock}
\exitexample


\pnum
A template declared by a \grammarterm{template-introduction} can also be 
an abbreviated function template (\ref{dcl.fct}). 
% 
The invented template parameters introduced by the placeholders in the 
abbreviated function template are appended to the list of template parameters 
declared by the \grammarterm{template-introduction}.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;

C1{T} void f(T, auto);
template<C1 T, typename U> void f(T, U); // OK: redeclaration of f(T, auto)
\end{codeblock}
% 
\enternote
The second declaration of \tcode{f} is a redeclaration of the first
because the associated constraints of each are equivalent 
(\ref{temp.over.link}).
\exitnote
\exitexample

\end{quote}

%%
%% Names of template specializations
%%
\rSec1[temp.names]{Names of template specializations}

Add this paragraph at the end of the section to require the satisfaction of 
associated constraints on the formation of the \grammarterm{simple-template-id}.

\begin{quote}
\setcounter{Paras}{7}
\pnum
When the \grammarterm{template-name} of a \grammarterm{simple-template-id} names
a constrained non-function template or a template template parameter,
but not a member template that is a member of an unknown specialization
\ref{temp.res}, and all \grammarterm{template-argument}{}s in the
\grammarterm{simple-template-id} are non-dependent \cxxref{temp.dep.temp}, the 
template arguments are substituted into the associated constraints
(Clause~\ref{temp}). 
% 
If, as a result of substitution, the associated constraints are not 
satisfied (\ref{temp.constr}), the \grammarterm{simple-template-id} is ill-formed.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = false;

template<C T> struct S1 { };
template<C T> using Ptr = T*;

S1<int>* p; // error: constraints not satisfied
Ptr<int> p; // error: constraints not satisfied

template<typename T>
  struct S2 { Ptr<int> x; }; // error: constraints not satisfied

template<typename T>
  struct S3 { Ptr<T> x; };   // OK: satisfaction is not required

S3<int> x;                   // error: constraints not satisfied

template<template<C T> class X>
  struct S4 {
    X<int> x; // error: constraints not satisfied (\#1)
  };

template<typename T>
  struct S5 {
    using Type = typename T::template MT<char>; // \#2
  };
\end{codeblock}
In \#1, the error is caused by the substitution of \tcode{int} into 
the associated constraints of the template parameter \tcode{X}.
% 
In \#2, there are no constraints can be checked for 
\tcode{typename Y::template MT<char>} because \tcode{MT} is a member
of an unknown specialization.
\exitexample
\end{quote}


%%
%% Template arguments
%%
\rSec1[temp.arg]{Template arguments}

%%
%% Template template arguments
%%
\rSec2[temp.arg.template]{Template template arguments}

Modify paragraph 3 to include rules for matching constrained template 
\grammarterm{template parameter}{}s. Note that the examples following this 
paragraph in the \Cpp Standard are omitted.

\begin{quote}
\setcounter{Paras}{2}
\pnum
A \grammarterm{template-argument} matches  a template 
\grammarterm{template-parameter}  (call it \tcode{P}) when each of the 
template parameters in the \grammarterm{template-parameter-list} of the 
\grammarterm{template-argument}'s corresponding class template or alias 
template (call it  \tcode{A}) matches the corresponding template parameter in 
the \grammarterm{template-parameter-list} of \tcode{P}\added{, and \tcode{P} is 
at least as constrained as \tcode{A} according to the rules in 
\ref{temp.constr.order}}.
% 
Two template parameters match if they are of the same kind (type, non-type, 
template), for non-type \grammarterm{template-parameter}{}s, their types are 
equivalent (\ref{temp.over.link}), and for template 
\grammarterm{template-parameter}{}s, each of their corresponding
\grammarterm{template-parameter}{}s matches, recursively. 
% 
When \tcode{P}'s \grammarterm{template-parameter-list} 
contains a template parameter pack (\cxxref{temp.variadic}), the template 
parameter pack will match zero or more template parameters or template 
parameter packs in the \grammarterm{template-parameter-list} of
\tcode{A} with the same kind (type, non-type, template) and type as the template 
parameter pack in \tcode{P} (ignoring whether those template parameters are
template parameter packs).
\end{quote}

Add the following example to the end of paragraph 3, after the
examples given in the \Cpp Standard.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool D = C<T> && requires (T t) { t.g(); };

template<template<C> class P>
  struct S { };

template<C> struct X { };
template<D> struct Y { };
template<typename T> struct Z { };

S<X> s1; // OK: \tcode{X} and \tcode{P} have equivalent constraints
S<Y> s2; // error: \tcode{P} is not at least as constrained \tcode{Y} (\tcode{Y} is more constrained than \tcode{P})
S<Z> s3; // OK: \tcode{P} is at least as constrained as \tcode{Z}
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Template declarations
%%
\setcounter{section}{5}
\rSec1[temp.decls]{Template declarations}

Modify paragraph 2 to indicate that associated constraints are
instantiated separately from the template they are associated with.

\begin{quote}
\setcounter{Paras}{1}
For purposes of name lookup and instantiation, default 
arguments\added{, associated constraints (Clause~\ref{temp}),} and
\grammarterm{exception-specification}{}s of function templates and default
arguments\added{, associated constraints,} and 
\grammarterm{exception-specification}{}s of member functions of class
templates are considered definitions; each default 
argument\added{, associated constraint,} or 
\grammarterm{exception-specification} is a separate definition which is 
unrelated to the function template definition or to any other default 
arguments\added{, associated constraints,} or 
\grammarterm{exception-specification}{}s.
\end{quote}


%%
%% Class templates
%%
\rSec2[temp.class]{Class templates}

Modify paragraph 3 to require template constraints for out-of-class
definitions of members of constrained templates. 

\begin{quote}
\setcounter{Paras}{2}
\pnum
When a member function, a member class, a member enumeration, a static 
data member or a member template of a class template is defined outside 
of the class template definition, the member definition is defined as a 
template definition in which the \grammarterm{template-parameter}{}s
\added{and associated constraints} are those of the class template.
% 
The names of the template parameters used in the definition of the 
member may be different from the template parameter names used in the 
class template definition. The template argument list following the class
template name in the member definition shall name the parameters in the 
same order as the one used in the template parameter list of the member. 
% 
Each template parameter pack shall be expanded with an ellipsis in the 
template argument list.
\end{quote}

Add the following example at the end of paragraph 3.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;
template<typename T> concept bool D = true;

template<C T> struct S {
    void f();
    void g();
    template<D U> struct Inner;
  }

template<typename T> requires C<T> void S<T>::f() { } // OK: parameters and constraints match
template<typename T> void S<T>::g() { } // error: no matching declaration for \tcode{S<T>}

template<C T> D{U} struct S<T>::Inner { }; // OK
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}

%%
%% Member functions of class templates
%%
\rSec3[temp.mem.func]{Member functions of class templates}

Add the following example to the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> struct S {
  void f() requires true;
  void g() requires true;
};

template<typename T> 
  void S<T>::f() requires true { } // OK
template<typename T> 
  void S<T>::g() { }               // error: no matching function in \tcode{S<T>}
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Member templates
%%
\rSec2[temp.mem]{Member templates}


Modify paragraph 1 in order to account for constrained member templates
of (possibly) constrained class templates. 

\begin{quote}
A template can be declared within a class or class template; such a 
template is called a member template. 

A member template can be defined within or outside its class definition 
or class template definition. 

A member template of a class template that is defined outside of its 
class template definition shall be specified with the 
\grammarterm{template-parameter}{}s \added{and associated constraints}
of the class template followed by the \grammarterm{template-parameter}{}s
\added{and associated constraints} (Clause~\ref{temp}) of the member template.
\end{quote}


Add the following example at the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = sizeof(T) <= 4;

template<C1 T>
  struct S {
    template<C2 U> void f(U);
    template<C2 U> void g(U);
  };

template<C1 T> template<typename U> 
  void S<T>::f(U) requires C2<U> { } // OK
template<C1 T> template<typename U> 
  void S<T>::g(U) { }                // error: no matching function in \tcode{S<T>}
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Friends
%%
\setcounter{subsection}{3}
\rSec2[temp.friend]{Friends}

Modify paragraph 9 to restrict constrained friend declarations.

\begin{quote}
\setcounter{Paras}{8}
\pnum
When a friend declaration refers to a specialization of a function
template, the function parameter declarations shall not include
default arguments, \added{the declaration shall not be
constrained,} nor shall the inline specifier be used in such a
declaration.
\end{quote}

Add examples following that paragraph.

\begin{quote}
\begin{addedblock}
\pnum
\enternote
Other friend declarations can be constrained. In a constrained friend 
declaration that is not a definition, the constraints are used for declaration
\exitnote
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = false;

template<C1 T> g0(T);
template<C1 T> g1(T);
template<C2 T> g2(T);

template<typename T>
  struct S {
    friend void f1() requires true;      // OK
    friend void f2() requires C1<T>;     // OK
    friend void g0<T>(T) requires C1<T<; // error: constrained friend specialization
    friend void g1<T>(T);                // OK
    friend void g2<T>(T);                // error: constraint can never be satisfied, no diagnostic required
  };

void f1() requires true;    // friend of all S<T>
void f2() requires C1<int>; // friend of S<int>
\end{codeblock}
The friend declaration of \tcode{g2} is ill-formed, no
diagnostic required, because no valid specialization of \tcode{S}
can be generated: the constraint on \tcode{g2} can never
be satisfied, so template argument deduction
(\ref{temp.deduct.decl}) will always fail.
\exitexample

\pnum
\enternote
Within a class template, a friend may define a non-template function
whose constraints specify requirements on template arguments.
\enterexample
\begin{codeblock}
template<typename T> concept bool Eq = requires (T t) { t == t; };

template<typename T>
  struct S {
    friend bool operator==(S a, S b) requires Eq<T> { return a == b; } // OK
  };
\end{codeblock}
\exitexample
In the instantiation of such a class template, the template
arguments are substituted into the constraints but not evaluated.
Constraints are checked (\ref{temp.constr}) only when
that function is considered as a viable candidate for overload resolution
(\ref{over.match.viable}).
\exitnote
\end{addedblock}
\end{quote}


%%
%% Class template partial specializations
%%
\rSec2[temp.class.spec]{Class template partial specialization}

After paragraph 3, insert the following, which explains constrained partial 
specializations.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{3}
\pnum
A class template partial specialization may be constrained
(Clause~\ref{temp}).
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<int I> concept bool N = I > 0;

template<C T1, C T2, N I> class A<T1, T2, I>;  // \#6
template<C T, N I>        class A<int, T*, I>; // \#7
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}

Remove the 3rd item in the list of paragraph 8 to allow constrained class 
template partial specializations like \#6, and because it is redundant with 
the 4th item. Note that all other items in that list are elided.

\begin{quote}
\setcounter{Paras}{7}
Within the argument list of a class template partial specialization, 
the following restrictions apply:
\begin{itemize}
\item ...

\item \removed{The argument list of the specialization shall
not be identical to the implicit argument list of the
primary template.}

\item The specialization shall be more specialized than the primary
template (\ref{temp.class.order}).

\item ...
\end{itemize}
\end{quote}
 
%%
%% Matching of class template partial specializations
%%
\rSec3[temp.class.spec.match]{Matching of class template partial specializations}

Modify paragraph 2; constraints must be satisfied in order
to match a partial specialization. 

\begin{quote}
\setcounter{Paras}{1}
\pnum
A partial specialization matches a given actual template argument list if 
the template arguments of the partial specialization can be deduced from the 
actual template argument list (\ref{temp.deduct}) \added{, and the deduced 
template arguments satisfy the constraints of the partial specialization, if 
any (\ref{temp.constr})}.
\end{quote}

Add the following example to the end of paragraph 2.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
struct S { void f(); };

A<S, S, 1>    a6; // uses \#6
A<S, int, 2>  a7; // error: constraints not satisfied
A<int, S*, 3> a8; // uses \#7
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Partial ordering of class template specializations
%%
\rSec3[temp.class.order]{Partial ordering of class template specializations}

Modify paragraph 1 so that constraints are considered in the
partial ordering of class template specializations. 

\begin{quote}
\pnum
For two class template partial specializations, the first is 
at least as specialized as the second if, given the following 
rewrite to two function templates, the first function template 
is at least as specialized as the second according to the ordering 
rules for function templates 
(\ref{temp.func.order}):
% 
\begin{itemize}
\item the first function template has the same template 
parameters \added{and associated constraints} as the first partial 
specialization, and has a single function parameter whose
type is a class template specialization with the template 
arguments of the first partial specialization, and

\item the second function template has the same template 
parameters \added{and associated constraints} as the second partial 
specialization, and has a single function parameter whose
type is a class template specialization with the template 
arguments of the second partial specialization.
\end{itemize}
\end{quote}

Add the following example to the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool D = C<T> && requires (T t) { t.f(); };


template<typename T> class S { };
template<C T> class S<T> { }; // \#1
template<D T> class S<T> { }; // \#2

template<C T> void f(S<T>); // A
template<D T> void f(S<T>); // B
\end{codeblock}
The partial specialization \#2 is more specialized than 
\#1 for template arguments that satisfy both constraints because 
\tcode{B} is more specialized than \tcode{A}.
\exitexample
\end{addedblock}
\end{quote}


%%
%% Function templates
%%
\rSec2[temp.fct]{Function templates}

%%
%% Function template overloading
%%
\rSec3[temp.over.link]{Function template overloading}

Modify paragraph 6 to account for constraints on function templates.

\begin{quote}
\setcounter{Paras}{5}
\pnum

\removed{ Two function templates are \defn{equivalent} if they are 
declared in the same scope, have the same name, have identical template 
parameter lists, and have return types and parameter lists that are 
equivalent using the rules described above to compare expressions 
involving template parameters.}
% 
\begin{addedblock}
Two function templates are \defn{equivalent} if they:
\begin{itemize}
\item are declared in the same scope,

\item have the same name,

\item have identical template parameter lists,

\item have return types and parameter lists that are equivalent using the 
rules described above to compare expressions involving template parameters, and

\item have associated constraints (Clause~\ref{temp}) that are equivalent 
using the rules above to compare expressions involving template parameters.
\end{itemize}
\end{addedblock}
% 
Two function templates are \defn{functionally equivalent} if they 
are equivalent except that one or more expressions that involve 
template parameters in the return types and parameter lists\added{, or the
associated constraints (Clause~\ref{temp})} are functionally equivalent using 
the rules described above to compare expressions involving template parameters.
% 
If a program contains declarations of function templates that are 
functionally equivalent but not equivalent, the program is ill-formed; 
no diagnostic is required.
\end{quote}


%%
%% Partial ordering of function templates
%%
\rSec3[temp.func.order]{Partial ordering of function templates}

Modify paragraph 2 to include constraints in the partial ordering
of function templates.

\begin{quote}
\setcounter{Paras}{1}
\pnum
Partial ordering selects which of two function templates is 
more specialized than the other by transforming each template 
in turn (see next paragraph) and performing template argument 
deduction using the function type. The deduction process 
determines whether one of the templates is more specialized 
than the other.
% 
If so, the more specialized template is the one chosen by the 
partial ordering process. 
% 
\added{If both deductions succeed, the partial ordering selects
the more constrained template as described by the rules in
\ref{temp.constr.order}.}
\end{quote}

%%
%% Name resolution
%%
\rSec1[temp.res]{Name resolution}

Modify paragraph 8.

\begin{quote}
\setcounter{Paras}{7}
\pnum
Knowing which names are type names allows the syntax of every
template to be checked. No diagnostic shall be issued for a template
for which a valid specialization can be generated. If no valid
specialization can be generated for a template, and that template is
not instantiated, the template is ill-formed, no diagnostic
required. If every valid specialization of a variadic template
requires an empty template parameter pack, the template is
ill-formed, no diagnostic required. \added{If no instantiation of
the associated constraints of a template would result in a valid
expression, the template is ill-formed, no diagnostic required.}
If a hypothetical instantiation of a template immediately following
its definition would be ill-formed due to a construct that does not
depend on a template parameter, the program is ill-formed; no
diagnostic is required. If the interpretation of such a construct in
the hypothetical instantiation is different from the interpretation
of the corresponding construct in any actual instantiation of the
template, the program is ill-formed; no diagnostic is required.
\end{quote}

%%
%% Dependent name resolution
%% 
\setcounter{subsection}{3}
\rSec2[temp.dep.res]{Dependent name resolution}

%%
%% Point of instantiation
%%
\rSec3[temp.point]{Point of instantiation}

Add a new paragraph after paragraph 4.

\begin{quote}
\setcounter{Paras}{4}
\pnum
The point of instantiation of a \grammarterm{constraint-expression} of a
specialization immediately precedes the point of instantiation of
the specialization.
\end{quote}


%%
%% Template instantiation and specialization
%%
\rSec1[temp.spec]{Template instantiation and specialization}

%%
%% Implicit instantiation
\rSec2[temp.inst]{Implicit Instantiation}
    
Change paragraph 1 to include associated constraints.

\begin{quote}
Unless a class template specialization has been explicitly
instantiated \ref{temp.explicit} or explicitly specialized \ref{temp.expl.spec}, 
the class template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a
completely-defined object type or when the completeness of the
class type affects the semantics of the program. 
% 
\enternote
Within a template declaration, a local class or enumeration and the members
of a local class are never considered to be entities that can be
separately instantiated (this includes their default arguments,
exception-specifications, and non-static data member initializers, if any). 
% 
As a result, the dependent names are looked up, the semantic constraints 
are checked, and any templates used are instantiated as part of the
instantiation of the entity within which the local class or enumeration is 
declared.
\exitnote
% 
The implicit instantiation of a class template specialization causes the 
implicit instantiation of the declarations, but not of the definitions, default
arguments, \added{associated constraints (Clause~\ref{temp}),} or
\grammarterm{exception-specification}{}s of the class member functions,
member classes, scoped member enumerations, static data members and
member templates; and it causes the implicit instantiation of the
definitions of unscoped member enumerations and member anonymous
unions.
\end{quote}


Add a new paragraph after paragraph 15 to describe how associated
constraints are instantiated.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{15}
\pnum
The associated constraints of a template specialization are not
instantiated along with the specialization itself; they are
instantiated only to determine if they are satisfied
(\ref{temp.constr}).
% 
\enternote
The satisfaction of constraints is determined during lookup or overload
resolution (\ref{over.match}). Preserving the spelling
of the substituted constraint also allows constrained member function
to be partially ordered by those constraints according to the rules
in \ref{temp.constr.order}.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) > 2;
template<typename T> concept bool D = C<T> && sizeof(T) > 4;

template<typename T> struct S {
  S() requires C<T> { } // \#1
  S() requires D<T> { } // \#2
};

S<char> s1;    // error: no matching constructor
S<char[8]> s2; // OK: calls \#2
\end{codeblock}

Even though neither constructor for \tcode{S<char>} will be selected by
overload resolution, they remain a part of the class template specialization. 
% 
This also has the effect of suppressing the implicit generation of a default
constructor (\cxxref{class.ctor}).
\exitexample

\enterexample
\begin{codeblock}
template<typename T> struct S1 {
  template<typename U> requires false struct Inner1; // OK
};

template<typename T> struct S2 {
  template<typename U> 
    requires sizeof(T[(int)-sizeof(T)]) > 1 // error: ill-formed, no diagnostic required
      struct Inner2;
};
\end{codeblock}
\exitexample
Every instantiation of \tcode{S1} results in a valid type, although any use 
of its nested \tcode{Inner1} template is invalid.
% 
\tcode{S2} is ill-formed, no diagnostic required, since no substitution into 
the constraints of its \tcode{Inner2} template would result in a valid 
expression.
\end{addedblock}
\end{quote}


%%
%% Explicit instantiation
%%
\rSec2[temp.explicit]{Explicit instantiation}

Modify paragraph 8 to ensure that only members whose constraints are 
satisfied are explicitly instantiated during class template 
specialization. The note in the \Cpp Standard is omitted.

\begin{quote}
\setcounter{Paras}{7}
\pnum
An explicit instantiation that names a class template specialization is 
also an explicit instantiation of the same kind (declaration or 
definition) of each of its members (not including members inherited from 
base classes and members that are templates) that has not been previously 
explicitly specialized in the translation unit containing the explicit 
instantiation, \added{and provided that the associated constraints (\ref{temp}),
if any, of that member are satisfied (\ref{temp.constr}) by the template 
arguments of the explicit instantiation, } except as described below.
\end{quote}

Add the following paragraphs to this section. These require an explicit
instantiation of a constrained template to satisfy the template's
associated constraints.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{13}
\pnum
If the explicit instantiation names a class template specialization
or variable template specialization of a constrained template, then
the \grammarterm{template-arguments} in the
\grammarterm{template-id} of the explicit
instantiation shall satisfy the template's associated constraints
(\ref{temp.constr}).
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 1;

template<C T> struct S { };

template struct S<char>;    // OK
template struct S<char[2]>; // error: constraints not satisfied
\end{codeblock}
\exitexample

\pnum
When an explicit instantiation refers to a specialization of a
function template (\ref{temp.deduct.decl}), that 
template's associated constraints shall be satisfied by the template 
arguments of the explicit instantiation.

\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { -t; };

template<C T>        void f(T) { } // \#1
template<typename T> void g(T) { } // \#2
template<C T>        void g(T) { } // \#3

template void f(int);   // OK: refers to \#1
template void f(void*); // error: no matching template
template void g(int);   // OK: refers to \#3
template void g(void*); // OK: refers to \#2
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Explicit specialization
%%
\rSec2[temp.expl.spec]{Explicit specialization}

Insert the following paragraphs after paragraph 12. These require
an explicit specialization to satisfy the constraints of the primary
template.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{12}
\pnum
The \grammarterm{template-arguments} in the
\grammarterm{template-id} of an explicit 
specialization of a constrained non-function template shall satisfy the 
associated constraints of that template, if any 
(\ref{temp.constr}).
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 1;

template<C T> struct S { };

template<> struct S<char> { };    // OK
template<> struct S<char[2]> { }; // error: constraints not satisfied
\end{codeblock}
\exitexample

\pnum
When determining the function template referred to by an explicit 
specialization of a function template (\ref{temp.deduct.decl}),
the associated constraints of that template (if any) shall be satisfied 
(\ref{temp.constr}) by the template arguments of the explicit specialization.

\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { -t; };

template<C T>        void f(T); // \#1
template<typename T> void g(T); // \#2
template<C T>        void g(T); // \#3

template<> void f(int);   // OK: refers to \#1
template<> void f(void*); // error: no matching template
template<> void g(int);   // OK: refers to \#3
template<> void g(void*); // OK: refers to \#2
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Function template specializations
%%
\rSec1[temp.fct.spec]{Function template specializations}

%%
%% Template argument deduction
%%
\rSec2[temp.deduct]{Template argument deduction}

Add the following sentences to the end of paragraph 5. This defines
the substitution of template arguments into a function template's
associated constraints. Note that the last part of paragraph 5
has been duplicated in order to provide context for the addition.

\begin{quote}
\setcounter{Paras}{4}
\pnum
When all template arguments have been deduced or obtained from default 
template arguments, all uses of template parameters in the template 
parameter list of the template and the function type are replaced with
the corresponding deduced or default argument values. 

If the substitution results in an invalid type, as described above, type 
deduction fails.

\added{If the function template has associated constraints (Clause~\ref{temp}),
the template arguments are substituted into the associated constraints
without evaluating the resulting expression. If this substitution
results in an invalid type or expression, type deduction fails.
% 
\enternote
The satisfaction of constraints (\ref{temp.constr})
associated with the function template specialization is determined during 
overload resolution (\ref{over.match}), and not at 
the point of substitution.
\exitnote}
\end{quote}

\setcounter{subsection}{5}
\rSec3[temp.deduct.decl]{Deducing template arguments from a function declaration}

Add the following after paragraph 1 in order to require the
satisfaction of constraints when matching a specialization to a
template.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{2}
\pnum
Remove from the set of function templates considered all those
whose associated constraints (if any) are not satisfied by the deduced
template arguments (\ref{temp.constr}).
\end{addedblock}
\end{quote}

Update paragraph 2 (now paragraph 3) to accommodate the new wording.

\begin{quote}
\pnum
If, 
\removed{for the set of function templates so considered}
\added{for the remaining function templates},
there is either no match or more than one match after partial ordering 
has been considered (\ref{temp.func.order}), deduction fails 
and, in the declaration cases, the program is ill-formed.
\end{quote}

