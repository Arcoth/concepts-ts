
%%
%% Templates
%%
\setcounter{chapter}{13}
\rSec0[temp]{Templates}

Modify the \grammarterm{template-declaration} grammar in paragraph 1 to 
allow a template declaration introduced by a concept.

\begin{quote}
\pnum

\begin{bnf}
\nontermdef{template-declaration}\br
  \terminal{template} \terminal{<} template-parameter-list \terminal{>}
    \added{requires-clause\opt} declaration\br
  \added{template-introduction declaration}

\begin{addedblock}
\nontermdef{requires-clause}\br
  \terminal{requires} constraint-expression
\end{addedblock}
\end{bnf}
\end{quote}
  
Add the following paragraphs after paragraph 6.

\begin{quote}
\setcounter{Paras}{6}
\pnum
A \grammarterm{template-declaration} is written in terms of its template 
parameters. These parameters are declared explicitly in a 
\grammarterm{template-parameter-list} (\ref{temp.param}), or they are
introduced by a \grammarterm{template-introduction} (\ref{temp.intro}).


\pnum
The \defn{associated constraints} of a 
\grammarterm{template-declaration} are the 
logical \tcode{\&\&} of all 
\grammarterm{constraint-expression}s introduced by:
% 
\begin{itemize}
\item a concept introduction, and

\item a \grammarterm{requires-clause} following a
\grammarterm{template-parameter-list}, and

\item any constrained template parameters (\ref{temp.param})
in the declaration's \grammarterm{template-parameter-list},
and 

\item any \grammarterm{constrained-type-specifier}s
in the \grammarterm{decl-specifier-seq} of
a \grammarterm{parameter-declaration} in a function
declaration or definition (\ref{dcl.spec.constr}), and

\item a \grammarterm{requires-clause} appearing after
the \grammarterm{declarator} of an
\grammarterm{init-declarator}
(\ref{dcl.decl}),
\grammarterm{function-definition}
(\ref{dcl.fct.def.general}), or
\grammarterm{member-declarator}
(\ref{class.mem}).
\end{itemize}
% 
Let \tcode{T1} be a \grammarterm{template-declaration}
with associated constraints. \tcode{T1} is equivalent to another
\grammarterm{template-declaration} (call it \tcode{T2}) 
whose template parameters are declared explicitly as unconstrained template 
parameters, and \tcode{T2} has a single
\grammarterm{requires-clause} whose 
\grammarterm{constraint-expression} is equivalent to 
the associated constraints of \tcode{T1} 
(\ref{temp.constr.expr}). \tcode{T2} is said
to be the \defn{canonical declaration} of all declarations that are 
equivalent to it according to the rules below.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;

// all of the following declare the same function:
void g(C);
template<C T> void g(T);
C{T} void g(T);
template<typename T> requires C<T> void g(T);
\end{codeblock}
The last declaration is the canonical declaration of \tcode{g(T)}.
\exitexample


\pnum
When a \grammarterm{template-declaration} is
declared by a template introduction (\ref{temp.intro}), 
its canonical declaration is a
\grammarterm{template-declaration} whose
\grammarterm{template-parameter-list} is defined 
according to the rules for introducing template parameters in
\ref{temp.intro}, and the 
equivalent declaration has a \grammarterm{requires-clause} 
whose \grammarterm{constraint-expression} is
formed as follows.
% 
Let \tcode{TT} be a \grammarterm{template-id}
formed as 
\tcode{C<I1, I2, ..., In, D1, D2, ..., Dn>}
where \tcode{C} is the name of the designated concept,
\tcode{I1, I2, ..., In} is the sequence
of introduced template parameters, and
\tcode{D1, D2, ..., Dn} is the (possibly empty)
sequence of instantiated default template arguments needed to form the
\grammarterm{template-id} that refers to \tcode{C}.
% 
If an introduced parameter declares a template parameter pack, the
corresponding template argument in the \tcode{TT} is a pack
expansion (\cxxref{temp.variadic}).
% 
If \tcode{C} is a variable concept, then the
\grammarterm{constraint-expression} is
the \grammarterm{id-expression} \tcode{TT}.
% 
If \tcode{C} is a function concept, then the
\grammarterm{constraint-expression} is
the function call \tcode{TT()}.
% 
\enterexample
\begin{codeblock}
template<typename T, typename U> concept bool C1 = true;
template<typename T, typename U> concept bool C2() { return true; }
template<typename T, typename U = char> concept bool C3 = true;
template<typename... Ts> concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&&...);

template<typename A, typename B> 
  requires C1<A, B> // constraint associated by \tcode{C1{A, B}}
    struct X;       // OK: redeclaration of \tcode{X}

template<typename A, typename B> 
  requires C2<A, B>()  // constraint associated by \tcode{C2{A, B}}
    struct Y;          // OK: redeclaration of \tcode{Y}

template<class P>
  requires C3<P> // constraint associated by \tcode{C3{P}}
    void f(P);   // OK: redeclaration of \tcode{f(P)}

template<typename... Qs>
  requires C4<Qs...>      // constraint associated by \tcode{C4{...Qs}}
    void void g(Qs&&...); // OK: redeclaration of \tcode{g(Qs\&\&...)}
  }
\end{codeblock}
\exitexample

\pnum
When a \grammarterm{template-declaration} (call it \tcode{T1}) is
explicitly declared with \grammarterm{template-parameter-list}
that has constrained template parameters (\ref{temp.param}), 
its canonical declaration is a 
\grammarterm{template-declaration} (call it \tcode{T2})
with the same template parameters,
except that all constrained parameters are replaced by unconstrained
parameters matching the corresponding prototype parameter designated
by the \grammarterm{constrained-type-specifier} 
(\ref{dcl.spec.constr}).
% 
The declaration, \tcode{T2}, has a \grammarterm{requires-clause}
whose \grammarterm{constraint-expression} is the
conjunction of the \grammarterm{constraint-expressoin}s 
associated by the constrained template parameters in \tcode{T1}.
% 
The order in which the introduced constraints are evaluated is 
the same as the order in which the constrained template 
parameters are declared.
% 
If the original declaration \tcode{T1} includes a 
\grammarterm{requires-clause}, its
\grammarterm{constraint-expression} is evaluated after 
the constraints associated by the constrained template parameters in
\tcode{T2}.
% 
\enterexample
\begin{codeblock}
template<typename> concept bool C1 = true;
template<int> concept bool C2 = true;

template<C1 A, C2 B> struct S;
template<C1 T> requires C2<sizeof(T)> void f(T);

template<typename X, int Y> 
  requires C1<X> && C2<Y>
    struct S; // OK: redeclaration of S

template<typename T> 
  requires C1<T> && C2<sizeof(T)>
    void f(T); // OK: redeclaration of \tcode{f(T)}
\end{codeblock}
\exitexample

\pnum
When the declaration is an abbreviated function, it is 
equivalent to a \grammarterm{template-declaration}
whose template parameters are declared according to the rules in
\ref{dcl.fct}. The associated constraints of the
abbreviated function are evaluated in the order in which they appear.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;
template<typename T> concept bool D() { return true; }

void f(C, C, D);

template<C T, D U> 
  void f(T, T, U);   // OK: redeclaration of f(C, C, D)

template<typename T, typename U>
  requires C<T> && D<U>()
    void f(T, T, U): // OK: also a redeclaration of f(C, C, D)
\end{codeblock}
\exitexample


\pnum
An abbreviated function can also be declared as a
\grammarterm{template-declaration}. The constraints
associated by \grammarterm{constrained-type-specifier}s
in the \grammarterm{parameter-declaration-clause} of
the function declaration are evaluated after those introduced by
\grammarterm{constrained-type-specifier}s in the
\grammarterm{template-parameter-list} and the
following \grammarterm{requires-clause}, if present.
This is also the case for an abbreviated function that is declared
is declared with a concept introduction.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;
template<typename T> concept bool D() { return true; }
template<typename T> concept bool P = true;

template<C T> requires P<T> void g1(T, D);
template<C T> void g2(T, D);

template<typename T, typename U>
  requires C<T> && P<T> && D<U>()
    void g1(T, U);      // OK: redeclaration of \tcode{g1(T, D)}

C{T} void g2(T, D); // OK: redeclaration of \tcode{g2(T, D)}
\end{codeblock}
\exitexample


\pnum
A \defn{trailing \grammarterm{requires-clause}} 
is a \grammarterm{requires-clause} that appears after
the \grammarterm{declarator} in an
\grammarterm{init-declarator}
(\ref{dcl.decl}),
\grammarterm{function-definition}
(\ref{dcl.fct.def.general}), or
\grammarterm{member-declarator}
(\ref{class.mem}).
% 
When a constrained function template or member function template is
declared with a trailing \grammarterm{requires-clause}
it is equivalent to a declaration in which the 
\grammarterm{constraint-expression} of the
trailing \grammarterm{requires-clause} is evaluated
after all other associated constraints.
% 
\enterexample
\begin{codeblock}
template<C T> struct S {
  template<D U> void f(U) requires D<T>;
};

template<C T> template<typename U>
    requires D<U> && D<T>
      void S<T>::f(U) { } // OK: definition of S<T>::f(U)

template<C T> template<typename U>
    void S<T>::f(U) requires D<U> && D<T> { } // error: redefinition of S<T>::f(U)
  \end{codeblock}
  The second definition if \tcode{S<T>::f(U)} is an error 
  because its declaration is equivalent to the first.
\exitexample
\end{quote}

%%
%% Template parameters
%%
\rSec1[temp.param]{Template parameters}

Modify the \grammarterm{template-parameter}
grammar in \cxxref{temp.param}/1 in order
to allow constrained template parameters.

\begin{quote}
\begin{bnf}
\nontermdef{template-parameter}\br
  \removed{parameter-declaration}\br
  \added{non-type-or-constrained-parameter}

\begin{addedblock}
\nontermdef{non-type-or-constrained-parameter}\br
  basic-parameter-declaration\br
  basic-parameter-declaration \terminal{=} initializer\br
  basic-parameter-declaration \terminal{=} type-id\br
  basic-parameter-declaration \terminal{=} id-expression
\end{addedblock}
\end{bnf}
\end{quote}
    
Update the wording in \cxxref{temp.param}/2 as follows.

\begin{quote}
\setcounter{Paras}{1}
\pnum
There is no semantic difference between \tcode{class} and \tcode{typename} 
in a \grammarterm{template-parameter}. \tcode{typename} 
followed by an \grammarterm{unqualified-id} names a 
template type parameter. \tcode{typename} followed by a 
\grammarterm{qualified-id} denotes the
type in a non-type 
\removed{\grammarterm{parameter-declaration}}
\added{\grammarterm{non-type-or-constrained-parameter}}. 
\end{quote}

Insert the following paragraphs after paragraph 3 in order to distinguish
between a template parameter that declares a non-type parameter and a
template-parameter that declares a constrained parameter, which may
declare a type parameter. 

\begin{quote}
\pnum
When a \grammarterm{non-type-or-constrained-parameter} has
the following form:
\begin{bnf}
constrained-type-specifier ...\opt identifier\opt
\end{bnf}
it declares a \defn{constrained template parameter}.
% 
Otherwise the parameter is a non-type \grammarterm{template-parameter}.

\pnum
If the \tcode{auto} \grammarterm{type-specifier}
appears in the the parameter type of a
\grammarterm{non-type-or-constrained-parameter},
the program is ill-formed. The program is also ill-formed if a
\grammarterm{constrained-type-specifier} appears
anywhere in the \grammarterm{basic-parameter-declaration} 
and the form of that declaration does not match the form above.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;
template<typename T> concept bool D = true;

template<C T> struct S1;       // OK: T is a constrained template parameter
template<int N> struct S2;     // OK: N is a non-type template parameter
template<auto X> struct S2;    // error: auto in template parameter
template<const D N> void f1(); // error: D is used with a const-qualifier
template<D* N> void f2();      // error: N declares a pointer-to-D
\end{codeblock}
\exitexample
\end{quote}

Insert the following paragraphs after paragraph 8. These paragraphs
define the meaning of a constrained template parameter.

\begin{quote}
\setcounter{Paras}{8}
\pnum
A constrained template parameter declares a template parameter whose
type and form match that of the prototype parameter of the concept 
designated by its \grammarterm{constrained-type-specifier}.
The designated concept is found using the rules in
\ref{dcl.spec.constr}. 
% 
Let \tcode{I} be the \grammarterm{declarator-id}
of the \grammarterm{basic-parameter-declaration},
and let \tcode{P} be the prototype parameter of the designated
concept. The declared template parameter is determined by the type
and form of \tcode{P} and the \grammarterm{identifier}
and optional ellipsis in \tcode{I}.
% 
\begin{itemize}
\item If \tcode{P} is a type 
\grammarterm{template-parameter} declared with
the \tcode{class} or \tcode{typename}, the declared parameter is 
a type \grammarterm{template-parameter}. 

\item If \tcode{P} is a non-type 
\grammarterm{template-parameter}, the declared
parameter is a non-type \grammarterm{template-parameter}
having the same type as \tcode{P}. 

\item If \tcode{P} is a template 
\grammarterm{template-parameter}, the declared
parameter is a template \grammarterm{template-parameter}
having the same \grammarterm{template-parameter-list}
as \tcode{P}. 

\item If \tcode{P} declares a template parameter pack,
\tcode{I} shall include an ellipsis, and the declared parameter
is a template parameter pack. 
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<template<typename> class X> concept bool C2 = true;
template<int N> concept bool C3 = true;
template<typename... Ts> concept bool C4 = true;
template<char... Cs> concept bool C5 = true;

template<C1 T> void f1();     // OK: \tcode{T} is a type template-parameter
template<C2 X> void f2();     // OK: \tcode{X} is a template with one type-parameter
template<C3 N> void f3();     // OK: \tcode{N} has type \tcode{int}
template<C4... Ts> void f4(); // OK: \tcode{Ts} is a template parameter pack of types
template<C4 Ts> void f5();    // error: \tcode{Ts} must be preceded by an ellipsis
template<C5... Cs> f6();      // OK: \tcode{Cs} is a template parameter pack of \tcode{char}s
    \end{codeblock}
    \exitexample
    

%%
%% Introduction of template parameters
%%
\rSec1[temp.intro]{Introduction of template parameters}

Add this section after \ref{temp.param}.

\pnum
A \defn{template introduction} provides a convenient way of declaring
different templates that have the same template parameters and constraints.

\begin{bnf}
\nontermdef{template-introduction}\br
  nested-name-specifier\opt concept-name introduction-list

\nontermdef{introduction-list}\br
  introduced-parameter\br
  introduction-list\terminal{,} introduced-parameter\br

\nontermdef{introduced-parameter}\br
  \terminal{...}\opt identifier
\end{bnf}

A template introduction declares a sequence of 
\grammarterm{template-parameter}s, which are derived 
from a \grammarterm{concept-name}
and the sequence of \grammarterm{identifier}s in 
its \grammarterm{introduction-list}.


\pnum
The concept designated by the \grammarterm{concept-name}
(call it \tcode{C}) is determined by the 
\grammarterm{introduction-list}.
% 
The \grammarterm{concept-name} \tcode{C} 
refers to a set of concept definitions. A concept \tcode{CC} in
that set is viable if \tcode{CC} declares at least as many template 
parameters as there are \grammarterm{identifier}s in 
the \grammarterm{introduction-list}, and
all template parameters in excess of the number of 
\grammarterm{identifier}s are declared with default 
template arguments.
% 
If only one concept in that set is viable, that is the concept
designated by \tcode{C}. Otherwise, the program is ill-formed.
% 
\enterexample
It is possible to overload function concepts in such a way that a
\grammarterm{concept-name} can designate multiple
concepts.
\begin{codeblock}
template<typename T> concept bool Eq() { return true; }             // \#1
template<typename T, typename U> concept bool Eq() { return true; } // \#2

Eq{T} void f1(T, T);    // OK: Eq{T} designates \#1
Eq{A, B} void f2(A, B); // OK: Eq{A, B} designates \#2
\end{codeblock}
\begin{codeblock}
template<typename T> concept bool C() { return true; }
template<int N> concept bool C() { return true; }

C{X} void f(); // error: resolution of C{X} is ambiguous
\end{codeblock}
\exitexample

\pnum
For each \grammarterm{introduced-parameter} \tcode{I} in an
\grammarterm{introduction-list},
and for its corresponding template parameter in the 
\grammarterm{template-parameter-list}
of the designated concept (call it \tcode{P}), declare a new template 
parameter using the rules for declaring a constrained parameter in
\ref{temp.param} by using \tcode{I} as a
\grammarterm{declarator-id} and \tcode{P}
as the prototype parameter.
% 
However, if \tcode{I} contains an ellipsis, \tcode{P} shall
declare a template parameter pack.
% 
\enterexample
\begin{codeblock}
template<typename T, int N, typename... Xs> concept bool C1 = true;
template<template<typename> class X> concept bool C2 = true;

C1{A, B, ...C} // OK: A is declared as typename A
  struct s;    // B is declared as int B
               // C is declared as typename... C

C1{X, Y, Z} // error: Z must be preceded by an ellipsis
  struct t;

C2{T} // OK: T is declared as template<typename> class T
  void foo();

C2{...X}      // error: the corresponding parameter is not a 
  void bar(); // template parameter pack
\end{codeblock}
\exitexample

\pnum
\enternote
A concept referred to by a \grammarterm{concept-name} 
may have template parameters with default template arguments. An
\grammarterm{introduction-list} may omit 
\grammarterm{identifier}s for a corresponding template
parameter if it has a default argument. However, only the
\grammarterm{introduced-parameter}s are declared
as template parameters. 
% 
\enterexample
\begin{codeblock}
template<typename A, typename B = bool> 
  concept bool C() { return true; }

C{T} void f(T); // OK: f(T) is a function template with
                // a single template type parameter T
\end{codeblock}
There is no \grammarterm{introduced-parameter} 
that corresponds to the template parameter \tcode{B} in the
\tcode{C} concept, so \tcode{f(T)} is declared with only
one template parameter.
\exitexample
\exitnote
    
\pnum
An introduced template parameter does not have a default template 
argument even if its corresponding template parameter does.
% 
\enterexample
\begin{codeblock}
template<typename T, int N = -1> concept bool P() { return true; }

P{T, N} struct Array { };

Array<double, 0> s1; // OK
Array<double> s2;    // error: Array takes two template arguments
\end{codeblock}
\exitexample

\pnum
\enternote
The introduction of a sequence of template parameters by a
\grammarterm{concept-name} associates a constraint 
with the \grammarterm{template-declaration}
according to the rules describe in \ref{temp}.
\exitnote
    
\end{quote}

%%
%% Names of template specializations
%%
\rSec1[temp.names]{Names of template specializations}


Add the following paragraph to require the implicit instantiation
of default template arguments for non-function templates.

\begin{quote}
\setcounter{Paras}{7}
\pnum
When a \grammarterm{simple-template-id} does 
not name a function, a default 
\grammarterm{template-argument} is implicitly
instantiated (\ref{temp.inst}) in a context that 
requires the value of that default argument.

\enterexample
\begin{codeblock}
template<typename T, typename U = int> struct S { };

S<bool>* p; // the type of p is S<bool, int>*
\end{codeblock}
The default argument for \tcode{U} is instantiated to form
the type \tcode{S<bool, int>*}, but the definition of that
class template specialization is not implicitly instantiated
(\ref{temp.inst}); it is not used in a 
context that requires a complete type.
\exitexample
\end{quote}

Add this paragraph to require the satisfaction of associated constraints
on the formation of the \grammarterm{simple-template-id}.

\begin{quote}
\pnum
When a \grammarterm{simple-template-id} names
a constrained class template, variable template or alias template,
and all \grammarterm{template-argument}s in the
\grammarterm{template-id} are non-dependent,
(\cxxref{temp.nondep}), the associated constraints
are checked against those
\grammarterm{template-argument}s
(\ref{temp.constr}). If, as a result of checking,
the associated constraints are not satisfied, the program is ill-formed.

\enterexample
\begin{codeblock}
template<typename C> = false;

template<C T> struct S { };
template< T> using Ptr = T*;

S<int>* p;  // error: constraints not satisfied
Ptr<int> p; // error: constraints not satisfied
\end{codeblock}
\exitexample
\end{quote}


%%
%% Template arguments
%%
\rSec1[temp.arg]{Template arguments}

%%
%% Template template arguments
%%
\rSec2[temp.arg.template]{Template template arguments}

Modify paragraph 3 to include rules for matching constrained template 
\grammarterm{template parameter}s. Note that the 
examples following this paragraph in
the original document are omitted.

\begin{quote}
\setcounter{Paras}{2}
\pnum
A \grammarterm{template-argument} matches 
a template \grammarterm{template-parameter} 
(call it \tcode{P}) when each of the template parameters in 
the \grammarterm{template-parameter-list} of 
the \grammarterm{template-argument}'s 
corresponding class template or alias template (call it 
\tcode{A}) matches the corresponding template parameter in 
the \grammarterm{template-parameter-list} of 
\tcode{P}\added{, and \tcode{P} is more constrained than
 \tcode{A} according to the rules in 
 \ref{temp.constr}}.

Two template parameters match if they are of the same kind 
(type, non-type, template), 
for non-type \grammarterm{template-parameter}s,
their types are equivalent (\ref{temp.over.link}), and 
for template \grammarterm{template-parameter}s, 
each of their corresponding 
\grammarterm{template-parameter}s matches, recursively. 

When \tcode{P}'s \grammarterm{template-parameter-list} 
contains a template parameter pack 
(\cxxref{temp.variadic}), the template parameter 
pack will match zero or more template parameters or template parameter 
packs in the \grammarterm{template-parameter-list} of 
\tcode{A} with the same type and form as the template parameter
pack in \tcode{P} (ignoring whether those template parameters are 
template parameter packs).
\end{quote}

Add the following example to the end of paragraph 3, after the
examples given in the original document.

\begin{quote}
\setcounter{Paras}{2}
\pnum
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool D = C<T> && requires (T t) { t.g(); };

template<template<C> class P>
  struct S { };

template<C> struct X { };
template<D> struct Y { };
template<typename T> struct Z { };

S<X> s1; // OK: X has the same constraints as P
S<Y> s2; // error: the constraints of P do not subsume those of Y
S<Z> s3; // OK: the constraints of P subsume those of Z
\end{codeblock}
\exitexample
\end{quote}      



%%
%% Template declarations
%%
\setcounter{section}{5}
\rSec1[temp.decls]{Template declarations}

Modify paragraph 2 to indicate that associated constraints are
instantiated separately from the template they are associated with.


%%
%% Class templates
%%
\rSec2[temp.class]{Class templates}

Modify paragraph 3 to require template constraints for out-of-class
definitions of members of constrained templates. Note that the example
in the original document is omitted. The example in this paragraph
is to be added after the omitted example.

\begin{quote}
\setcounter{Paras}{2}
\pnum
When a member function, a member class, a member enumeration, a static 
data member or a member template of a class template is defined outside 
of the class template definition, the member definition is defined as a 
template definition in which the 
\grammarterm{template-parameter}s 
\added{and associated constraints} are those of the class template.

The names of the template parameters used in the definition of the 
member may be different from the template parameter names used in the 
class template definition. The template argument list following the class
template name in the member definition shall name the parameters in the 
same order as the one used in the template parameter list of the member. 

Each template parameter pack shall be expanded with an ellipsis in the 
template argument list.

\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;
template<typename T> concept bool D = true;

template<C T> struct S {
    void f();
    void g();
    template<D U> struct Inner;
  }

template<C T> void S<T>::f() { }        // OK: parameters and constraints match
template<typename T> void S<T>::g() { } // error: no matching declaration for \tcode{S<T>}

template<C T> 
  template<D U> struct S<T>::Inner { }; // OK
\end{codeblock}
The declaration of \tcode{S<T>::g()} does not match because
it does not have the associated constraints of \tcode{S}.
\exitexample
\end{quote}

%%
%% Member functions of class templates
%%
\rSec3[temp.mem.func]{Member functions of class templates}

Add the following example to the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> struct S {
  void f() requires true;
  void g() requires true;
};

template<typename T> 
  void S<T>::f() requires true { } // OK
template<typename T> 
  void S<T>::g() { }               // error: no matching function in S<T>
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Member templates
%%
\rSec2[temp.mem]{Member templates}

Modify paragraph 1 in order to account for constrained member templates
of (possibly) constrained class templates. Add the example in this
document after the example in the original document, which is omitted
here.

\begin{quote}
\pnum
A template can be declared within a class or class template; such a 
template is called a member template. 
% 
A member template can be defined within or outside its class definition 
or class template definition. 
% 
A member template of a class template that is defined outside of its 
class template definition shall be specified with the 
\grammarterm{template-parameter}s 
\added{and associated constraints}
of the class template followed by the 
\grammarterm{template-parameter}s
\added{and associated constraints}
of the member template.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = sizeof(T) <= 4;

template<C1 T>
  struct S {
    template<C2 U> void f(U);
    template<C2 U> void g(U);
  };

template<C1 T> template<C2 U> 
  void S<T>::f(U) { } // OK
template<C1 T> template<typename U> 
  void S<T>::g(U) { } // error: no matching function in \tcode{S<T>}
\end{codeblock}
The associated constraints in the definition of \tcode{g()} do not
match those in of its declaration.
\exitexample
\end{quote}

%%
%% Friends
%%
\setcounter{subsection}{3}
\rSec2[temp.friend]{Friends}

Add the following paragraphs to explain the meaning of constrained
friend declarations. 

\begin{quote}
\setcounter{Paras}{9}
\pnum
A friend function template may be constrained, except:
% 
\begin{itemize}
\item if the friend declares, but does not define, a non-template
function to be a friend of a class template, the associated constraints
of that friend function declaration shall be non-dependent
(\cxxref{temp.nondep}); 
% 
\item if the friend declares a function template specialization to
be a friend of a class template, the declaration shall not have
associated constraints, and the template arguments of that specialization
shall satisfy the associated constraints of the template referred to
by the friend declaration (\ref{temp.deduct.decl}). 
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = false;

template<C1 T> g1(T);
template<C2 T> g2(T);

template<typename T>
  struct S {
    void f1() requires true;  // OK
    void f2() requires C1<T>; // error: constraints refer to T
    void g1<T>(T);            // OK
    void g2<T>(T);            // error: constraints not satisfied
  };
\end{codeblock}
\exitexample

\pnum
\enternote
Within a class template, a friend may define a non-template function
whose constraints specify requirements on template arguments.
\enterexample
\begin{codeblock}
template<typename T> concept bool Eq = requires (T t) { t == t; };

template<typename T>
  strut S {
    bool operator==(S a, S b) requires Eq<T> { return a == b; } // OK
  };
\end{codeblock}
\exitexample
In the instantiation of such a class template, the template
arguments are substituted into the constraints but not evaluated.
Constraints are checked (\ref{temp.constr}) only when
that function is considered as a viable candidate for overload resolution
(\ref{over.match.viable}).
\exitnote
\end{quote}


%%
%% Class template partial specializations
%%
\rSec2[temp.class.spec]{Class template partial specialization}

After paragraph 3, insert the following, which explains constrained
partial specializations.

\begin{quote}
\setcounter{Paras}{3}
\pnum
A class template partial specialization may be constrained (\ref{temp}).
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool N = N > 0;

template<C T1, C T2, N I> class A<T1, T2, I>;  // \#6
template<C T, N I>        class A<int, T*, I>; // \#7
\end{codeblock}
\exitexample
\end{quote}

Modify the 3rd item in the list of paragraph 8 to allow 
constrained class template partial specializations like \#6.
Note that all other items in that list are elided. 

\begin{quote}
\setcounter{Paras}{7}
\pnum
Within the argument list of a class template partial specialization, 
the following restrictions apply:
\begin{itemize}
\item...
\item\added{In an unconstrained class template partial specialization,}
\removed{The}\added{the} argument list of the specialization shall
not be identical to the implicit argument list of the primary template.
\item...
\end{itemize}
\end{quote}


%%
%% Matching of class template partial specializations
%%
\rSec3[temp.class.spec.match]{Matching of class template partial specializations}

Modify paragraph 2; constraints must be satisfied in order
to match a partial specialization. Add the example given here
to the (omitted) example in the original document.

\begin{quote}
\setcounter{Paras}{1}
\pnum
A partial specialization matches a given actual template 
argument list if the template arguments of the partial 
specialization can be deduced from the actual template argument 
list (\cxxref{temp.deduct})
\added{, and the deduced template arguments satisfy the constraints 
of the partial specialization, if any 
(\ref{temp.constr})}.
\enterexample
\begin{codeblock}
struct S { void f(); };

A<S, S, 1>    a6; // uses \#6
A<S, int, 2>  a7; // error: constraints not satisfied
A<int, S*, 3> a8; // uses \#7
\end{codeblock}
\exitexample
\end{quote}
        

%%
%% Partial ordering of class template specializations
%%
\rSec3[temp.class.order]{Partial ordering of class template specializations}

Modify paragraph 1 so that constraints are considered in the
partial ordering of class template specializations. Add the
example at the end of this paragraph to the (omitted) example
in the original document.

\begin{quote}
\pnum
For two class template partial specializations, the first is 
at least as specialized as the second if, given the following 
rewrite to two function templates, the first function template 
is at least as specialized as the second according to the ordering 
rules for function templates 
(\cxxref{temp.func.order}):

\begin{itemize}
\item the first function template has the same template 
parameters \added{and associated constraints} as the first partial 
specialization and has a single function parameter whose
type is a class template specialization with the template 
arguments of the first partial specialization, and

\item the second function template has the same template 
parameters \added{and associated constraints} as the second partial 
specialization and has a single function parameter whose
type is a class template specialization with the template 
arguments of the second partial specialization.
\end{itemize}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool D = C<T> && requires (T t) { t.f(); };


template<typename T> class S { };
template<C T> class S<T> { }; // \#1
template<D T> class S<T> { }; // \#2

template<C T> void f(S<T>); // A
template<D T> void f(S<T>); // B
\end{codeblock}
The partial specialization \#2 is be more specialized than 
\#1 for template arguments that satisfy both constraints because 
\tcode{B} is more specialized than \tcode{A}.
\exitexample
\end{quote}        


%%
%% Function templates
%%
\rSec2[temp.fct]{Function templates}


%%
%% Function template overloading
%%
\rSec3[temp.over.link]{Function template overloading}

Modify paragraph 6 to account for constraints on function
templates.

\begin{quote}
\setcounter{Paras}{5}
\pnum
\removed{ Two function templates are \defn{equivalent} if they are 
declared in the same scope, have the same name, have identical template 
parameter lists, and have return types and parameter lists that are 
equivalent using the rules described above to compare expressions 
involving template parameters.}
% 
\begin{addedblock}
Two function templates are \defn{equivalent} if they are:
\begin{itemize}
\item declared in the same scope,
\item have the same name,
\item have identical template parameter lists,
\item have return types and parameter lists that are equivalent using
     the rules described above to compare expressions involving 
     template parameters, and
\item have associated constraints that are equivalent using the rules 
     in \ref{temp.constr.expr} to
     compare \grammarterm{constraint-expression}s.
\end{itemize}
\end{addedblock}
% 
Two function templates are \defn{functionally equivalent} if they 
are equivalent except that \removed{one or more expressions that involve 
template parameters in the return types and parameter lists are 
functionally equivalent using the rules described above to compare 
expressions involving template parameters}
\begin{addedblock}
\begin{itemize} 
\item one or more expressions that involve template parameters in the 
return types and parameter lists are functionally equivalent using 
the rules described above to compare expressions involving template 
parameters, or if not that, 

\item both function templates have associated constraints that are
functionally equivalent but not equivalent, using the rules in 
\ref{temp.constr.expr} to compare 
\grammarterm{constraint-expression}s.
\end{itemize}
\end{addedblock}
If a program contains declarations of function templates that are 
functionally equivalent but not equivalent, the program is ill-formed; 
no diagnostic is required.
\end{quote}
        

%%
%% Partial ordering of function templates
%%
\rSec3[temp.func.order]{Partial ordering of function templates}

Modify paragraph 2 to include constraints in the partial ordering
of function templates.

\begin{quote}
\setcounter{Paras}{1}
\pnum
Partial ordering selects which of two function templates is 
more specialized than the other by transforming each template 
in turn (see next paragraph) and performing template argument 
deduction using the function type. The deduction process 
determines whether one of the templates is more specialized 
than the other.
% 
If so, the more specialized template is the one chosen by the 
partial ordering process. 
% 
\added{If both deductions succeed, the partial ordering selects
the more constrained template as described by the rules in
\ref{temp.constr.order}.}
\end{quote}


%%
%% Template instantiation and specialization
%%
\rSec1[temp.spec]{Template instantiation and specialization}

%%
%% Implicit instantiation
\rSec2[temp.inst]{Implicit Instantiation}
    
Add the following paragraph after paragraph 1 in order to explain
the how constrained members are instantiated.

\begin{quote}
\setcounter{Paras}{1}
\pnum
When a constrained member of a class is instantiated, new constraints
for the instantiated declaration are formed by substituting the
template arguments into the associated constraints of that member.
The resulting expression is not evaluated after this substitution.
% 
If the substitution fails, the program is ill-formed.
% 
\enternote
The evaluation of constraints happens during lookup or overload
resolution (\ref{over}). Preserving the spelling
of the substituted constraint also allows constrained member function
to be partially ordered by those constraints according to the rules
in \ref{temp.constr}.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) > 2;
template<typename T> concept bool D = C<T> && sizeof(T) > 4;

template<typename T> struct S {
  S() requires C<T> { } // \#1
  S() requires D<T> { } // \#2
};

S<char> s1;    // error: no matching constructor
S<char[8]> s2; // OK: calls \#2
\end{codeblock}
The instantiation of \tcode{S<char>} produces a class
template specialization having the constructors, 
\tcode{S<char>::S() requires C<char>} and
\tcode{S<char>::S() requires D<char>}.
% 
Even though neither constructor will be selected by overload resolution,
they remain a part of the class template specialization. This also
has the effect of suppressing the implicit generation of a default 
constructor (\cxxref{class.ctor}).
% 
\begin{codeblock}
template<typename T> struct S2 {
    void f() requires T::value == 1;
  };

S2<int> s; // error: substitution failure in definition of S2<int>
\end{codeblock}
\exitexample
\end{quote}    


%%
%% Explicit instantiation
%%
\rSec2[temp.explicit]{Explicit instantiation}

Add the following paragraphs to this section. These require an explicit
instantiation of a constrained template to satisfy the template's
associated constraints.

\begin{quote}
\setcounter{Paras}{13}
\pnum
If the explicit instantiation names a class template specialization
or variable template specialization of a constrained template, then
the \grammarterm{template-arguments} in the
\grammarterm{template-id} of the explicit
instantiation shall satisfy the template's associated constraints
(\ref{temp.constr}).
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 1;

template<C T> struct S { };

template S<char>;    // OK
template S<char[2]>; // error: constraints not satisfied
\end{codeblock}
\exitexample

\pnum
When an explicit instantiation refers to a specialization of a
function template (\ref{temp.deduct.decl}), that 
template's associated constraints shall be satisfied by the template 
arguments of the explicit instantiation.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { -t; };

template<C T>        void f(T) { } // \#1
template<typename T> void g(T) { } // \#2
template<C T>        void g(T) { } // \#3

template void f(int);   // OK: refers to \#1
template void f(void*); // error: no matching template
template void g(int);   // OK: refers to \#3
template void g(void*); // OK: refers to \#2\end{codeblock}
\exitexample
\end{quote}


%%
%% Explicit specialization
%%
\rSec2[temp.expl.spec]{Explicit specialization}


Insert the following paragraphs after paragraph 12. These require
an explicit specialization to satisfy the constraints of the primary
template.

\begin{quote}
\setcounter{Paras}{11}
\pnum
The \grammarterm{template-arguments} in the
\grammarterm{template-id} of an explicit 
specialization of a constrained class template or
constrained variable template shall satisfy the associated constraints
of that template, if any (\ref{temp.constr}).
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 1;

template<C T> struct S { };

template<> S<char> { };    // OK
template<> S<char[2]> { }; // error: constraints not satisfied
\end{codeblock}
\exitexample

\pnum
When determining the function template referred to by an explicit 
specialization of a function template 
(\ref{temp.deduct.decl}),
the associated constraints of that template (if any) shall be satisfied 
(\ref{temp.constr}) by the
template arguments of the explicit specialization.
% 
\enterexample
\begin{codeblock}
template<C T>        void f(T); // \#1
template<typename T> void g(T); // \#2
template<C T>        void g(T); // \#3

template<> void f(int);   // OK: refers to \#1
template<> void f(void*); // error: no matching template
template<> void g(int);   // OK: refers to \#3
template<> void g(void*); // OK: refers to \#2
\end{codeblock}
\exitexample
\end{quote}


%
% Function template specializations
%
\rSec1[temp.fct.spec]{Function template specializations}

%%
%% Template argument deduction
%%
\rSec2[temp.deduct]{Template argument deduction}

Add the following sentences to the end of paragraph 5. This defines
the substitution of template arguments into a function template's
associated constraints. Note that the last part of paragraph 5
has been duplicated in order to provide context for the addition.

\begin{quote}
\setcounter{Paras}{4}
When all template arguments have been deduced or obtained from default 
template arguments, all uses of template parameters in the template 
parameter list of the template and the function type are replaced with
the corresponding deduced or default argument values. 
% 
If the substitution results in an invalid type, as described above, type 
deduction fails.
% 
\begin{addedblock}
If the function template has associated constraints
(\ref{temp}),
the template arguments are substituted into the constraints without 
evaluating the resulting expression. If this substitution results in an 
invalid type, then the resulting expression is defined to be 
\tcode{false}.
% 
The resulting constraints are associated with the function template
specialization.
% 
\enternote
The constraints associated with the function template specialization
are checked (\ref{temp.constr}) in order to determine 
if the specialization is a viable candidate 
(\ref{over.match.viable}), and not at the point
of substitution.
\exitnote
\end{addedblock}
\end{quote}
      

\setcounter{subsection}{5}
\rSec3[temp.deduct.decl]{Deducing template arguments from a function declaration}

Add the following after paragraph 1 in order to require the
satisfaction of constraints when matching a specialization to a
template.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{2}
\pnum
Remove from the set of function templates considered all those
whose associated constraints (if any) are not satisfied by the deduced
template arguments (\ref{temp.constr}).
\end{addedblock}
\end{quote}

Update paragraph 2 (now paragraph 3) to accommodate the new wording.

\begin{quote}
\pnum
If, 
\removed{for the set of function templates so considered}
\added{for the remaining function templates},
there is either no match or more than one match after partial ordering 
has been considered (\ref{temp.func.order}), deduction fails 
and, in the declaration cases, the program is ill-formed.
\end{quote}

%%
%% Template constraints
%%
\rSec1[temp.constr]{Template constraints}

Add this section after 14.8.

\pnum
\enternote
The defines the meaning of constraints on template arguments, including
the translation of \grammarterm{constraint-expression}s
into constraints by normalization (\ref{temp.constr.expr}),
and the abstract syntax, satisfaction, and subsumption of those constraints
(\ref{temp.constr.op}, \ref{temp.constr.atom}).
\exitnote


\pnum
 A \defn{constraint} is a sequence of logical operators and 
operands that specifies requirements on template arguments. 

\pnum
\defn{Constraint checking} is the processing of substituting 
non-dependent template arguments (\cxxref{temp.nondep}) 
into a constraint for the purpose of determining if the constraint
is satisfied.

After substitution, a constraint is \defn{satisfied} if and only if 
all of its sub-constraints are satisfied according to the evaluation 
rules described in
\ref{temp.constr.op} and
\ref{temp.constr.atom}.
% 
If the substitution of template arguments into a constraint fails, 
that constraint is not satisfied.
% 
\enternote
Substitution into a constraint may yield a well-formed constraint that
contains ill-formed expressions or types. This may happen, for
example, in the implicit instantiation of a class template
specialization (\ref{temp.inst}).
\exitnote


\pnum
A constraint \tcode{P} is said to \defn{subsume} another
constraint \tcode{Q} if, informally, it can be determine that
\tcode{P} implies \tcode{Q}, up to the equivalence of
expressions and types in \tcode{P} and \tcode{Q}.
% 
\enternote
Subsumption does not determine, for example, if the predicate 
constraint (\ref{temp.constr.atom.pred}) 
\tcode{N \% 2 == 1} subsumes \tcode{N \& 1} for 
some integral template argument, \tcode{N}. 
\exitnote
The rules defining the subsumption relation are given for each kind
of constraint in
\ref{temp.constr.op} and
\ref{temp.constr.atom}.


%%
%% Logical operators
%%
\rSec2[temp.constr.op]{Logical operators}

\pnum
There are two logical operators on constraints: conjunction and disjunction.

%%
%% Conjunction
%%
\rSec3[temp.constr.op.conj]{Conjunction}

\pnum
A \defn{conjunction} is a logical operator taking two 
operands. A conjunction of constraints is satisfied if and only 
if both operands are satisfied. 

\pnum
A conjunction of the constraints \tcode{P} 
and \tcode{Q} subsumes another constraint \tcode{R}
if and only if \tcode{P} subsumes \tcode{R},
\tcode{Q} subsumes \tcode{R}, or both subsume
\tcode{R}.


%%
%% Disjunction
%%
\rSec3[temp.constr.op.disj]{Disjunction}

\pnum
A \defn{disjunction} is a logical operator taking two 
operands. A disjunction of constraints is satisfied if and only 
if either operand is satisfied or both operands are satisfied. 

\pnum
A disjunction of the constraints \tcode{P} and \tcode{Q}
subsumes another constraint \tcode{R} if and only if
\tcode{P} subsumes \tcode{R} and \tcode{Q} subsumes
\tcode{R}.
          

%%
%% Atomic constraints
%%
\rSec2[temp.constr.atom]{Atomic constraints}

\pnum
Any constraint that is not a conjunction or disjunction is an
\defn{atomic constraint}.

\pnum
An atomic constraint \tcode{P} subsumes a disjunction
of the constraints \tcode{Q} and \tcode{R} if and only
if \tcode{P} subsumes \tcode{Q}, \tcode{P}
subsumes \tcode{R}, or both. 

\pnum
An atomic constraint \tcode{P} subsumes a conjunction
of the constraints \tcode{Q} and \tcode{R} if and only
if \tcode{P} subsumes \tcode{Q} and \tcode{P}
subsumes \tcode{R}.


%%
%% Predicate constraints
%%
\rSec3[temp.constr.atom.pred]{Predicate constraints}

\pnum
A \defn{predicate constraint} is an atomic constraint
that evaluates a prvalue constant expression of type \tcode{bool}
(\cxxref{expr.const}).
The constraint is satisfied if and only if the expression 
evaluates to \tcode{true}.
% 
\enternote
Predicate constraints allow the definition of template requirements
in terms of constant expressions. This enables constraints on non-type
arguments, template template arguments, and also the definition of
constraints as metaprograms on template arguments.
\exitnote

\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 4 && !true;
\end{codeblock}
Here, \tcode{sizeof(T) == 4} and \tcode{!true} are 
predicate constraints required by the concept, \tcode{C}.
\exitexample
          

\pnum
A predicate constraint \tcode{P} subsumes another
predicate constraint \tcode{Q} if and only if
\tcode{P} and \tcode{Q} are equivalent
\grammarterm{constraint-expression}s
(\ref{temp.constr.expr}).

\enterexample
The predicate \tcode{M >= 0} does not subsume the predicate
\tcode{M > 0} because they are not equivalent
\grammarterm{constraint-expressions}.
\exitexample
          

%%
%% Expression constraints
%%
\rSec3[temp.constr.atom.expr]{Expression constraints}

\pnum
An \defn{expression constraint} is an atomic constraint
that specifies a requirement on the formation of an
\grammarterm{expression} (call it \tcode{E})
through substitution of template arguments.
% 
An expression constraint is satisfied if \tcode{E} is non-dependent, 
meaning that the substitution yielding \tcode{E} did not fail. 
Within an expression constraint, \tcode{E} is an unevaluated 
operand (\ref{expr}).
% 
\enternote
An expression constraint is introduced by the 
\grammarterm{expression} in either a
\grammarterm{simple-requirement} 
(\ref{expr.prim.req.simple}) or
\grammarterm{compound-requirement}
(\ref{expr.prim.req.compound}) of a
\grammarterm{requires-expression}.
\exitnote
% 
\enterexample
The concept \tcode{C} introduces an expression constraint for 
the expression \tcode{++t}.
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { ++t; };
\end{codeblock}
The type argument \tcode{int} satisfies this constraint because the
the expression \tcode{++t} is valid after substituting \tcode{int}
for \tcode{T}.
\exitexample
          

\pnum
An expression constraint \tcode{P} subsumes another
expression constraint \tcode{Q} if and only if
the \grammarterm{expression}s of \tcode{P}
and \tcode{Q} are equivalent 
(\ref{temp.over.link}). 


%%
%% Type constraints
%%
\rSec3[temp.constr.atom.type]{Type constraints}

\pnum
A \defn{type constraint} is an atomic constraint that
specifies a requirement on the formation 
of a type (call it \tcode{T}) through the substitution of
template arguments
% 
A type constraint is satisfied if and only 
\tcode{T} is non-dependent, meaning that the substitution 
yielding \tcode{T} did not fail.
% 
\enternote
A type constraint is introduced by the 
\grammarterm{typename-specifier} in a
\grammarterm{type-requirement} of a
\grammarterm{requires-expression}
(\ref{expr.prim.req.type}).
\exitnote
% 
\enterexample
The concept \tcode{C} introduces a type constraint for the 
type name \tcode{T::type}.
\begin{codeblock}
template<typename T> concept bool C = 
  requires (T t) { 
    typename T::type;
  };
\end{codeblock}
The type \tcode{int} does not satisfies this constraint 
because substitution of that type into the constraint results in a
substitution failure; \tcode{int::type} is ill-formed.
\exitexample
          

\pnum
A type requirement that names a class template specialization 
does not require that type to be complete 
(\cxxref{basic.types}). 

\pnum
A type requirement \tcode{P} subsumes another type
requirement \tcode{Q} if and only if the types in \tcode{P}
and \tcode{Q} are equivalent 
(\cxxref{temp.type}). 


%%
%% Implicit conversion constraints
%%
\rSec3[temp.constr.atom.conv]{Implicit conversion constraints}

\pnum
A \defn{implicit conversion constraint} is an atomic
constraint that specifies a requirement 
on the implicit conversion of an 
\grammarterm{expression}
(call it \tcode{E}) to a 
type (call it \tcode{T}). The constraint is satisfied if and 
only if \tcode{E} is implicitly convertible to \tcode{T}
(\cxxref{conv}).
% 
\enternote
A conversion constraint is introduced by a
\grammarterm{trailing-return-type} in a
\grammarterm{compound-requirement} when
its type contains no placeholders
(\ref{expr.prim.req.compound}).
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = 
  requires (T a, T b) {
    { a == b } -> bool;
  };
\end{codeblock}
The \grammarterm{compound-requirement} in the
\grammarterm{requires-expression} of \tcode{C}
introduces two atomic constraints: an expression constraint
for \tcode{a == b} and the implicit conversion constraint that 
the expression \tcode{a == b} is implicitly convertible to
\tcode{bool}.
\exitexample
          
\pnum
An implicit conversion constraint \tcode{P} subsumes 
another implicit conversion constraint \tcode{Q} if and only if
the \grammarterm{expression}s of 
\tcode{P} and \tcode{Q} are equivalent
(\ref{temp.over.link}) and the types
of \tcode{P} and \tcode{Q} are equivalent
(\cxxref{temp.type}).


%%
%% Argument deduction constraints
%%
\rSec3[temp.constr.atom.deduct]{Argument deduction constraints}

\pnum
 An \defn{argument deduction constraint} is an atomic
constraint that specifies a requirement on 
the usability of an \grammarterm{expression} 
(call it \tcode{E}) as an argument to an invented 
function template (call it \tcode{F}) that has a single 
parameter whose type (call it \tcode{T}) is
written in terms of \tcode{F}'s template parameters.
% 
The constraint is satisfied if and only if \tcode{F}
is selected by overload resolution for the call \tcode{F(E)}
(\ref{over.match}).
% 
\enternote
Overload resolution selects \tcode{F} only when template 
argument deduction succeeds and \tcode{F}'s associated 
constraints are satisfied.
\exitnote
% 
\enternote
An argument deduction constraint is introduced by a
\grammarterm{trailing-return-type} in a
\grammarterm{compound-requirement} when the
\grammarterm{trailing-type-specifier-seq}
contains at least one placeholder
(\ref{expr.prim.req.compound}).
\exitnote
% 
\enterexample
The concept \tcode{D} introduces an argument deduction 
constraint for the expression \tcode{*t}.
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { ++t; }
template<typename T> concept bool D = requires (T t) { *t -> const C&; }
\end{codeblock}
When determining if \tcode{D} is satisfied, overload resolution
is performed for the call \tcode{g(*t)} against the following 
invented function:
\begin{codeblock}
template<typename T> requires C<T> void g(const T&);
\end{codeblock}
\exitexample
          
\pnum
 An argument deduction constraint \tcode{P} subsumes
another argument deduction constraint \tcode{Q} if and only
if the \grammarterm{expression}s of
\tcode{P} and \tcode{Q} are equivalent
(\ref{temp.over.link}), and the types
of \tcode{P} and \tcode{Q} are equivalent
(\cxxref{temp.type}). 


%%
%% Constant expression constraints
%%
\rSec3[temp.constr.atom.constexpr]{Constant expression constraints}

\pnum
A \defn{constant expression constraint} is an atomic
constraint that specifies a requirement that
an \grammarterm{expression} (call it \tcode{E}) 
can be evaluated during translation. The constraint is satisfied if 
and only if \tcode{E} is a prvalue constant expression 
(\cxxref{expr.const}).
% 
\enternote
A constant expression constraint determines if an expression can be
evaluated during translation for specific \tcode{constexpr}
arguments. It cannot be used to determine if an expression is
evaluated during translation for all possible arguments.
\exitnote
% 
\enternote
Constant expression constraints are introduced by a
\grammarterm{compound-requirement} that
includes the \tcode{constexpr} specifier
(\ref{expr.prim.req.compound}).
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T, int N> concept bool C = 
  requires() {
    constexpr { T(N) }; // determines if T(N) is a constant expression
  };
\end{codeblock}
\exitexample


\pnum
A constant expression constraint \tcode{P} subsumes
another constant expression constraint \tcode{Q} if and
only if the expressions of \tcode{P} and \tcode{Q}
are equivalent (\ref{temp.over.link}). 


%%
%% Exception constraints
%%
\rSec3[temp.constr.atom.noexcept]{Exception constraints}

\pnum
An \defn{exception constraint} is an atomic constraint
that specifies a requirement that an
\grammarterm{expression} 
(call it \tcode{E}) does not throw an exception.
It is satisfied if and only if the expression 
\tcode{noexcept(E)}
is \tcode{true}
(\cxxref{expr.unary.noexcept}).
          
\enternote
Constant expression constraints are introduced by a
\grammarterm{compound-requirement} that
includes the \tcode{noexcept} specifier
(\ref{expr.prim.req.compound}).
\exitnote
          

\pnum
An exception constraint \tcode{P} subsumes another
exception constraint \tcode{Q} if and only if the
\grammarterm{expression}s of \tcode{P}
and \tcode{Q} are equivalent 
(\ref{temp.over.link}). 


%%
%% Partial ordering by constraints
%%
\rSec2[temp.constr.order]{Partial ordering by constraints}


\pnum
The subsumption relation defines a partial ordering on constraints. 
      This partial ordering is used to determine 

\begin{itemize}
\item the best viable candidate of non-template functions
(\ref{over.match.best}), 
\item the address of a non-template function
(\ref{over.over}), 
\item the matching of template template arguments
(\ref{temp.arg.template}).
\item the partial ordering of class template specializations
(\ref{temp.class.order}), 
\item the partial ordering of function templates
(\ref{temp.func.order}), and 
\end{itemize}

\pnum
When two declarations \tcode{D1} and \tcode{D2} are
partially ordered by their constraints, \tcode{D1} is more
constrained than \tcode{D2} if

\begin{itemize}
\item \tcode{D1} and \tcode{D2} are both constrained
declarations and \tcode{D1}'s associated constraints subsume but 
are not subsumed by those of \tcode{D2}, or if not that, 

\item \tcode{D1} is constrained and \tcode{D2} is
unconstrained. 
\end{itemize}

\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = requires(T t) { ++t; };
template<typename T> concept bool C2 = C1<T> && requires(T t) { *t; };

template<C1 T> void f(T);       // \#1
template<C2 T> void f(T);       // \#2
template<typename T> void g(T); // \#3
template<C1 T> void g();        // \#4

f(0);       // selects \#1
f((int*)0); // selects \#2
g(true);    // selects \#3 because \tcode{C1<bool>} is not satisfied
g(0);       // selects \#4
\end{codeblock}
\exitexample


%%
%% Constraint expressions
%%
\rSec2[temp.constr.expr]{Constraint expressions}

\pnum
Certain contexts require expressions that can be transformed
into constraints through the process of normalization.
\begin{bnf}
\nontermdef{constraint-expression}\br
  logical-or-expression
\end{bnf}

\pnum
A \grammarterm{constraint-expression}
\tcode{E} is \defn{normalized} by forming a constraint 
(\ref{temp.constr}) from
\tcode{E} and its subexpressions.
% 
That transformation is defined as follows:

\begin{itemize}
\item The normalization of an expression of the form \tcode{(P)} is
the normalization of \tcode{P}.

\item The normalization of an expression of the form \tcode{P || Q} is
the disjunction of the normalization of \tcode{P} and the
normalization of \tcode{Q}. 

If, in the expression \tcode{P || Q}, lookup of \tcode{operator||} 
finds a user-defined function, the program is ill-formed.

\item The normalization of an expression of the form \tcode{P \&\& Q} is
the conjunction of the normalization of \tcode{P} and the
normalization of \tcode{Q}. 

If, in the expression \tcode{P \&\& Q}, lookup of
\tcode{operator\&\&} finds a user-defined function, the 
program is ill-formed.

\item The normalization of a function call of the form
\tcode{C<A$_1$, A$_2$, ..., A$_n$>()}
where \tcode{A$_1$, A$_2$, ..., A$_n$}
is a sequence of template arguments and \tcode{C} names a function
concept (\ref{dcl.spec.concept}) is defined as follows:

Let \tcode{E} be the expression returned by the function concept 
\tcode{C}, and let \tcode{S} be the result of substituting the
template arguments into that expression. The resulting constraint is
the normalization of \tcode{S}.

\item The normalization of a \grammarterm{id-expression}
of the form \tcode{C<A$_1$, A$_2$, ..., A$_n$>}
where \tcode{A$_1$, A$_2$, ..., A$_n$}
is a sequence of template arguments and \tcode{C} names a variable
concept (\ref{dcl.spec.concept}) is defined as follows:

Let \tcode{E} be the initializer of the variable concept
\tcode{C}, and let \tcode{S} be the result of substituting the
template arguments into that expression. The resulting constraint is
the normalization of \tcode{S}.

\item The normalization of a 
\grammarterm{requires-expression} is 
defined to be the conjunction of constraints introduced by
the body of that expression (\ref{expr.prim.req}).

\item Otherwise, \tcode{E} shall be a prvalue constant
expression of type \tcode{bool}, and it denotes a
predicate constraint (\ref{temp.constr.atom.pred}).
\end{itemize}
% 
\enternote
A \grammarterm{constraint-expression} 
defines a subset of constant expressions over which certain 
logical implications can be deduced during translation.

The prohibition against user-defined logical operators in intended to
prevent the subversion of the underlying logic necessary partially
order constraints (\ref{temp.constr.order}).
\exitnote

\enterexample
\begin{codeblock}
template<typename T> concept bool C1() { return sizeof(T) == 1; }
template<typename T> concept bool C2 = C1<T>() \&\& 1 == 2; }
template<typename T> concept bool C3 = requires () { typename T::type; };

// Expression      // Constraints
C2<char>           sizeof(char) == 1 /* and */ 1 == 2
C3<int>            /* type constraint for int::type */
3 + 4              // error: not a constraint
(bool)(3 + 4)      (bool)(3 + 4)
\end{codeblock}
In the normalized constraints, the expressions \tcode{sizeof(char) == 1}, 
\tcode{1 == 2}, and \tcode{(bool)(3 + 4)} are predicate 
constraints (\ref{temp.constr.atom.pred}). 
% 
The concept \tcode{C4} is normalized to a single type constraint
(\ref{temp.constr.atom.type}) for the (ill-formed) 
type \tcode{int::type}.
% 
The expression \tcode{3 + 4} is not a 
\grammarterm{constraint-expression} because it does
not satisfy the requirements for being normalized into a predicate 
constraint.
\exitexample


\pnum
Two \grammarterm{constraint-expression}s are 
considered equivalent if two function definitions containing the 
expressions would satisfy the one definition rule 
(\cxxref{basic.def.odr}), except that
the tokens used to name template parameters may differ as long as a 
token used to name a template parameter in one expression is replaced by 
another token that names the same template parameter in the other 
expression, and the tokens used to name names of other entities may 
differ only if those names refer to the same set of declarations.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 1;

template<typename T> requires C<T> void f(); // \#1
template<typename U> requires C<U> void f(); // OK: redeclaration of \#1

namespace N1 { template<typename T> concept bool C1 = true; }
namespace N2 { template<typename T> concept bool C2 = true; }

template<typename T> requires N1::C1<T> void g(); // \#2
template<typename T> requires N1::C1<T> void h(); // \#3
using N1::C1;
template<typename T> requires C1<T> void g();     // OK: redeclaration of \#2
using namespace N2;
template<typename T> requires C2<T> void h();     // OK: redeclaration of \#3
\end{codeblock}
\exitexample
% 
Two \grammarterm{constraint-expressions} that are not 
equivalent are functionally equivalent if, for any given set of template 
arguments, the satisfaction of their normalized constraints yields the
same result.
% 
A \grammarterm{constraint-expression} or
subexpression thereof of the form \tcode{(E)} is not equivalent to
\tcode{E}, but the two expressions are functionally equivalent. 
\enterexample
\begin{codeblock}
void f() requires true || 1 == 2;   // \#1
void f() requires true || (1 == 2); // not equivalent but functionally equivalent
\end{codeblock}
\exitexample
