
%%
%% Declarators
%%
\rSec0[dcl.decl]{Declarators}


Modify the definition of the \grammarterm{init-declarator}
production in \cxxref{dcl.decl}/1 as follows:

\begin{quote}
\pnum
A declarator declares a single variable, function, or type within a 
declaration. The \grammarterm{init-declarator-list}
appearing in a declaration is a comma-separated sequence of declarators, 
each of which may
\removed{have an initializer}
\added{have constraints, an initializer, or both}.

\begin{bnf}
\nontermdef{init-declarator}\br
  declarator \added{requires-clause\opt} initializer\opt
\end{bnf}
\end{quote}

Insert the following paragraphs.

\begin{quote}
\pnum
A \grammarterm{requires-clause} in an
\grammarterm{init-declarator} shall only appear
with a function declarator (\ref{dcl.fct}).
% 
If present, the \grammarterm{requires-clause} associates 
its \grammarterm{constraint-expression} with the declared
function (\ref{temp}).
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;

void f1(int x) requires C<int>;       // OK
auto n requires C<decltype(n)> = 'a'; // error: constrained variable declaration
\end{codeblock}
\exitexample

\pnum
The names of parameters in a function declarator are visible in the
\grammarterm{constraint-expression} of the
\grammarterm{requires-clause}.
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;

void f(auto x) requires C<decltype(x)>;
void g(int n) requires sizeof(n) == 4;
\end{codeblock}
\exitexample
\end{quote}


%%
%% Meaning of declarators
%%
\setcounter{section}{2}
\rSec1[dcl.meaning]{Meaning of declarators}


%%
%% Functions
%%
\setcounter{section}{4}
\rSec2[dcl.fct]{Functions}

Refactor the grammar for \grammarterm{parameter-declaration}s in
paragraph 3 in order to support the definition of
\grammarterm{template-parameter}s in
Clause 14.

\begin{quote}
\setcounter{Paras}{2}
\pnum

\begin{bnf}
\begin{removedblock}
\nontermdef{parameter-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq declarator\br
    attribute-specifier-seq\opt decl-specifier-seq declarator \terminal{=} initializer-clause\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt \terminal{=} initializer-clause
\end{removedblock}

\begin{addedblock}
\nontermdef{parameter-declaration}\br
  basic-parameter-declaration\br
  basic-parameter-declaration \terminal{=} initializer
\end{addedblock}

\begin{addedblock}
\nontermdef{basic-parameter-declaration}\br
    attribute-specifier-seq\opt decl-specifier-seq declarator\br
    attribute-specifier-seq\opt decl-specifier-seq abstract-declarator\opt\br
\end{addedblock}
\end{bnf}
\end{quote}

Modify the second sentence of paragraph 5. The remainder of this
paragraph has been omitted.

\begin{quote}
\setcounter{Paras}{4}
\pnum
A single name can be used for several different functions in a single 
scope; this is function overloading (\ref{over}). 
% 
All declarations for a function shall agree exactly in \removed{both} 
the return type\added{,} \removed{and} the parameter-type-list\added{,
and asssociated constraints, if any (\ref{temp})}.
\end{quote}

Modify paragraph 15. Note that the footnote reference has been
omitted.

\begin{quote}
\setcounter{Paras}{14}
\pnum
There is a syntactic ambiguity when an ellipsis occurs at the end of a 
\grammarterm{parameter-declaration-clause} without
a preceding comma. In this case, the ellipsis is parsed as part of the 
\grammarterm{abstract-declarator} if the type of the
parameter either names a template parameter pack that has not been 
expanded or contains \added{either} \tcode{auto} \added{or a 
\grammarterm{constrained-type-specifier}}; otherwise, 
it is parsed as part of the 
\grammarterm{parameter-declaration-clause}.
\end{quote}

Add the following paragraphs after
\cxxref{dcl.fct}/15.

\begin{quote}
\pnum
An <dfn>abbreviated function</dfn> is a function whose
parameter-type-list inclues one or more placeholders 
(\ref{dcl.spec.auto}, \ref{dcl.spec.constr}).
% 
An abbreviated function is equivalent to a function template 
(\ref{temp.fct}) whose
\grammarterm{template-parameter-list}
includes one invented \grammarterm{template-parameter}
for each occurrence of a placeholder in the 
\grammarterm{parameter-declaration-clause}, 
in order of appearance. 
% 
If the placeholder is designated by the \tcode{auto}
\grammarterm{type-specifier}, then the corresponding
invented template parameter is a type 
\grammarterm{template-parameter}.
% 
Otherwise, the placeholder is designated by a
\grammarterm{constrained-type-specifier}, and
the corresponding invented parameter matches the type and form of
the prototype parameter (\ref{dcl.spec.concept}) of 
the concept designated by the 
\grammarterm{constrained-type-specifier}.
% 
The invented \grammarterm{template-parameter} is 
a parameter pack if the corresponding 
\grammarterm{parameter-declaration}
declares a function parameter pack and the type of the parameter 
contains only one placeholder.
% 
If the type of the function parameter that declares a function
parameter pack containing more than one placeholder, the program
is ill-formed.
% 
The adjusted function parameters of an abbreviated function are derived 
from the \grammarterm{parameter-declaration-clause} 
by replacing each occurrence of a placeholder with the name of the 
corresponding invented \grammarterm{template-parameter}.
% 
If the replacement of a placeholder with the name of a template parameter
results in an invalid parameter declaration, the program is ill-formed.
% 
\enterexample
\begin{codeblock}
template<typename T> class Vec { };
template<typename T, typename U> class Pair { };

void f1(const auto&, auto);
void f2(Vec<auto*>...);
void f3(auto (auto::*)(auto));

template<typename T, typename U> 
  void f1(const T&, U);        // redeclaration of \tcode{f1(const auto\&, auto)}
template<typename... T> 
  void f2(Vec<T*>...);         // redeclaration of \tcode{f2(Vec<auto*>...)}
template<typename T, typename U, typename V>
  void f3(T (U::*)(V));        // redeclaration of \tcode{f3(auto (auto::*)(auto))}

void foo(Pair<auto, auto>...); // error: multiple placeholder types in a parameter pack

template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = true;
template<typename T, typename U> concept bool D = true;

void g1(const C1*, C2&);
void g2(Vec<C1>&);
void g3(C1&...);
void g4(Vec<D<int>>);

template<C1 T, C2 U> void g1(const T*, U&); // redeclaration of \tcode{g1(const C1*, C2\&)}
template<C1 T> void g2(Vec<T>&);            // redeclaration of \tcode{g2(Vec<C1>\&)}
template<C1... Ts> void g3(Ts&...);         // redeclaration of \tcode{g3(C1\&...)}
template<D<int> T> void g4(Vec<T>);         // redeclaration of \tcode{g4(Vec<D<int>>)}
\end{codeblock}
\exitexample
% 
\enterexample
\begin{codeblock}
template<int N> concept bool Num = true;

void h(Num*); // error: invalid type in parameter declaration
\end{codeblock}
The equivalent and erroneous declaration would have this form:
\begin{codeblock}
template<int N> void h(N*); // error: invalid type
\end{codeblock}
\exitexample

\pnum
All placeholders introduced
\grammarterm{constrained-type-specifier} 
that are equivalent according to the definition in
\ref{dcl.spec.constr} have the
same invented template parameter.
\enterexample
\begin{codeblock}
namespace N {
  template<typename T> concept bool C = true;
}
template<typename T> concept bool C = true;
template<typename T, int> concept bool D = true;
template<typename, int = 0> concept bool E = true;

void f0(C a, C b);
\end{codeblock}
The types of \tcode{a} and \tcode{b} are the same invented template
type parameter.

\begin{codeblock}
void f1(C& a, C* b);
\end{codeblock}
The type of \tcode{a} is a reference to an invented template type parameter 
(call it \tcode{T}), and the type of \tcode{b} is a pointer to 
\tcode{T}.

\begin{codeblock}
void f2(N::C a, C b);
void f3(D<0> a, D<1> b);
\end{codeblock}
In both functions, the parameters \tcode{a} and
\tcode{b} have different invented template type parameters.

\begin{codeblock}
void f4(E a, E<> b, E<0> c);
\end{codeblock}
The types of \tcode{a}, \tcode{b}, and \tcode{c} are
the same since \grammarterm{constrained-type-specifier}s
\tcode{E}, \tcode{E<>}, and \tcode{E<0>}
all associate the \grammarterm{constraint-expression},
\tcode{E<T, 0>}, where \tcode{T} is an invented
template type parameter.
</p>

<!-- TODO: Move into temp.fct? -->
<p> A function template can be an abbreviated function. The
invented \grammarterm{template-parameter}s are
added to the \grammarterm{template-parameter-list}
after the explicitly declared \grammarterm{template-parameter}s.

\enterexample
\begin{codeblock}
template<typename T, int N> class Array { };

template<int N> void f(Array<auto, N>*);
template<int N, typename T> void f(Array<T, N>*); // OK: equivalent to f(Array<auto, N>*)
\end{codeblock}
\exitexample
\end{quote}

%%
%% Function definitions
%%
\setcounter{section}{3}
\rSec1[dcl.fct.def]{Function definitions}


%%
%% In general
%%
\rSec2[dcl.fct.def.general]{In general}

Modify the \grammarterm{function-definition}
syntax in \cxxref{dcl.fct.def.general}/1
to include a \grammarterm{requires-clause}.

\begin{quote}
\pnum
\begin{bnf}
\nontermdef{function-definition}\br
    attribute-specifier-seq\opt decl-specifier-seq\opt declarator virt-specifier-seq\opt \added{requires-clause\opt} function-body
\end{bnf}
\end{quote}

Add the following paragraph.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{8}
If present, the \grammarterm{requires-clause}
associates its \grammarterm{constraint-expression}
with the function (\ref{temp}).
\end{addedblock}
\end{quote}
