
<cxx-clause id="temp" number="14">
  <h1>Templates</h1>

  Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p number="1" class="quoted">
  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins><bnf-opt>requires-clause</bnf-opt></ins>
        declaration
      </bnf-alt>
      <ins>
      <bnf-alt>
        <bnf-opt>nested-name-specifier</bnf-opt> 
        concept-name
        <bnf-terminal>{</bnf-terminal>
        introduction-list
        <bnf-terminal>}</bnf-terminal>
        declaration
      </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt><bnf-terminal>requires</bnf-terminal> constraint-expression</bnf-alt>

    <bnf-rule>introduction-list</bnf-rule>
      <bnf-alt>introduced-parameter</bnf-alt>
      <bnf-alt>introduction-list<bnf-terminal>,</bnf-terminal> introduced-parameter</bnf-alt>

      <bnf-rule>introduced-parameter</bnf-rule>
        <bnf-alt><bnf-opt><bnf-terminal>...</bnf-terminal></bnf-opt> identifier</bnf-alt>
    </ins>
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp"></cxx-ref>/6.

  <p> A <cxx-grammarterm>template-declaration</cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  (<cxx-ref to="temp.param"></cxx-ref>), or they are
  introduced by a <dfn>concept introduction</dfn>, a
  <cxx-grammarterm>concept-name</cxx-grammarterm> and following
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.</p>

  <p> The concept designated by the <cxx-grammarterm>concept-name</cxx-grammarterm>
  is determined by the <cxx-grammarterm>introduction-list</cxx-grammarterm>.
  Let <code>C</code> be a <cxx-grammarterm>concept-name</cxx-grammarterm>
  and <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code> be a 
  sequence of <cxx-grammarterm>identifiers</cxx-grammarterm> in the
  <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s of
  an <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  If the <cxx-grammarterm>template-id</cxx-grammarterm>,
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code>, refers to a single
  concept declaration, then that concept is the one designated by
  <code>C</code>. Otherwise, the program is ill-formed.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i>
  </cxx-codeblock>
  It is possible to overload function concepts in such a way that a
  <cxx-grammarterm>concept-name</cxx-grammarterm> can designate multiple
  concepts.
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of</i> C{X} <i>is ambiguous</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>Each <cxx-grammarterm>identifier</cxx-grammarterm>, <code>I</code>,
  in the <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s
  of the <cxx-grammarterm>introduction-list</cxx-grammarterm> 
  is declared to be a template parameter that matches the 
  corresponding template parameter, <code>P</code>, in the 
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
  of the concept designated by the 
  <cxx-grammarterm>concept-name</cxx-grammarterm>.
  <cxx-grammarterm>
  <ul>
  
  <li> If <code>P</code> is a template 
  <cxx-grammarterm>type-parameter</cxx-grammarterm> declared with either 
  the <code>class</code> or <code>typename</code> keyword, 
  <code>I</code> is declared as a template 
  <cxx-grammarterm>type-parameter</cxx-grammarterm> using the same keyword;</li>
  
  <li> if <code>P</code> is a template <cxx-grammarterm>type-parameter</cxx-grammarterm> 
  that declares a class template, <code>I</code> is declared as a
  class template with the template parameters of <code>P</code>;</li>
  
  <li> if <code>P</code> is a non-type 
  <cxx-grammarterm>template-parameter</cxx-grammarterm>, <code>I</code> is
  declared as a non-type <cxx-grammarterm>template-parameter</cxx-grammarterm> 
  having the same type as <code>P</code>;</li>
  
  <li> if <code>P</code> is a template parameter pack, 
  the <cxx-grammarterm>identifier</cxx-grammarterm>, <code>I</code>,
  shall be preceded by an ellipsis, and is declared as a template parameter 
  pack.</li>
  </ul>
  
  An <cxx-grammarterm>introduced-parameter</cxx-grammarterm> shall not contain
  an ellipsis if its corresponding template parameter does not declare
  a template parameter pack.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N, typename... Xs&gt; concept bool Inscrutable = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool Unary_template = true;

Inscrutable{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;             // B <i>is declared as</i> int B
                        // C <i>is declared as</i> typename... C

Inscrutable{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

Unary_template{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

Unary_template{...X} // <i>error: the corresponding parameter is not a</i> 
  void bar();        // <i>template parameter pack</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>
  <cxx-note>
  A concept referred to by a <cxx-grammarterm>concept-name</cxx-grammarterm> 
  may have template parameters with default template arguments. An
  <cxx-grammarterm>introduction-list</cxx-grammarterm> may omit 
  <cxx-grammarterm>identifier</cxx-grammarterm>s for a corresponding template
  parameter if it has a default argument. However, only the
  <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s are declared
  as template parameters. 
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename A, typename B = bool&gt; 
  concept bool Ineffable() { return true; }

Ineffable{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                        // <i>a single template type parameter</i> T
  </cxx-codeblock>
There is no <cxx-grammarterm>introduced-parameter</cxx-grammarterm> 
that corresponds to the template parameter <code>B</code> in the
<code>Ineffable</code> concept, so <code>f(T)</code> is declared with only
one template parameter.
  </cxx-example>
  </cxx-note>
  </p>

  <p> The <cxx-grammarterm>introduction-list</cxx-grammarterm> shall not
  be empty.</p>

  <p> An introduced template parameter does not have a default template 
  argument, even if its corresponding template parameter does.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <!-- FIXME: Does this belong here or in member functions? -->
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p>

  <p> A <cxx-grammarterm>template-declaration</cxx-grammarterm> declared
  by a concept introduction can also be an abbreviated function
  (<cxx-ref to="dcl.fct"></cxx-ref>).

  The invented template parameters introduced by the presence of
  <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>s or
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in
  the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
  are added to the list of template parameters introduced by the the
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} void f(T, D);

template&lt;C T, D __D&gt; void f(T, __D); // <i>OK: redeclaration of</i> f(T, D)
  </cxx-codeblock>
  </cxx-example>
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  void f(D);
  D{U} void g(U, C);
};

C{T} void X&lt;T&gt;::f(D) { } // <i>OK: definition of</i> X&lt;T&gt;::f(D);
                         // f <i>is a function template with one invented</i>
                         // <i>template type-parameter</i>

C{T} D{U} void X&lt;T&gt;::g(U, C) { } // <i>OK: definition of</i> X&lt;T&gt;::g(U, C);
                                 // g <i>is a function template with two template</i>
                                 // <i>type parameters: one introduced (</i>U<i>) and</i>
                                 // <i>one invented</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> The introduction of a sequence of template parameters,
  <code>T1, T2, ..., T<i>n</i></code>, by a 
  <cxx-grammarterm>concept-name</cxx-grammarterm>, <code>C</code>,
  associates a constraint with the 
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. That constraint is
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;</code> when <code>C</code> designates
  a variable concept and
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;()</code> when <code>C</code> designates
  a function concept. If an <cxx-grammarterm>introduced-parameter</cxx-grammarterm>
  declares a template parameter pack, its corresponding template argument in the
  associated constraint is a pack expansion 
  (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>).

  <cxx-example>
  <cxx-codeblock>
template&lt;typename A, typename B, int C&gt; concept bool C = true;
template&lt;typename A, typename... Args&gt; concept bool D = true;

C{X, Y, Z} struct S;  // <i>associates</i> C&lt;X, Y, Z&gt; <i>with</i> S
D{P, ...Qs} struct T; // <i>associates</i> D&lt;P, Qs...&gt; <i>with</i> T
  </cxx-codeblock>
  </cxx-example>
  </p>


  <!-- FIXME: This should move to a separate section? -->


  <p>A <cxx-grammarterm>template-declaration</cxx-grammarterm>'s 
  <dfn>associated constraints</dfn> are a conjunction of all constraints 
  introduced by
  <ul>
  <li> a concept introduction,

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> following a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>)
  in the declaration's <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li> any <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
  a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"></cxx-ref>),</li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> appearing after
  the <cxx-grammarterm>declarator</cxx-grammarterm> of an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>), or</li>

  <li>some combination these.</li>
  </ul>

  A <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>T</code>, 
  whose constraints are introduced using any combination of these mechanisms is 
  equivalent to another <cxx-grammarterm>template-declaration</cxx-grammarterm>,
  <code>E</code>, whose template parameters are declared explicitly and as
  unconstrained template parameters, and <code>E</code> has a single 
  <cxx-grammarterm>requires-clause</cxx-grammarterm> whose 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T</code> 
  (<cxx-ref to="temp.over.link"></cxx-ref>).

  <cxx-note> This section describes how constrained template declarations can 
  be equivalently written using alternative syntax in order to generate
  a canonical spelling of a template's associated constraints. 
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);
  </cxx-codeblock>
  The last declaration includes the canonical spelling of the associated 
  constraints for all declarations of <code>g(T)</code> as the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of its
  <cxx-grammarterm>requires-clause</cxx-grammarterm>.
  </cxx-example>
  The paragraphs below define the rules that make these declarations
  equivalent.
  </cxx-note>
  <p>

  <p> When <cxx-grammarterm>template-declaration</cxx-grammarterm> is
  declared by a concept introduction, it is equivalent to a
  <cxx-grammarterm>template-declaration</cxx-grammarterm> whose
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> is defined 
  according to the rules for introducing template parameters above, and the 
  equivalent declaration has a <cxx-grammarterm>requires-clause</cxx-grammarterm> 
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  equivalent to constraint associated by the concept introduction.
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt;      // <i>constraint associated by</i> C4{...Qs}
    void void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p>When a <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>T</code>, is
  explicitly declared with <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>), it
  is equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>E</code>,
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"></cxx-ref>).
  
  The declaration, <code>E</code>, has a <cxx-grammarterm>requires-clause</cxx-grammarterm>
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is the
  conjunction of the constraints associated by the constrained template 
  parameters in <code>T</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared. If the constraints of a redeclaration are
  functionally equivalent, but not equivalent to, those of the original,
  the program is ill-formed; no diagnostic is required
  (<cxx-ref to="temp.over.link"></cxx-ref>).

  If the original declaration, <code>T</code>, includes a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm>, its
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>E</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename X, int Y&gt; 
  requires C2&lt;Y&gt; &amp;&amp; C1&lt;X&gt;
    struct S; // <i>error: constraints are functionally equivalent but not</i>
              // <i>equivalent to those of</i> R<i>; no diagnostic required</i>

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"></cxx-ref>. The associated constraints of the
  abbreviated function are evaluated in the order in which they appear.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires D&lt;U&gt;() &amp;&amp; C&lt;T&gt;  
    void f(T, T, U): // <i>error: constraints are functionally equivalent</i>
                     // <i>but not equivalent to those of</i> f(C, C, D)</i>;
                     // <i>no diagnostic required</i></cxx-codeblock>
  </cxx-example>
  </p>

  <p> An abbreviated function can also be declared as a
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in the
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> and the
  following <cxx-grammarterm>requires-clause</cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

template&lt;C T, D U&gt;
  requires P&lt;T&gt;     // <i>associated constraints are</i> C&lt;T&gt; &amp;&amp; D&lt;U&gt;() &amp;&amp; P&lt;T&gt; 
    void g1(T, U);  // <i>error: ill-formed, no diagnostic required</i>;
  
C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)
  </cxx-codeblock>
  The second declaration of <code>g1(T, U)</code> is ill-formed (no diagnostic
  required) because it is functionally equivalent to the first declaration, 
  but not equivalent.
  </cxx-example>


  <p> A <dfn>trailing <cxx-grammarterm>requires-clause</cxx-grammarterm></dfn> 
  is a <cxx-grammarterm>requires-clause</cxx-grammarterm> that appears after
  the <cxx-grammarterm>declarator</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>).

  When a constrained function template or member function template 
  declared with a trailing <cxx-grammarterm>requires-clause</cxx-grammarterm>
  is equivalent to a declaration in which the 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of the
  trailing <cxx-grammarterm>requires-clause</cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U, typename __P&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)
  </cxx-codeblock>
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  </cxx-example>
  </p>


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    Modify the <cxx-grammarterm>template-parameter</cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param"></cxx-ref>/1 in order
    to allow constrained template parameters.

    <p number="1" class="quoted">

    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <del><bnf-alt>parameter-declaration</bnf-alt></del>
        <ins><bnf-alt>non-type-or-constrained-parameter</bnf-alt></ins>

      <ins>
      <bnf-rule>non-type-or-constrained-parameter</bnf-rule>
        <bnf-alt>basic-parameter-declaration</bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> initializer
        </bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> type-id
        </bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> id-expression
        </bnf-alt>
      </ins>
    </bnf-grammar>
    </p>
    
    Update the wording in <cxx-ref in="cxx" to="temp.param"></cxx-ref>/2 as 
    follows.

    <p number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm>template-parameter</cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm>unqualified-id</cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm>qualified-id</cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm>parameter-declaration</cxx-grammarterm></del>
    <ins><cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm></ins>. 
    </p>

    Insert the following paragraphs after paragraph 3 in order to distinguish
    between a template parameter that declares a non-type parameter and a
    template-parameter that declares a constrained parameter, which may
    declare a type parameter. 

    <p number="3" class="quoted">
    When a <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm> has
    the following form:
    <bnf-grammar>
    <bnf-alt>
    constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt>
    </bnf-alt>
    </bnf-grammar>
    it declares a <dfn>constrained template parameter</dfn>.

    Otherwise the parameter is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>.
    </p>

    <p class="quoted">
    If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
    appears in the the parameter type of a
    <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm>,
    the program is ill-formed. The program is also ill-formed if a
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> appears
    anywhere in the <cxx-grammarterm>basic-parameter-declaration</cxx-grammarterm> 
    and the form of that declaration does not match the form above.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S1;       // <i>OK:</i> T <i>is a constrained template parameter</i>
template&lt;int N&gt; struct S2;     // <i>OK:</i> N <i>is a non-type template parameter</i>
template&lt;auto X&gt; struct S2;    // <i>error: auto in template parameter</i>
template&lt;const D N&gt; void f1(); // <i>error:</i> D <i>is used with a const-qualifier</i>
template&lt;D* N&gt; void f2();      // <i>error:</i> N <i>declares a pointer-to-</i>D
    </cxx-codeblock>
    </cxx-example>
    </p>


    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.


    <p number="9" class="quoted">
    A constrained template parameter declares a template parameter whose
    type and form match that of the prototype parameter of the concept 
    designated by its <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
    The designated concept is found using the rules in
    <cxx-ref to="dcl.spec.constr"></cxx-ref>. 

    In particular, when 
    <code>T</code> is a template parameter declared as 
    <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm>,
    and <code>P</code> is its corresponding prototype parameter, then
    <code>T</code> is declared as follows:
    
    <ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> declared with
    the <code>code</code> or <code>typename</code>, <code>T</code> is also 
    type <cxx-grammarterm>template-parameter</cxx-grammarterm> . It is 
    unspecified whether <code>T</code> is declared with <code>class</code>
    or <code>typename</code>.</li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, <code>T</code> is 
    also a non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same type as <code>P</code>.</li>

    <!-- TODO: A template template parameter can be declared with
         typename in addition to class. -->
    <li> If <code>P</code> is a template 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, <code>T</code> is
    also a template <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
    <code>P</code>.</li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>T</code> also declares a template parameter pack. In such cases,
    <code>T</code> shall be declared with <code>...</code> following its
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.</li>
    </ul>

    <div class="quoted">
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error: parameter pack declared without</i> ...
template&lt;C5... Cx&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i>
    </cxx-codeblock>
    </cxx-example>
    </div>
  </cxx-section> <!-- temp.param -->


  <!-- ==============
       Template Names 
       ============== -->

  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    <h1>Template names</h1>


    Add the following paragraph to require the implicit instantiation
    of default template arguments for non-function templates.

    <p number="8" class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> does 
    not name a function, a default 
    <cxx-grammarterm>template-argument</cxx-grammarterm> is implicitly
    instantiated (<cxx-ref to="temp.inst"></cxx-ref>) in a context that 
    requires the value of the default argument.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, typename U = int&gt; struct S { };

S&lt;bool&gt; p; // <i>the type of</i> p <i>i</i>s S&lt;bool, int&gt;
    </cxx-codeblock>
    </cxx-example>
    </p>

    Add this paragraph to require the satisfaction of associated constraints
    on the formation of the <cxx-grammarterm>simple-template-id</cxx-grammarterm>.

    <p number="9" class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> names
    a constrained class template, variable template or alias template,
    and all <cxx-grammarterm>template-argument</cxx-grammarterm>s in the
    <cxx-grammarterm>template-id</cxx-grammarterm> are non-dependent,
    (<cxx-ref to="temp.nondep"></cxx-ref>), the associated constraints
    of the named template shall be satisfied by those
    <cxx-grammarterm>template-argument</cxx-grammarterm>s.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; requires false struct S { };

S&lt;int&gt;* p; // error: constraints not satisfied.
    </cxx-codeblock>
    </cxx-example>

    </p>

  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section id="temp.arg.template">
      <h1>Template template arguments</h1>

      Modify paragraph 3 to include rules for matching constrained template 
      template parameters. Note that the examples following this paragraph in
      the original document are omitted.

      <p number="3" class="quoted">
      A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"></cxx-ref>), and 
      for template <cxx-grammarterm>template-parameter</cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s matches, recursively. 

      When <code>P</code>’s <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <p number="3" class="quoted">
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; && requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    <h1>Template declarations</h1>


    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
      <h1>Class templates</h1>

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. Note that the example
      in the original document is omitted. The example in this paragraph
      is to be added after the omitted example.

      <p number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.

      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;C T&gt; void S&lt;T&gt;::f() { }        // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; 
  template&lt;D U&gt; struct S&lt;T&gt;::Inner { }; // <i>OK</i>
      </cxx-codeblock>
      The declaration of <code>S&lt;T&gt;::g()</code> does not match because
      it does not have the associated constraints of <code>S</code>.
      </cxx-example>
      </p>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        Add the following example to the end of paragraph 1.

        <p number="1" class="quoted">
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g()                   // <i>error: no matching function in</i> S&lt;T&gt;
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
      <h1>Member templates</h1>

      Modify paragraph 1 in order to account for constrained member templates
      of (possibly) constrained class templates. Add the example in this
      document after the example in the original document, which is omitted
      here.

      <p number="1" class="quoted">
      A template can be declared within a class or class template; such a 
      template is called a member template. 

      A member template can be defined within or outside its class definition 
      or class template definition. 

      A member template of a class template that is defined outside of its 
      class template definition shall be specified with the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins>
      of the class template followed by the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s
      <ins>and associated constraints</ins>
      of the member template.

      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = sizeof(T) <= 4;

template&lt;C1 T&gt;
  struct S {
    template&lt;C2 U&gt; void f(U);
    template&lt;C2 U&gt; void g(U);
  };

template&lt;C1 T&gt; template&lt;C2 U&gt; 
  void S&lt;T&gt;::f(U); // <i>OK</i>
template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::g(U); // <i>error: definition does not match</i>
      </cxx-codeblock>
      The associated constraints in the definition of <code>g()</code> do not
      match those in of its declaration.
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.mem -->


    <!-- ============
         Friends
         ============ ->

    <!-- TODO: Rewrite friends -->
    <cxx-section id="temp.friend" number="4">
      <h1>Friends</h1>

      <p>Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend"></cxx-ref>/9.

      <p> 
      A <dfn>constrained friend</dfn> of a class or class template is
      a constrained class template, constrained function template, a 
      constrained ordinary or generic (non-member) function definition.
      
      <cxx-example class="inline">
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;         
      friend void f(X x, U u) { }    // Constrained function template

    template&lt;C W&gt;         
      friend struct Z { };           // Constrained class template

    friend bool operator==(X a, X b) // Constrained ordinary function
      requires C&lt;T&gt;() { return true; }

    friend void g(X a, C b) { }      // Constrained generic function
  };
      </cxx-codeblock>
      Note that <code>g</code> is a generic function because the the
      parameter <code>b</code> has a
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
      </cxx-example>
      </p>

      <p>
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.</p>

    </cxx-section> <!-- temp.friend -->


    <!-- ======================================
         Class template partial specializations
         ====================================== -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      After paragraph 3, insert the following, which explains constrained
      partial specializations.

      <p number="4" class="quoted">
      A class template partial specialization may be constrained
      (<cxx-ref to="temp"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool N = N &gt; 0;

template&lt;C T1, C T2, N I&gt; class A&lt;T1, T2, I&gt;;  // <i>#6</i>
template&lt;C T, N I&gt;        class A&lt;int, T*, I&gt;; // <i>#7</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      Modify the 3rd item in the list of paragraph 8 to allow 
      constrained class template partial specializations like #6.
      Note that all other items in that list are elided.

      <p number="8" class="quoted">
      Within the argument list of a class template partial specialization, 
      the following restrictions apply:
      <ul>
      <li>...</li>
      <li><ins>In an unconstrained class template partial specialization,</ins>
      <del>The</del><ins>the</ins> argument list of the specialization shall
      not be identical to the implicit argument list of the primary template.
      <li>...</li>
      </ul>
      </p>


      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        Modify paragraph 2; constraints must be satisfied in order
        to match a partial specialization. Add the example given here
        to the (omitted) example in the original document.

        <p number="2" class="quoted"> 
        A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.
        <cxx-example class="inline">
        <cxx-codeblock>
struct S { void f(); };

A&lt;S, S, 1&gt;    a6; // <i>uses #6</i>
A&lt;S, int, 2&gt;  a7; // <i>error: constraints not satisfied</i>
A&lt;int, S*, 3&gt; a8; // <i>uses #7</i>
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- temp.class.spec.match -->


      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        Modify paragraph 1 so that constraints are considered in the
        partial ordering of class template specializations. Add the
        example at the end of this paragraph to the (omitted) example
        in the original document.

        <p number="1" class="quoted">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and associated constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and associated constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
        <cxx-codeblock>
template&ltl;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&ltl;typename T&gt; concept bool D = C&ltl;T&gt; &amp;&amp; requires (T t) { t.f(); };


template&lt;typename T&gt; class S { };
template&lt;C T&gt; class S&lt;T&gt; { }; // <i>#1</i>
template&lt;D T&gt; class S&lt;T&gt; { }; // <i>#2</i>

template&lt;C T&gt; void f(S&lt;T&gt;); // <i>A</i>
template&lt;D T&gt; void f(S&lt;T&gt;); // <i>B</i>
        </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> is more specialized than <code>A</code>.
        </cxx-example>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->


    <!-- ==================
         Function templates
         ================== --> 

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        Modify paragraph 6 to account for constraints on function
        templates.

        <p number="6" class="quoted">
        <del> Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical template 
        parameter lists, and have return types and parameter lists that are 
        equivalent using the rules described above to compare expressions 
        involving template parameters.</del>
        <br/>
        <ins>
        Two function templates are <dfn>equivalent</dfn> if they are:
        <ul>
        <li> declared in the same scope,</li>
        <li> have the same name,</li>
        <li> have identical template parameter lists,</li>
        <li> have return types and parameter lists that are equivalent using
             the rules described above to compare expressions involving 
             template parameters, and</li>
        <li> have associated constraints that are equivalent using the rules 
             described in <cxx-ref to="temp.constr.eq"></cxx-ref> to
             compare constraints.</li>
        </ul>
        </ins>

        <div class="quoted">
        Two function templates are <dfn>functionally equivalent</dfn> if they 
        are equivalent except that <del>one or more expressions that involve 
        template parameters in the return types and parameter lists are 
        functionally equivalent using the rules described above to compare 
        expressions involving template parameters</del>
        <ins>
        <ul> 
        <li>one or more expressions that involve template parameters in the 
        return types and parameter lists are functionally equivalent using 
        the rules described above to compare expressions involving template 
        parameters, or if not that, </li>

        <li> the two function templates have constraints that are
        functionally equivalent but not equivalent, using the rules described
        in <cxx-ref to="temp.constr.eq"></cxx-ref> to describe the comparison
        of constraints.</li>
        </ul>
        </ins>
        If a program contains declarations of function templates that are 
        functionally equivalent but not equivalent, the program is ill-formed; 
        no diagnostic is required.
        </div>
        <!-- </p> -->


      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        Modify paragraph 2 to include constraints in the partial ordering
        of function templates.

        <p number="2" class="quoted">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. 

        <ins>If both deductions succeed, the partial ordering selects
        the more constrained template as described by rules in
        <cxx-ref to="temp.constr"></cxx-ref>.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->
    </cxx-section> <!-- temp.fct -->


  <!-- ===============
       Alias templates
       =============== -->

    <cxx-section number="7" id="temp.alias">
      <h1>Alias templates</h1>

      Insert the following after paragraph 2.

      <p number="3" class="quoted">
      If the alias template is constrained, and all template arguments
      are non-dependent, the <cxx-grammarterm>template-argument</cxx-grammarterm>s
      shall satisfy the template's associated constraints 
      (<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-example class="inline">
      <cxx-codeblock>
template<typename C> = false;

template<C T> using Ptr = T*;

Ptr<int> p; // error: constraints not satisfied.
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section>

  </cxx-section> <!-- temp.decls -->


  <!-- =========================================
       Template instantiation and specialization
       ========================================= -->

  <cxx-section id="temp.spec" number="7">
    <h1>Template instantiation and specialization</h1>


    <cxx-section id="temp.inst">
      <h1>Implicit instantiation</h1>

      Add the following paragraph after paragraph 1 in order to explain
      the how constrained members are instantiated.

      <p number="2" class="quoted">
      When a constrained member of a class is instantiated, new constraints
      for the instantiated declaration are formed by substituting the
      template arguments into the associated constraints of that member.
      The resulting expression is not evaluated after this substitution.

      If the substitution fails, the program is ill-formed.

      <cxx-note>
      The evaluation of constraints happens during lookup or overload
      resolution (<cxx-ref to="over"></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr"></cxx-ref>.
      </cxx-note>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C<T> && sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { } // <i>#1</i>
  S() requires D&lt;T&gt; { } // <i>#2</i>
};

S&lt;char&gt; s1;    // <i>error: no matching constructor</i>
S&lt;char[8]&gt; s2; // <i>OK: calls #2</i>
      </cxx-codeblock>
      The instantiation of <code>S&lt;char&gt;</code> produces a class
      template specialization having the constructors, 
      <code>S&lt;char&gt;::S() requires C&lt;char&gt;</code> and
      <code>S&lt;char&gt;::S() requires D&lt;char&gt;</code>.

      Even though neither constructor will be selected by overload resolution,
      they remain a part of the class template specialization. This also
      has the effect of suppressing the implicit generation of a default 
      constructor (<cxx-ref in="cxx" to="class.ctor"></cxx-ref>).

      The default constructor invoked by the declaration of <code>s2</code>
      is the more constrained because the constraint
      <code>D&lt;char[8]&gt;</code> subsumes <code>C&lt;char[8]&gt;</code>.
      </cxx-example>
      </cxx-note>
      </p>

    </cxx-section> <!-- temp.inst -->


    <!-- ======================
         Explicit instantiation
         ====================== -->

    <cxx-section id="temp.explicit">
      <h1>Explicit instantiation</h1>

      Add the following paragraphs to this section. These require an explicit
      instantiation of a constrained template to satisfy the template's
      associated constraints.

      <p number="14" class="quoted">
      If the explicit instantiation names a class template specialization
      or variable template specialization of a constrained template, then
      the <cxx-grammarterm>template-arguments</cxx-grammarterm> in the
      <cxx-grammarterm>template-id</cxx-grammarterm> of the explicit
      instantiation shall satisfy the template's associated constraints
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template S&lt;char&gt;;    // <i>OK</i>
template S&lt;char[2]&gt;; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>

      <p class="quoted">
      An explicit instantiation whose <cxx-grammarterm>template-name</cxx-grammarterm>
      names a set of overloaded function template refers to exactly one
      in that set.

      Remove from that set all function templates for which the
      template arguments of the explicit instantiation
      do not match (<cxx-ref to="temp.arg"></cxx-ref>), 
      cannot be deduced (<cxx-ref to="temp.deduct.type"></cxx-ref>), 
      have different parameter-type-lists,
      and whose constraints are not satisfied by the template arguments.

      The partial ordering of the remaining function templates determines the 
      template to which the specialization refers
      (<cxx-ref to="temp.func.order"></cxx-ref>).
      
      If no function template is found, or if multiple function templates
      are found, the program is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T) { } // <i>#1</i>
template&lt;typename T&gt; void g(T) { } // <i>#2</i>
template&lt;C T&gt;        void g(T) { } // <i>#3</i>

template void f(int);   // <i>OK: refers to #1</i>
template void f(void*); // <i>error: no matching template</i>
template void g(int);   // <i>OK: refers to #3</i>
template void g(void*); // <i>OK: refers to #2</i></cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.explicit -->


    <!-- =======================
         Explicit specialization
         ======================= -->

    <cxx-section id="temp.expl.spec">
      <h1>Explicit specialization</h1>

      Insert the following paragraphs after paragraph 12. These require
      an explicit specialization to satisfy the constraints of the primary
      template.

      <p number="12" class="quoted">
      The <cxx-grammarterm>template-arguments</cxx-grammarterm> in the
      <cxx-grammarterm>template-id</cxx-grammarterm> of an explicit 
      specialization of a constrained class template or
      constrained variable template shall satisfy the associated constraints
      of that template (<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template&lt;&gt; S&lt;char&gt; { };    // <i>OK</i>
template&lt;&gt; S&lt;char[2]&gt; { }; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p class="quoted">
      An explicit specialization whose <cxx-grammarterm>template-name</cxx-grammarterm>
      names a set of overloaded function template refers to exactly one
      in that set.

      The function template referred to by an explicit specialization is the 
      same function template as an explicit instantiation
      with the same <cxx-grammarterm>template-name</cxx-grammarterm>
      <cxx-grammarterm>template-arguments</cxx-grammarterm>
      (<cxx-ref to="temp.explicit"></cxx-ref>).
      <cxx-note>
      An explicit specialization cannot refer to a constrained function
      template whose associated constraints are not satisfied
      (<cxx-ref to="temp.constr"></cxx-ref>).
      </cxx-note>

      <cxx-example class="inline">
      <cxx-codeblock>
template<C T>        void f(T); // <i>#1</i>
template<typename T> void g(T); // <i>#2</i>
template<C T>        void g(T); // <i>#3</i>

template&lt;&gt; void f(int);   // <i>OK: refers to #1</i>
template&lt;&gt; void f(void*); // <i>error: no matching template</i>
template&lt;&gt; void g(int);   // <i>OK: refers to #3</i>
template&lt;&gt; void g(void*); // <i>OK: refers to #2</i></cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.expl.spec -->
  </cxx-section> <!-- temp.spec -->


  <!-- =================================
       Function template specializations
       ================================= -->

  <cxx-section id="temp.fct.spec" number="8">
    <h1>Function template specializations</h1>

    <cxx-section id="temp.deduct" number="2">
      <h1>Template argument deduction</h1>

      Add the following sentences to the end of paragraph 5. This defines
      the substitution of template arguments into a function template's
      associated constraints. Note that the last part of paragraph 5
      has been duplicated in order to provide context for the addition.

      <p number="5" class="quoted">
      When all template arguments have been deduced or obtained from default 
      template arguments, all uses of template parameters in the template 
      parameter list of the template and the function type are replaced with
      the corresponding deduced or default argument values. 

      If the substitution results in an invalid type, as described above, type 
      deduction fails.

      <ins>
      Additionally, if the function template has associated constraints
      (<cxx-ref to="temp"></cxx-ref>),
      substitute the template arguments into the constraints without evaluating
      the result. If this substitution results in an invalid type, then
      the resulting expression is defined to be <code>false</code>.

      The resulting constraints are associated with the function template
      specialization.

      <cxx-note>
      The constraints associated with the function template specialization
      are evaluated in order to determine if the specialization is a viable
      candidate (<cxx-ref to="over.match.viable"></cxx-ref>).
      </cxx-note>
      </ins>
      </p>
    </cxx-section> <!-- tmp.fct.spec -->
  </cxx-section> <!-- tmp.deduct -->


  <!-- ===================
       Template constraints
       ==================== -->

  Add the following section after 14.8. This section defines
  <cxx-grammarterm>constraint-expression</cxx-grammarterm>s, their
  normalization and composition, the equivalence of constraints,
  and their partial ordering.

  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    <p>Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called <dfn>constraint</dfn>s.
    <bnf-grammar>
      <bnf-rule>constraint-expression</bnf-rule>
        <bnf-alt>logical-or-expression</bnf-alt>
    </bnf-grammar>
    </p>

    <p>A <cxx-grammarterm>logical-or-expression</cxx-grammarterm> is a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> if it can
    be normalized. A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
    <code>E</code> is <dfn>normalized</dfn> by forming a new expression from 
    <code>E</code> and its subexpressions so that the resulting expression is
    composed only of the combination of atomic constraints (defined below) by 
    the logical operators <code>&amp;&amp;</code> and <code>||</code>.
    <ul> 
    
    <li> The normalization of an expression of the form <code>(P)</code> is
    the expression <code>(P')</code> where <code>P'</code> is the normalization 
    of <code>P</code>.</li>

    <li> The normalization of an expression of the form <code>P || Q</code> is
    the expression <code>P' || Q'</code> where <code>P'</code> is the
    normalization of <code>P</code>, and <code>Q'</code> is the normalization
    of <code>Q</code>. In the resulting expression, if the lookup of
    <code>operator||</code> finds a user-defined function, the program is
    ill-formed. The resulting expression is a prvalue constant
    expression with type <code>bool</code>.</li>

    <li> The normalization of an expression of the form <code>P &amp;&amp; Q</code> is
    the expression <code>P' &amp;&amp; Q'</code> where <code>P'</code> is the
    normalization of <code>P</code>, and <code>Q'</code> is the normalization
    of <code>Q</code>. In the resulting expression, if the lookup of
    <code>operator&amp;&amp;</code> finds a user-defined function, the program is
    ill-formed. The resulting expression is a prvalue constant
    expression with type <code>bool</code>.</li>

    <li> The normalization of a function call of the form
    <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;()</code>
    where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
    is a sequence of template arguments and <code>C</code> names a function
    concept (<cxx-ref to="dcl.spec.concept"></cxx-ref>) is defined as follows:

    Let <code>E</code> be the expression returned by the function concept 
    <code>C</code>, and let <code>S</code> be the result of substituting the
    template arguments into that expression. The resulting expression is
    the normalization of <code>S</code>.</li>

    <li> The normalization of a <cxx-grammarterm>id-expression</cxx-grammarterm>
    of the form <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;</code>
    where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
    is a sequence of template arguments and <code>C</code> names a variable
    concept (<cxx-ref to="dcl.spec.concept"></cxx-ref>) is defined as follows:

    Let <code>E</code> be the initializer of the variable concept
    <code>C</code>, and let <code>S</code> be the result of substituting the
    template arguments into that expression. The resulting expression is
    the normalization of <code>S</code>.</li>

    <li> The normalization of a 
    <cxx-grammarterm>requires-expression</cxx-grammarterm> is an 
    expression <code>E</code> defined to be the conjunction of requirements
    introduced by the body of that expression 
    (<cxx-ref to="expr.prim.req"></cxx-ref>).
    <cxx-note>
    Subexpressions of <code>E</code> may include the atomic constraints
    defined in <cxx-ref to="temp.constr.atomc"></cxx-ref>.
    </cxx-note>
    </li>

    <li> Otherwise, the expression is an <dfn>atomic constraint</dfn>,
    and is a prvalue constant expression with type <code>bool</code>.
    </li>
    </ul>

    A program that includes an expression not having these properties
    in a context where a <cxx-grammarterm>constraint-expression</cxx-grammarterm>
    is required is ill-formed.

    <cxx-note>
    A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be deduced during translation.

    The prohibition against user-defined logical operators in intended to
    prevent the subversion of the underlying logic necessary partially
    order constraints (<cxx-ref to="temp.constr.order"></cxx-ref>).
    </cxx-note>

    <p>
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C1() { return sizeof(T) == 1; }
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt;() &amp;&amp; 1 == 2; }
template&lt;typenaem T&gt; concept bool C3 = requires (T t) { t.f(); };
template&lt;typenaem T&gt; concept bool C4 = requires () { typename T::type; };
template&lt;typename T&gt; concept bool C5 = requires (T t) { t.f() -> int; }

// <i>Constraint</i>      // <i>Normalization</i>
C1&lt;int&gt;            sizeof(int) == 1
C2&lt;char&gt;           sizeof(char) == 1 &amp;&amp; 1 == 2
C2&lt;bool&gt; || true   sizeof(bool) == 1 &amp;&amp; 1 == 2 || true
C3&lt;int&gt;            /* <i>valid-expression for</i> t.f() */
C4&lt;int&gt;            /* <i>valid-type for</i> int::type */
C3&lt;int&gt; &amp;&amp; C4&lt;int&gt; /* <i>valid-expression for</i> t.f() */ &amp;&amp; /* <i>valid-type for</i> int::type */
C5&lt;int&gt;            /* <i>valid-expression for</i> t.f() */ &amp;&amp; /* t.f() <i>convertible to</i> int */
3 + 4              // <i>error: not a constraint</i>
    </cxx-codeblock>
    In the normalized constraints, the expressions <code>sizeof(int)==1</code>, 
    <code>sizeof(char)==1</code>, <code>sizeof(bool)==1</code>, 
    <code>1==2</code>, and <code>true</code> are atomic constraints.
    Because C++ does not provide a means of spelling the atomic constraints
    introduced by a <cxx-grammarterm>requires-expression</cxx-grammarterm>,
    they are written in comments. In each of these, the <code>t</code> in
    the expression <code>t.f()</code> is a value of type <code>int</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
struct Fool { bool value; };
Fool operator&amp;&amp;(Fool a, Fool b) { return a.value || b.value; }
Fool operator||(Fool a, Fool b) { return a.value &amp;&amp; b.value; }

template&lt;typename T&gt;
  requires Fool{true} &amp;&amp; Fool{true} // <i>error: user-define operator&amp;&amp;</i>
void f(T);
    </cxx-codeblock>
    </cxx-example>
    </p>

    <!-- =======================
         Constraint satisfaction
         ======================= -->

    <cxx-section id="temp.constr.sat">
      <h1>Constraint satisfaction</h1>
    
      <p> At certain points during processing, it is necessary to determine
      if a set of template arguments satisfy a template's associated
      constraints. These are: 
      determining if a <cxx-grammarterm>template-id</cxx-grammarterm>
      refers to a type,
      taking the address of an overloaded function 
      (<cxx-ref to="over.over"></cxx-ref>),
      matching a class template partial specialization 
      (<cxx-ref to="temp.class.spec.match"></cxx-ref>), and
      in the declaration of an explicit instantiation
      (<cxx-ref to="temp.explicit"></cxx-ref>) 
      or specialization 
      (<cxx-ref to="temp.expl.spec"></cxx-ref>).</p>

      <p> To determine if a set of template arguments satisfies a
      template's associated constraints, the template arguments are 
      substituted into the normalized associated constraints and
      evaluated.

      If the substitution fails, the resulting evaluation is defined
      to be <code>false</code>.

      A template's associated constraints are satisfied only when
      the result of this evaluation is <code>true</code>.
      </p>

      <p> In the context of overload resolution, a candidate's 
      associated constraints are substituted before determining
      if the candidate is viable (<cxx-ref to="over.match.viable"></cxx-ref>).
      For function templates, this substitution happens during template 
      argument deduction
      (<cxx-ref to="temp.deduct"></cxx-ref>); 
      for constrained member functions of a class template, this happens
      during class template instantiation
      (<cxx-ref to="temp.inst"></cxx-ref>). In these cases, no
      further substitution is required to determine if the constraints
      are satisfied: they are satisfied if and only if the evaluation
      of the normalized constraints is <code>true</code>.
      </p>
    </cxx-section> <!-- temp.constr.sat -->


    <cxx-section id="temp.constr.atom">
      <h1>Atomic constraints</h1>

      <p> Several kinds of atomic constraints are not directly expressible
      as expressions in C++. The atomic constraints introduced by a
      <cxx-grammarterm>requires-expression</cxx-grammarterm> are such
      constraints. Those atomic constraints are defined in the following
      paragraphs. </p>

      <p> A <dfn>valid expression constraint</dfn> is a requirement on an
      expression, <code>E</code>. The constraint is satisfied if and only if 
      the substitution of template arguments into <code>E</code> does not 
      result in substitution failure. </p>

      <p> A <dfn>valid type constraint</dfn> is a requirement on a type
      <code>T</code>. The constraint is satisfied if and only if the 
      substitution of template arguments into <code>T</code> does not result in 
      substitution failure.</p>

      <p> A <dfn>result type constraint</dfn> is a predicate on the result type
      of a valid expression. Let <code>E</code> be a valid expression and 
      <code>X</code> be a <cxx-grammarterm>trailing-return-type</cxx-grammarterm>.

      The constraint is satisfied if and only if <code>E</code> can be used as an 
      argument to an invented function <code>f</code>, which has a single function
      parameter of type <code>X</code> and returning <code>void</code>. That is,
      the function call <code>f(E)</code> must be a valid expression.
      
      <cxx-note>
      Each template parameter referred to by <code>X</code> is a template
      parameter of the invented function <code>f</code>. If <code>X</code>
      contains a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      or <code>auto</code> specifier, then <code>f</code> is a generic function
      (<cxx-ref to ="dcl.fct"></cxx-ref>).
      </cxx-note>
      </p>

      <p> A <dfn>constant expression constraint</dfn> is satisfied if and only
      if a valid expression <code>E</code> is a constant expression 
      (<cxx-ref in="cxx" to="expr.const"></cxx-ref>).
      </p>

      <p> An <dfn>exception constraint</dfn> is satisfied if and only if, for
      a valid expression <code>E</code>, the expression <code>noexcept(E)</code>
      evaluates to <code>true</code>
      (<cxx-ref in="cxx" to="expr.unary.noexcept"></cxx-ref>).
      </p>
    </cxx-section> <!-- temp.constr.atom -->


    <cxx-section id="temp.constr.eq">
      <h1>Equivalence of constraints</h1>

      <p> Two <cxx-grammarterm>constraint-expression</cxx-grammarterm>s are 
      considered equivalent if two function definitions containing the 
      expressions would satisfy the one definition rule 
      (<cxx-ref to="basic.def.odr"></cxx-ref>), except that 
      the tokens used to name template parameters may differ as long as a 
      token used to name a template parameter in one expression is replaced by 
      another token that names the same template parameter in the other 
      expression, and
      the tokens used to name names of other entities may differ only if 
      those names refer to the same set of declarations.
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;typename T&gt; requires C&lt;T&gt; void f(); // <i>#1</i>
template&lt;typename U&gt; requires C&lt;U&gt; void f(); // <i>OK: redeclaration of #1</i>

namespace N1 { template&lt;typename T&gt; concept bool C1 = true; }
namespace N2 { template&lt;typename T&gt; concept bool C2 = true; }

template&lt;typename T&gt; requires N1::C1&lt;T&gt; void g(); // #2
template&lt;typename T&gt; requires N1::C1&lt;T&gt; void h(); // #3
using N1::C1;
template&lt;typename T&gt; requires C1&lt;T&gt; void g();     // <i>OK: redeclaration of #2</i>
using namespace N2;
template&lt;typename T&gt; requires C2&lt;T&gt; void h();     // <i>OK: redeclaration of #3</i>
      </cxx-codeblock>
      </cxx-example>

      Two <cxx-grammarterm>constraint-expressions</cxx-grammarterm> that are not 
      equivalent are functionally equivalent if, for any given set of template 
      arguments, the evaluation of the expression results in the same value.

      A <cxx-grammarterm>constraint-expression</cxx-grammarterm> or
      subexpression thereof of the form <code>(E)</code> is not equivalent
      to the same expression or subexpression <code>E</code>, but the two
      expressions are functionally equivalent. </p>
      <cxx-example class="inline">
      <cxx-codeblock>
void f() requires true || 1 == 2;   // <i>#1</i>
void f() requires true || (1 == 2); // <i>not equivalent but functionally equivalent</i>
      </cxx-codeblock>
      </cxx-example>
    </cxx-section> <!-- temp.constr.eq -->


    <cxx-section id="temp.constr.order">
      <h1>Partial ordering of constraints</h1>
    
      <p>
      For a mapping <i>M</i> from a set <i>X</i> of atomic 
      constraints to boolean values, let <i>G(M)</i> be the mapping 
      from constraints to boolean values such that <i>G(M)(C)</i> is 
      the result of substituting each atomic constraint A within 
      <i>C</i> for <i>M(A)</i>.

      For two constraints <code>P</code> and <code>Q</code>, let 
      <i>X</i> be the set of all atomic constraints that
      appear in <code>P</code> and <code>Q</code>.

      <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
      every mapping <i>M</i> from members of <i>X</i> to boolean 
      values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
      are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
      true (or both).
      </p>

    </cxx-section> <!-- temp.cosntr.order -->

  </cxx-section> <!-- temp.constr -->

</cxx-clause> <!-- temp -->


