<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/concepts-ts -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-NOTE");document.createElement("CXX-GRAMMARTERM");document.createElement("BNF-GRAMMAR");document.createElement("BNF-RULE");document.createElement("BNF-ALT");document.createElement("CXX-GRAMMARTER");document.createElement("CXX-EXAMPLE");document.createElement("CXX-CODEBLOCK");document.createElement("BNF-TERMINAL");document.createElement("BNF-OPT");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}core-xhr {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

@media print {
cxx-titlepage {
	height: 8.8in;
}


}

cxx-titlepage  {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}</style>
  <meta charset="utf-8">
  
  
  <style>
del.local {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}
del.local > * {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}

ins.local {
  color: Black;
  text-decoration: underline;
  background-color: LightSteelBlue; 
}
ins.local > * {
  color: Black;
  text-decoration: under;
  background-color: LightSteelBlue; 
}

p.quoted {
  margin-left: .25in;
}
div.quoted {
  margin-left: .25in;
}
</style>
<style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 9pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 9pt; }
    @bottom-left { content: string(current-section, last); font-size: 9pt; }
    @bottom-right { content: counter(page); font-size: 9pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "© ISO 2014 — All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 9pt; text-align: justify; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {
        height: 100%;
        text-align: justify; 
    }
}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><title>C++ Extensions for Concepts, Working Draft</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tbody><tr><th>Document Number:</th><td><cxx-docnum>DXXX</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-07-30</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4040.pdf">N4040</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Andrew Sutton<br>
    University of Akron<br>
    <cxx-email><a href="mailto:asutton@uakron.edu">asutton@uakron.edu</a></cxx-email>
  </cxx-editor></td></tr>
      
    </tbody></table>
    <h1>Working Draft, C++ Extensions for Concepts</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#intro">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#intro.refs">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#intro.compliance">Implementation compliance</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#intro.ack">Acknowledgments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#lex">Lexical conventions</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#lex.key">Keywords</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#expr">Expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#expr.prim">Primary expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.2</span><a href="#expr.prim.lambda">Lambda expressions</a>
        
      </li>
            
              <li><span class="marker">5.1.3</span><a href="#expr.req">Requires expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.3.1</span><a href="#expr.req.simple">Simple requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.2</span><a href="#expr.req.type">Type requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.3</span><a href="#expr.req.nested">Nested requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.4</span><a href="#expr.req.compound">Compound requirements</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#dcl.dcl">Declarations</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#dcl.spec">Specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6</span><a href="#dcl.type">Type specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6.2</span><a href="#dcl.type.simple">Simple type specifiers</a>
        
      </li>
            
              <li><span class="marker">7.1.6.4</span><a href="#dcl.spec.auto">auto specifier</a>
        
      </li>
            
              <li><span class="marker">7.1.6.5</span><a href="#dcl.spec.constr">Constrained type specifiers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7.1.7</span><a href="#dcl.spec.concept">concept specifier</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#dcl.decl">Declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3</span><a href="#dcl.meaning">Meaning of declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3.5</span><a href="#dcl.fct">Functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.4</span><a href="#dcl.fct.def">Function definitions</a>
        
          <ol>
            
              <li><span class="marker">8.4.1</span><a href="#dcl.fct.def.general">In general</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">9</span><a href="#class">Classes</a>
        
          <ol>
            
              <li><span class="marker">9.2</span><a href="#class.mem">Class members</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">10</span><a href="#class.derived">Derived classes</a>
        
          <ol>
            
              <li><span class="marker">10.3</span><a href="#class.virtual">Virtual functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13</span><a href="#over">Overloading</a>
        
          <ol>
            
              <li><span class="marker">13.2</span><a href="#over.dcl">Declaration matching</a>
        
      </li>
            
              <li><span class="marker">13.3</span><a href="#over.match">Overload resolution</a>
        
          <ol>
            
              <li><span class="marker">13.3.1</span><a href="#over.match.viable">Viable functions</a>
        
      </li>
            
              <li><span class="marker">13.3.2</span><a href="#over.match.best">Best viable function</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13.4</span><a href="#over.over">Address of overloaded function</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14</span><a href="#temp">Templates</a>
        
          <ol>
            
              <li><span class="marker">14.1</span><a href="#temp.param">Template parameters</a>
        
      </li>
            
              <li><span class="marker">14.2</span><a href="#temp.names">Template names</a>
        
      </li>
            
              <li><span class="marker">14.3</span><a href="#temp.arg">Template arguments</a>
        
          <ol>
            
              <li><span class="marker">14.3.1</span><a href="#temp.arg.template">Template template arguments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5</span><a href="#temp.decls">Template declarations</a>
        
          <ol>
            
              <li><span class="marker">14.5.1</span><a href="#temp.class">Class templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.1.1</span><a href="#temp.mem.func">Member functions of class templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.2</span><a href="#temp.mem">Member templates</a>
        
      </li>
            
              <li><span class="marker">14.5.4</span><a href="#temp.friend">Friends</a>
        
      </li>
            
              <li><span class="marker">14.5.5</span><a href="#temp.class.spec">Class template partial specialization</a>
        
          <ol>
            
              <li><span class="marker">14.5.5.1</span><a href="#temp.class.spec.match">Matching of class template partial specializations</a>
        
      </li>
            
              <li><span class="marker">14.5.5.2</span><a href="#temp.class.order">Partial ordering of class template specializations</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.6</span><a href="#temp.fct">Function templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.6.1</span><a href="#temp.over.link">Function template overloading</a>
        
      </li>
            
              <li><span class="marker">14.5.6.2</span><a href="#temp.func.order">Partial ordering of function templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.7</span><a href="#temp.alias">Alias templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.7</span><a href="#temp.spec">Template instantiation and specialization</a>
        
          <ol>
            
              <li><span class="marker">14.7.1</span><a href="#temp.inst">Implicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.2</span><a href="#temp.explicit">Explicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.3</span><a href="#temp.expl.spec">Explicit specialization</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.8</span><a href="#temp.constr">Template constraints</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>


<cxx-clause id="intro">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#intro">[intro]</a></span></header>
      
  

  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++ 
    Programming language (<cxx-ref to="intro.refs"><a title="intro.refs" href="#intro.refs">1.2</a></cxx-ref>) that
    enable the specification and checking of constraints on template 
    arguments, and the ability to overload functions and specialize
    templates based on those constraints. These extensions include 
    new syntactic forms and modifications to existing language semantics.</p>

    <p para_num="2" id="general.scope.2">International Standard, ISO/IEC 14882, provides important context
    and specification for this Technical Specification. This document as 
    written as a set of changes against that specification. Instructions
    to modify or add paragraphs are written as explicit instructions. 
    Modifications made directly to existing text from the International
    Standard use <ins>underlining</ins> to represent added text and
    <del>strikethrough</del> to represent deleted text.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.refs">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#intro.refs">[intro.refs]</a></span></header>
      
    

    <p para_num="1" id="intro.refs.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>
    <ul>
      <li>ISO/IEC 14882:2014, <cite>Programming Languages - C++</cite>
      </li>
    </ul>

    <p para_num="2" id="intro.refs.2">ISO/IEC 14882:2014 is herein after called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++
    §3.2".</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.compliance">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Implementation compliance">Implementation compliance</h1> <span style="float:right"><a href="#intro.compliance">[intro.compliance]</a></span></header>
      
    
    <p para_num="1" id="intro.compliance.1">Conformance requirements for this specification are the same as those 
    defined in <cxx-ref in="cxx" to="intro.compliance">C++ <span title="intro.compliance">§1.4</span></cxx-ref>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Conformance is defined in terms of the behavior of
    programs.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.ack">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Acknowledgments">Acknowledgments</h1> <span style="float:right"><a href="#intro.ack">[intro.ack]</a></span></header>
      
    
  
    <p para_num="1" id="intro.ack.1">The design of this specification is based, in part, on a concept 
    specification of the algorithms part of the C++ standard library, known 
    as ``The Palo Alto" TR (WG21 N3351), which was developed by a large 
    group of experts as a test of the expressive power of the idea of 
    concepts. Despite syntactic differences between the notation of the 
    Palo Alto TR and this TS, the TR can be seen as a large-scale test of 
    the expressiveness of this TS.</p>

    <p para_num="2" id="intro.ack.2">This work was funded by NSF grant ACI-1148461.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>


<cxx-clause id="lex">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Lexical conventions">Lexical conventions</h1> <span style="float:right"><a href="#lex">[lex]</a></span></header>
      
  

  <cxx-section id="lex.key" <="" cxx-section="">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Keywords">Keywords</h1> <span style="float:right"><a href="#lex.key">[lex.key]</a></span></header>
      
    

    In <cxx-ref in="cxx" to="lex.key">C++ <span title="lex.key">§2.12</span></cxx-ref>, Table 4, add 
    the keywords <code>concept</code> and <code>requires</code>.

  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="expr" number="5">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Expressions">Expressions</h1> <span style="float:right"><a href="#expr">[expr]</a></span></header>
      
  

  <cxx-section id="expr.prim">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 Primary expressions">Primary expressions</h1> <span style="float:right"><a href="#expr.prim">[expr.prim]</a></span></header>
      
    

    <p para_num="1" id="expr.prim.1">In <cxx-ref in="cxx" to="expr.prim.general">C++ <span title="expr.prim.general">§5.1.1</span></cxx-ref>, add
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> to the
    rule, <cxx-grammarterm><i>primary-expression</i></cxx-grammarterm>.</p>
    
    <bnf-grammar>
    
    
      <bnf-rule>
    
    primary-expression:
  </bnf-rule>
        <ins><bnf-alt>
    
    requires-expression
  </bnf-alt></ins>
    
  </bnf-grammar>

    <cxx-section id="expr.prim.lambda" number="2">
    

    <section>
      <header><span class="section-number">5.1.2</span> <h1 data-bookmark-label="5.1.2 Lambda expressions">Lambda expressions</h1> <span style="float:right"><a href="#expr.prim.lambda">[expr.prim.lambda]</a></span></header>
      
      

      Insert the following paragraph after paragraph 4 to define the
      term "generic lambda". 

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      A <dfn>generic lambda</dfn> is a 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> where either the
      <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>)
      or a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>)
      appears in a parameter type of the
      <cxx-grammarterm><i>lambda-declarator</i></cxx-grammarterm>.
      </p>

      Modify paragraph 5 so that the meaning of a generic lambda is defined 
      in terms of its abbreviated member function call operator.

      <p para_num="6" id="expr.prim.lambda.6" number="6" class="quoted">
      The closure type for a non-generic
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> has a public inline 
      function call operator (<cxx-ref in="cxx" to="over.call">C++ <span title="over.call">§13.5.4</span></cxx-ref>)
      whose parameters and return type are described by the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> respectively. 

      <del>
      For a generic lambda, the closure type has a public inline function call
      operator member template (<cxx-ref to="temp.mem"><a title="temp.mem" href="#temp.mem">14.5.2</a></cxx-ref>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> consists of 
      one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      for each occurrence of <code>auto</code> in the lambda’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, in order 
      of appearance.

      The invented type <cxx-grammarter>template-parameter</cxx-grammarter> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration declares</i></cxx-grammarterm> a 
      function parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 

      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> by 
      replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
      with the name of the corresponding invented template-parameter.
      </del>

      <ins>
      For a generic lambda, the function call operator is an abbreviated
      member function, whose parameters and return type are derived according
      to the rules in <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>.
      </ins>
      </p>

      Add the following example after those in 
      <cxx-ref in="cxx" to="expr.prim.lambda">C++ <span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5. Note that
      the existing examples in the original document are omitted in this
      document.

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      <ins>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></ins></p><pre><code>template&lt;typename T&gt; concept bool C = true;

auto gl = [](C&amp; a, C* b) { a = *b }; // <i>OK: denotes a generic lambda</i>

struct Fun {
    auto operator()(C&amp; a, C* b) const { a = *b; }
} fun;</code></pre>
  
      <code>C</code> is a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>,
      signifying that the lambda is generic. The generic lambda, <code>gl</code>, 
      and the function object, <code>fun</code>, have equivalent behavior when 
      called with the same arguments.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      
      <p></p>

    
    </section>
  </cxx-section> <!-- expr.prim.lambda -->


  <cxx-section id="expr.req">
    

    <section>
      <header><span class="section-number">5.1.3</span> <h1 data-bookmark-label="5.1.3 Requires expressions">Requires expressions</h1> <span style="float:right"><a href="#expr.req">[expr.req]</a></span></header>
      
    

    <p para_num="1" id="expr.req.1">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    <bnf-grammar>
    
    
      <bnf-rule>
    
    requires-expression:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> 
          requirement-parameter-list requirement-body
  </bnf-alt>

    <bnf-rule>
    
    requirement-parameter-list:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>(</code></bnf-terminal> 
        <bnf-opt>parameter-declaration-clause<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>)</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-body:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>{</code></bnf-terminal> 
        requirement-list 
        <bnf-terminal><code>}</code></bnf-terminal> 
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-list:
  </bnf-rule>
      <bnf-alt>
    
    requirement
  </bnf-alt>
      <bnf-alt>
    
    requirement-list requirement
  </bnf-alt>

    <bnf-rule>
    
    requirement:
  </bnf-rule>
      <bnf-alt>
    
    simple-requirement
  </bnf-alt>
      <bnf-alt>
    
    compound-requirement
  </bnf-alt>
      <bnf-alt>
    
    type-requirement
  </bnf-alt>
      <bnf-alt>
    
    nested-requirement
  </bnf-alt>

    <bnf-rule>
    
    simple-requirement:
  </bnf-rule>
      <bnf-alt>
    
    expression <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>

    <bnf-rule>
    
    compound-requirement:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-opt><bnf-terminal><code>constexpr</code></bnf-terminal><sub>opt</sub></bnf-opt>
        <bnf-terminal><code>{</code></bnf-terminal> expression <bnf-terminal><code>}</code></bnf-terminal>
        <bnf-opt><bnf-terminal><code>noexcept</code></bnf-terminal><sub>opt</sub></bnf-opt>
        <bnf-opt>trailing-return-type<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>;</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    type-requirement:
  </bnf-rule>
      <bnf-alt>
    
    
        typename-specifier <bnf-terminal><code>;</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    nested-requirement:
  </bnf-rule>
      <bnf-alt>
    
    requires-clause <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
    
  </bnf-grammar>
    </p>

    <p para_num="2" id="expr.req.2">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> has type
    <code>bool</code>. </p>

    <p para_num="3" id="expr.req.3">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> shall not appear
    outside of a concept definition (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept"></a></cxx-ref>) or a
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>. </p>

    <p para_num="4" id="expr.req.4">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    The most common use of 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s is to define
    syntactic requirements in concepts (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept"></a></cxx-ref>) 
    such as the one below:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -&gt; const A&lt;T&gt;&amp;;
    };
  }</code></pre>
  
    The concept is defined in terms of the syntactic and type requirements 
    within the <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
    
    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> can also be
    used in a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> templates 
    as a way of writing ad hoc constraints on template arguments such as 
    the one below:
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="5" id="expr.req.5">The <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> may introduce
    local arguments via a <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>. 
    These parameters have no linkage, storage, or lifetime.
    They are used only to write constraints within the
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> and are not visible
    outside the closing <code>}</code> of the 
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm>. 
    The <cxx-grammarterm><i>requirement-parameter-list</i></cxx-grammarterm> shall
    not include an ellipsis.</p>

    <p para_num="6" id="expr.req.6">The <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> is a sequence of
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s separated by semicolons.
     These <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s may refer to local 
    arguments, template parameters, and any other declarations visible from the 
    enclosing context. Each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> 
    introduces a conjunction of one or more atomic constraints 
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>). The kinds of atomic constraints
    introduced by a <cxx-grammarterm><i>requirement</i></cxx-grammarterm> are:
    </p><ul>
    <li>A <dfn>valid expression constraint</dfn> is a predicate on an
    expression. The constraint is satisfied if and only if the substitution of 
    template arguments into that expression does not result in substitution 
    failure. The result of successfully substituting template arguments
    into the dependent expression produces a <dfn>valid expression</dfn>.</li>

    <li>A <dfn>valid type constraint</dfn> is a predicate on a type.
    The constraint is satisfied if and only if the substitution of template
    arguments into that type does not result in substitution failure. The
    result of successfully substituting template arguments into the dependent
    type produces an <dfn>associated type</dfn>.</li>

    <li>A <dfn>result type constraint</dfn> is a predicate on the result type
    of a valid expression. Let <code>E</code> be a valid expression and 
    <code>X</code> be a <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>.

    The constraint is satisfied if and only if <code>E</code> can be used as an 
    argument to an invented function <code>f</code>, which has a single function
    parameter of type <code>X</code> and returning <code>void</code>. That is,
    the function call <code>f(E)</code> must be a valid expression.
    
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Each template parameter referred to by <code>X</code> is a template
    parameter of the invented function <code>f</code>. If <code>X</code>
    contains a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
    or <code>auto</code> specifier, then <code>f</code> is a generic function
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </li>

    <li>A <dfn>constant expression constraint</dfn> is satisfied if and only
    if a valid expression <code>E</code> is a constant expression 
    (<cxx-ref in="cxx" to="expr.const">C++ <span title="expr.const">§5.19</span></cxx-ref>).
    </li>

    <li>An <dfn>exception constraint</dfn> is satisfied if and only if, for
    a valid expression <code>E</code>, the expression <code>noexcept(E)</code>
    evaluates to <code>true</code>
    (<cxx-ref in="cxx" to="expr.unary.noexcept">C++ <span title="expr.unary.noexcept">§5.3.7</span></cxx-ref>).
    </li>
    </ul>
    <!-- </p> -->

    <p para_num="7" id="expr.req.7">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> evaluates to
    <code>true</code> if and only the atomic constraints introduced by
    each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> in the 
    <cxx-grammarterm><i>requirement-list</i></cxx-grammarterm> are satisfied
    and <code>false</code> otherwise. The semantics of each kind of 
    requirement are described in the following sections.</p>

    <cxx-section id="expr.req.simple">
    

    <section>
      <header><span class="section-number">5.1.3.1</span> <h1 data-bookmark-label="5.1.3.1 Simple requirements">Simple requirements</h1> <span style="float:right"><a href="#expr.req.simple">[expr.req.simple]</a></span></header>
      
      
      <p para_num="1" id="expr.req.simple.1">A <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> introduces a
      valid expression constraint for its 
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>. The expression is an
      unevaluated operand (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      The following requirement evaluates to <code>true</code> for all
      arithmetic types (<cxx-ref in="cxx" to="basic.fundamental">C++ <span title="basic.fundamental">§3.9.1</span></cxx-ref>),
      and <code>false</code> for pointer types 
      (<cxx-ref in="cxx" to="basic.compound">C++ <span title="basic.compound">§3.9.2</span></cxx-ref>).
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires (T a, T b) {
  a + b;  // A simple requirement
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.req.simple.2">If the expression would always result in a substitution failure, 
      the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  new T[-1];  // error: the valid expression will never be well-formed.
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.simple -->


    <cxx-section id="expr.req.type">
    

    <section>
      <header><span class="section-number">5.1.3.2</span> <h1 data-bookmark-label="5.1.3.2 Type requirements">Type requirements</h1> <span style="float:right"><a href="#expr.req.type">[expr.req.type]</a></span></header>
      
      
      <p para_num="1" id="expr.req.type.1">A <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> introduces 
      valid type constraint for its 
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm>.
      
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A type requirement requests the validity of an associated
      type, either as a nested type name, a class template specialization,
      or an alias template. It is not used to specify requirements for
      arbitrary <cxx-grammarterm><i>type-specifiers</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename T::inner;         // Required nested type name
  typename Related&lt;T&gt;; // Required alias
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.req.type.2">If the required type will always result in a substitution failure,
      then the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename int::X;  // error: int does not have class type
  typename T[-1];   // error: array types cannot have negative extent
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.type -->


    <cxx-section id="expr.req.nested">
    

    <section>
      <header><span class="section-number">5.1.3.3</span> <h1 data-bookmark-label="5.1.3.3 Nested requirements">Nested requirements</h1> <span style="float:right"><a href="#expr.req.nested">[expr.req.nested]</a></span></header>
      
      
      <p para_num="1" id="expr.req.nested.1">A <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> introduces
      an additional constraint expression <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref> 
      to be evaluated as part of the satisfaction of the 
      <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>. 
      The requirement is satisfied if and only if the constraint evaluates to
      value <code>true</code>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
     
      Nested requirements are generally used to provide additional constraints on 
      associated types
      within a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename X<t>;
  requires C&lt;X&lt;T&gt;&gt;();
}
      </t></code></pre>
  
      These requirements are satisfied only when substitution into 
      <code>X&lt;T&gt;</code> is successful and when 
      <code>C&lt;X&lt;T&gt;&gt;()</code> evaluates to <code>true</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.re.nested -->



    <!-- TODO: {e}->cv void is ill-formed.

         For two reasons. First, we can't actually form an invented
         function template that takes cv void as an argumnet (oops).
         Second, even if we could, no expression converts to void. -->

    <cxx-section id="expr.req.compound">
    

    <section>
      <header><span class="section-number">5.1.3.4</span> <h1 data-bookmark-label="5.1.3.4 Compound requirements">Compound requirements</h1> <span style="float:right"><a href="#expr.req.compound">[expr.req.compound]</a></span></header>
      
      
      <p para_num="1" id="expr.req.compound.1">A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces 
      a conjunction of one or more constraints pertaining to its
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>, depending on the syntax
      used. This set includes:
      </p><ul>
      <li>a valid expression constraint,</li>
      <li>an optional associated type constraint</li>
      <li>an optional result type constraint,</li>
      <li>an optional constant expression constraint, and </li>
      <li>an optional exception constraint.</li>
      </ul>
      A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> is
      satisfied if and only if every constraint in the set is satisfied.
      
      <!-- BUG: There is a core issue on this -->
      The required valid expression is an unevaluated operand
      (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>)
      except in the case when the <code>constexpr</code> specifier is present.
      These other requirements are described in the following paragraphs.
      <!-- </p> -->

      <p para_num="2" id="expr.req.compound.2">The brace-enclosed <cxx-grammarterm><i>expression</i></cxx-grammarterm> in
      a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces
      a valid expression constraint. Let <code>E</code> be the valid expression
      resulting from successful substitution.

      </p><p para_num="3" id="expr.req.compound.3">The presence of a
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> introduces 
      a result type constraint on <code>E</code>.</p>

      <p para_num="4" id="expr.req.compound.4">If the <code>constexpr</code> specifier is present then a constant 
      expression constraint is introduced for the valid expression 
      <code>E</code>.</p>

      <p para_num="5" id="expr.req.compound.5">If the <code>noexcept</code> specifier is present, then an
      exception constraint is introduced for the valid expression
      <code>E</code>.</p>

      <p para_num="6" id="expr.req.compound.6">
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename I&gt;
  concept bool Inscrutable() { ... }

requires(T x) {
  {x++}; #1
  {*x} -&gt; typename T::r; #2
  {f(x)} -&gt; const Inscrutable&amp;; #3
  {g(x)} noexcept -&gt; auto&amp;; #4
  constexpr {T::value}; #5
  constexpr {T() + T()} -&gt; T; #6;
}</code></pre>
  
      Each of these requirements introduces a valid expression constraint
      on the expression in its enclosing braces.

      Requirement #1 introduces no additional constraints. It is equivalent to 
      a <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> containing the 
      same expression.
      
      Requirement #2 <code>*x</code> introduces a result type constraint
      through its <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
      <code>typename T::r</code>. The required valid expression <code>*x</code> 
      must be usable as an argument to the invented function:
      <cxx-codeblock>
    
    <pre><code>template&lt;class T&gt; 
  void z1(typename T::r);</code></pre>
  </cxx-codeblock>

      Requirement #3 also introduces a result type constraint on its required
      valid expression <code>f(x)</code>. This expression must be usable as
      an argument to the invented generic function:
      <cxx-codeblock>
    
    <pre><code>void z2(const Inscrutable&amp;)</code></pre>
  </cxx-codeblock>
      
      Requirement #4 introduces a result type constraint and an exception 
      constraint. The required valid expression <code>g(x)</code> must
      be usable as as an argument to the invented generic function:
      <cxx-codeblock>
    
    <pre><code>void z3(auto&amp;);</code></pre>
  </cxx-codeblock>
      Additionally, <code>g(x)</code> must not propagate exceptions.

      Requirement #5 introduces a constant expression constraint:
      <code>T::value</code> must be a constant expression. 

      The requirement in #6 introduces a result type constraint and a constant 
      expression constraint. The required valid expression 
      <code>T() + T()</code> must be usable as an argument to the invented 
      function:
      <cxx-codeblock>
    
    <pre><code>template&lt;class T&gt;
  void z4(T);</code></pre>
  </cxx-codeblock>
      The valid expression must also be a constant expression.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.compound -->
 
  
    </section>
  </cxx-section> <!-- expr.req -->

    </section>
  </cxx-section>
    </section>
  </cxx-clause> <!-- expr -->

<cxx-clause id="dcl.dcl" number="7">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 Declarations">Declarations</h1> <span style="float:right"><a href="#dcl.dcl">[dcl.dcl]</a></span></header>
      
  

  <cxx-section id="dcl.spec">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Specifiers">Specifiers</h1> <span style="float:right"><a href="#dcl.spec">[dcl.spec]</a></span></header>
      
    

    Extend the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p para_num="1" id="dcl.spec.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    decl-specifier:
  </bnf-rule>
        <ins><bnf-alt>
    
    <bnf-terminal><code>concept</code></bnf-terminal>
  </bnf-alt></ins>
    
  </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
    

    <section>
      <header><span class="section-number">7.1.6</span> <h1 data-bookmark-label="7.1.6 Type specifiers">Type specifiers</h1> <span style="float:right"><a href="#dcl.type">[dcl.type]</a></span></header>
      
      

      <cxx-section id="dcl.type.simple" number="2">
    

    <section>
      <header><span class="section-number">7.1.6.2</span> <h1 data-bookmark-label="7.1.6.2 Simple type specifiers">Simple type specifiers</h1> <span style="float:right"><a href="#dcl.type.simple">[dcl.type.simple]</a></span></header>
      
        
        
        Add <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        to the grammar for <cxx-grammarterm><i>simple-type-specifier</i></cxx-grammarterm>s.

        <p para_num="1" id="dcl.type.simple.1" class="quoted">
        <bnf-grammar>
    
    
          <bnf-rule>
    
    simple-type-specifier:
  </bnf-rule>
            <ins><bnf-alt>
    
    constrained-type-specifier
  </bnf-alt></ins>
        
  </bnf-grammar>
        </p>
      
    </section>
  </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
    

    <section>
      <header><span class="section-number">7.1.6.4</span> <h1 data-bookmark-label="7.1.6.4 auto specifier"><code>auto</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.auto">[dcl.spec.auto]</a></span></header>
      
        

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/1 as
        follows:

        <p para_num="1" id="dcl.spec.auto.1" number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The use of the <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> in a non-deduced 
        context (<cxx-ref in="c++" to="temp.deduct.type"></cxx-ref>) will cause the 
        deduction of a value for that placeholder type to fail, resulting
        in an ill-formed program.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <ins class"local"="">
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></ins></p><pre><code>struct N {
  template&lt;typename T&gt; struct Wrap;
  template&lt;typename T&gt; static Wrap<t> make_wrap(T);
};
template&lt;typename T, typename U&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

template&lt;int N&gt; struct Size { void f(int) { }  };
Size&lt;0&gt; s;
bool g(char, double);

void (auto::*)(auto) p = &amp;Size&lt;0&gt;::f;   // <i>OK</i>
N::Wrap&lt;auto&gt; a = N::make_wrap(0.0);    // <i>OK</i>
Pair&lt;auto, auto&gt; p = make_pair(0, 'a'); // <i>OK</i>
auto::Wrap&lt;int&gt; x = N::make_wrap(0);    // <i>error: failed to deduce value for</i> auto
Size&lt;sizeof(auto)&gt; y = s;               // <i>error: failed to deduce value for</i> auto
        </t></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/2 to read:

        <p para_num="2" id="dcl.spec.auto.2" number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, 
        <cxx-grammarterm><i>type-specifier-seq</i></cxx-grammarterm>,
        <cxx-grammarterm><i>conversion-function-id</i></cxx-grammarterm>, or
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
        in any context where such a declarator is valid. 

        If the function declarator includes a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
        that specifies the declared return type of the function.

        The <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        can also appear in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> of a
        function declarator.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/3 as follows:

        <p para_num="3" id="dcl.spec.auto.3" number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s
        in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
        <ins>in a parameter type</ins> 
        of a
        <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>, the lambda is
        a generic lambda (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears in a parameter type of a function declarator, that is an 
        abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>void f(const auto&amp;, int); // <i>OK: an abbreviated function</i></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </ins>
        <p></p>

        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/3.

        <p para_num="4" id="dcl.spec.auto.4" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> 
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in
        a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>, that
        return type introduces a deduction constraint
        (<cxx-ref to="expr.req.compound"><a title="expr.req.compound" href="#expr.req.compound">5.1.3.4</a></cxx-ref>).
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -&gt; const auto&amp;; // <i>OK</i>
  };
}</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <p></p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/4. The examples
        in the original text are unchanged and therefore omitted.

        <p para_num="4" id="dcl.spec.auto.4" number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block">C++ <span title="stmt.block">§6.3</span></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace">C++ <span title="basic.scope.namespace">§3.3.6</span></cxx-ref>), and 
        in a <cxx-grammarterm><i>for-init-statement</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for">C++ <span title="stmt.for">§6.5.3</span></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
    
    </cxx-codeblock></p><pre><code>( <i>expression-list</i> )</code></pre>
  
        the <cxx-grammarterm><i>expression-list</i></cxx-grammarterm> shall be a 
        single <cxx-grammarterm><i>assignment-expression</i></cxx-grammarterm>.
        <p></p>


        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/7.

        <p para_num="5" id="dcl.spec.auto.5" class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list">C++ <span title="dcl.init.list">§8.5.4</span></cxx-ref>), the program is 
        ill-formed. 

        <del>
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing the 
        occurrences of <code>auto</code> with either a new invented type 
        template parameter <code>U</code> or, if the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>, with 
        <code>std::initializer_list&lt;U&gt;</code>.
        </del>

        <ins>
        Otherwise, obtain <code>P</code> from <code>T</code> as follows:
        </ins></p><ul>
        <li> replace each occurrence of <code>auto</code> in the variable type 
        with a new invented type template parameter, or </li>

        <li> when the initializer is a <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>
        and <code>auto</code> is a <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>
        of the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        the variable declaration, replace that occurrence of <code>auto</code> 
        with <code>std::initializer_list&lt;U&gt;</code>
        where <code>U</code> is an invented template type parameter.</li>
        </ul>
        

<!--        
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing 
        <del>the occurrences</del>
        <ins>each occurrence</ins>
        of <code>auto</code> with <del>either</del> a new invented type
        template parameter <del><code>U</code></del> or, 

        if the initializer is a <cxx-grammarterm>braced-init-list</cxx-grammarterm>
        <ins>and <code>auto</code> is a <cxx-grammarterm>decl-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        the variable declaration, replace that single occurrence of
        <code>auto</code></ins><del>,</del> with <code>std::initializer_list&lt;U&gt;</code>
        <ins>where <code>U</code> is an invented template type parameter</ins>.
 -->

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call">C++ <span title="temp.deduct.call">§14.8.2.1</span></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code><ins>template&lt;typename T&gt; struct Vec { };
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;) { return Vec&lt;T&gt;{}; } </ins>

auto x1 = { 1, 2 };                 // <ins><i>OK:</i></ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = *x1.begin();             // <i>OK:</i> decltype(x3) <i>is</i> int&amp;
const auto* p = &amp;x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltype(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3};           // <i>error: cannot deduce element type</i></ins></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>const auto<ins>&amp;</ins><del> &amp;</del>i = expr;</code></pre>
  </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
    
    <pre><code>template &lt;class U&gt; void f(const U&amp; u);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
    
    <pre><code>template&lt;typename F, typename S&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

struct S { void mfn(bool); } s;
int fn(char, double);

Pair&lt;auto (*)(auto, auto), auto (auto::*)(auto)&gt; p = make_pair(fn, &amp;S::mfn);</code></pre>
  </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(make_pair(fn, &amp;S::mfn))</code> of the following invented function 
template:
        <cxx-codeblock>
    
    <pre><code>template&lt;class T1, class T2, class T2, class T3, class T4, class T5, class T6&gt; 
  void g(Pair&lt; T1(*)(T2, T3), T4 (T5::*)(T6));</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        <!-- </p> -->
      
    </section>
  </cxx-section> <!-- dcl.spec.auto -->


      <cxx-section id="dcl.spec.constr">
    

    <section>
      <header><span class="section-number">7.1.6.5</span> <h1 data-bookmark-label="7.1.6.5 Constrained type specifiers">Constrained type specifiers</h1> <span style="float:right"><a href="#dcl.spec.constr">[dcl.spec.constr]</a></span></header>
      
        

        Add this section to <cxx-ref in="cxx" to="dcl.type">C++ <span title="dcl.type">§7.1.6</span></cxx-ref>.

        <p para_num="1" id="dcl.spec.constr.1"> Like the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>),
        a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        designates a placeholder that will be replaced later by deduction
        from the <cxx-grammarterm><i>expression</i></cxx-grammarterm> in a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> or a
        function argument. 

        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s have
        the form

        <bnf-grammar>
    
    
          <bnf-rule>
    
    constrained-type-specifier:
  </bnf-rule>
            <bnf-alt>
    
    
              <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> constrained-type-name
            
  </bnf-alt>

          <bnf-rule>
    
    constrained-type-name:
  </bnf-rule>
            <bnf-alt>
    
    concept-name
  </bnf-alt>
            <bnf-alt>
    
    partial-concept-id
  </bnf-alt>

          <bnf-rule>
    
    concept-name:
  </bnf-rule>
            <bnf-alt>
    
    identifier
  </bnf-alt>

          <bnf-rule>
    
    partial-concept-id:
  </bnf-rule>
            <bnf-alt>
    
    
              concept-name 
              <bnf-terminal><code>&lt;</code></bnf-terminal> 
              <bnf-opt>template-argument-list<sub>opt</sub></bnf-opt>
              <bnf-terminal><code>&gt;</code></bnf-terminal>
            
  </bnf-alt>
        
  </bnf-grammar>

        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        may also designate placeholders for deduced non-type and template 
        template arguments.

        Deduction of a placeholder from a template argument succeeds only when 
        the deduced value satisfies the constraints associated by the
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = false;
template&lt;int N&gt; concept bool C2 = false;
template&lt;template&lt;typename&gt; class X&gt; C3 = false;

template&lt;typename T, int N&gt; class Array { };
template&lt;typename T, template&lt;typename&gt; class A&gt; class Stack { };
template&lt;typename T&gt; class Alloc { };

void f1(C1 c);            // C1 <i>designates a placeholder type</i>
void f2(Array&lt;auto, C2&gt;); // C2 <i>designates a placeholder for an integer value</i>
void f3(Stack&lt;auto, C3&gt;); // C3 <i>designates a placeholder for a class template</i>

f1(0);                    // <i>error</i>
f2(Array&lt;int, 3&gt;{});      // <i>error</i>
f3(Stack&lt;char, Alloc&gt;{}); // <i>error</i></code></pre>
  
In each of these function calls, the deduction of the placeholder designated 
by the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
fails because the associated constraints are not satisfied.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="2" id="dcl.spec.constr.2">
        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        can appear in many of the same places as the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, is subject
        to the same rules, and has equivalent meaning in those contexts. 
        In particular, a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
        can appear in the following contexts with the given meaning:
        </p><ul>
        <li> a parameter type of a function declaration, signifying an 
             abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>);</li>
        <li> a parameter of a lambda, signifying a generic lambda 
             (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>);</li>
        <li> the parameter type of a template parameter, signifying a
             constrained template parameter (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>);</li>
        <li> the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of
             a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>,
             signifying a deduction constraint (<cxx-ref to="expr.req.compound"><a title="expr.req.compound" href="#expr.req.compound">5.1.3.4</a></cxx-ref>). </li>
        </ul>
        A program that includes a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in any other contexts is ill-formed.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T, int N&gt; concept bool C2 = true;
template&lt;bool (*)(int)&gt; concept bool C3 = true;

template&lt;typename T&gt; class Vec;

struct N {
  template&lt;typename T&gt; struct Wrap;
}
template&lt;typename T, typename U&gt; struct Pair;
template&lt;bool (*)(int)&gt; struct Pred;

auto gl = [](C1&amp; a, C1* b) { a = *b; }; // <i>OK: a generic lambda</i>
void af(const Vec&lt;C1&gt;&amp; x);              // <i>OK: an abbreviated function</i>

void f1(N::Wrap&lt;C1&gt;);     // <i>OK</i>
void f2(Pair&lt;C1, C2&lt;0&gt;&gt;); // <i>OK</i>
void f3(Pred&lt;C3&gt;);        // <i>OK</i>
void f4(C1::Wrap&lt;C2&lt;1&gt;&gt;); // <i>OK: but deduction of</i> C1 <i>will always fail</i>

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -&gt; const C1&amp;; // <i>OK: a deduction constraint</i>
  };
}</code></pre>
  </cxx-codeblock>
The declaration of <code>f4</code> is valid, but a value can never be deduced 
for the placeholder designated by <code>C1</code> since it appears in a
non-deduced context (<cxx-ref in="cxx" to="temp.deduct.type">C++ <span title="temp.deduct.type">§14.8.2.5</span></cxx-ref>).
However, a value may be explicitly given as a template argument in a
<cxx-grammarterm><i>template-id</i></cxx-grammarterm>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        <!-- </p> -->

        <p para_num="3" id="dcl.spec.constr.3">
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
Unlike <code>auto</code>, a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
cannot be used in the type of a variable declaration or the return type of 
a function.
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

const C* x = 0;  // <i>error:</i> C <i>used in a variable type</i>
D&lt;0&gt; fn(int x);  // <i>error:</i> D&lt;0&gt; <i>used as a return type</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="4" id="dcl.spec.constr.4">
        A <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> refers to a
        set of concept definitions (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        If that set is empty, the program is ill-formed.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member of this set when a 
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        refers to a variable concept.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#3</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #3</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="5" id="dcl.spec.constr.5">
        A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> is a
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="6" id="dcl.spec.constr.6">
        The concept designated by a 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is resolved by determining the viability of each concept in the
        candidate concept set.

        For each candidate concept in that set, <code>TT</code> is a 
        <cxx-grammarterm><i>template-id</i></cxx-grammarterm> formed as follows:

        let <code>C</code> be the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        for the candidate concept set, and let <code>X</code> be a template 
        argument that matches
        the type and form (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.3</a></cxx-ref>) of the prototype 
        parameter (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        of the candidate concept. 

        The template <code>X</code> is called the 
        <dfn>deduced concept argument</dfn>.

        If the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> in
        the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, <code>TT</code> is
        formed as <code>C&lt;X&gt;</code>.

        Otherwise, the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> whose
        <cxx-grammarterm><i>template-argument-list</i></cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub><i>n</i></sub></code>, and
        <code>TT</code> is formed as
        <code>C&lt;X, A<sub>1</sub>, A<sub>2</sub>, ..., A<sub><i>n</i></sub>&gt;</code>.

        The candidate concept is a <dfn>viable candidate concept</dfn> when all
        <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> of <code>TT</code> 
        match the template parameters of that candidate 
        (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.3</a></cxx-ref>).

        If, after determining the viability of each concept, there is a
        single viable candidate concept, that is the concept designated by the
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="7" id="dcl.spec.constr.7">The use of a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        associates a constraint (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the constraint is associated with
        the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        For an abbreviated function declaration, the constraint is associated
        with that function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        The use of a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of
        a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> includes
        an associated constraint in the conjunction of constraints introduced
        by that requirement (<cxx-ref to="expr.req.compound"><a title="expr.req.compound" href="#expr.req.compound">5.1.3.4</a></cxx-ref>).

        When a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is used in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>,
        the constrained it associated with the 
        <cxx-grammarter>template-declaration</cxx-grammarter> in which the
        <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is declared.
        </p>

        <p para_num="8" id="dcl.spec.constr.8"> The constraint associated by a
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is derived from the <cxx-grammarterm><i>template-id</i></cxx-grammarterm> 
        (called <code>TT</code> above) used to determine the viability of
        the designated concept (call it <code>D</code>).

        The constraint is formed by replacing the
        deduced concept argument <code>X</code> in <code>TT</code> with a 
        template argument, <code>A</code>. That template argument is
        defined as follows:
        </p><ul>
        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        of a function declaration, <code>A</code> is the name of the
        invented template parameter corresponding to the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>);</li>

        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>,
        <code>A</code> is the type deduced for that
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        from the expression <cxx-grammarterm><i>expression</i></cxx-grammarterm> in the
        requirement (<cxx-ref to="expr.prim.req"><a title="expr.prim.req" href="#expr.prim.req"></a></cxx-ref>);</li>

        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
        declaration, <code>A</code> is the name of the declared
        parameter (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>). </li>
        </ul>

        Let <code>TT2</code> be a <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
        formed as follows. 

        If <code>A</code> is a template parameter (possibly invented) that 
        declares a template parameter pack, and <code>D</code>
        is a variadic concept (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>),
        <code>TT2</code> is formed by replacing <code>X</code> in 
        <code>TT</code> with the pack expansion <code>A...</code>.

        Otherwise <code>TT2</code> is formed by replacing <code>X</code>
        with <code>A</code>.

        Let <code>E</code> be the <cxx-grammarterm><i>id-expression</i></cxx-grammarterm>
        <code>TT2</code> when the <code>D</code> is a variable concept, and
        the function call <code>TT2()</code> when the <code>D</code> is a 
        function concept.

        If <code>A</code> is a template parameter that declares a template
        parameter pack, and <code>D</code> is not a variadic concept,
        then the associated constraint is the fold expression 
        <code>(... &amp;&amp; E)</code>
        (<cxx-ref in="cxx" to="expr.prim.fold">C++ <span title="expr.prim.fold">§5.1.4</span></cxx-ref>).
        
        Otherwise, the associated constraint is the expression <code>E</code>.
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }
template&lt;int N&gt; concept bool Num = true;

template&lt;int&gt; struct X { };

void f(C&amp;);             // <i>associates</i> C&lt;T1&gt; <i>with</i> f
void g(D&lt;int&gt;);         // <i>associates</i> D&lt;T2, int&gt;() <i>with</i> g
void h(X&lt;Num&gt;);          // <i>associates</i> Num&lt;M&gt; <i>with</i> h
template&lt;C T&gt; struct s1; // <i>associates</i> C&lt;T&gt; <i>with</i> s1</code></pre>
  </cxx-codeblock>
        In the associated constraints, <code>T1</code> and <code>T2</code> 
        are invented type template parameters corresponding to the
        prototype parameter of their respective designated concepts.
        Likewise, <code>M</code> is a non-type template parameter
        corresponding to the prototype parameter of <code>Num</code>.
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool Req = 
    requires (T t) {
      {*t} -&gt; const C&amp;; // <i>adds the constraint</i> C&lt;A&gt; <i>to</i> Req
    };</code></pre>
  </cxx-codeblock>
        In the constraint introduced by the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        <code>const C&amp;</code>, <code>A</code> is the deduced type
        of the parameter <code>a</code> in the the call
        <code>f(*t)</code> of the following invented function template:
        <cxx-codeblock>
    
    <pre><code>template&lt;typename A&gt;
  void f(const A&amp; a);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        <p para_num="9" id="dcl.spec.constr.9"></p>
      
    </section>
  </cxx-section> <!-- dcl.spec.constr -->

    
    </section>
  </cxx-section> <!-- dcl.type -->



    <cxx-section id="dcl.spec.concept">
    

    <section>
      <header><span class="section-number">7.1.7</span> <h1 data-bookmark-label="7.1.7 concept specifier"><code>concept</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.concept">[dcl.spec.concept]</a></span></header>
      
      

      <p para_num="1" id="dcl.spec.concept.1"> The <code>concept</code> specifier shall be applied only to the 
      definition of a function template or variable template, declared
      in namespace scope (<cxx-ref in="cxx" to="basic.scope.namespace">C++ <span title="basic.scope.namespace">§3.3.6</span></cxx-ref>).
      
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A function
      concept is a non-throwing function 
      (<cxx-ref in="cxx" to="except.spec">C++ <span title="except.spec">§15.4</span></cxx-ref>).
      
      A variable template definition having the <code>concept</code> 
      specifier is called a <dfn>variable concept</dfn>.

      A <dfn>concept definition</dfn> refers to either a function concept 
      and its definition or a variable concept and its initializer.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; 
  concept bool F1() { return true; } // <i>OK: declares a function concept</i>
template&lt;typename T&gt; 
  concept bool F2();                 // <i>error: function concept is not a definition</i>
template&lt;typename T&gt; 
  concept bool V1 = true;            // <i>OK: declares a variable concept</i>
template&lt;typename T&gt; 
  concept bool V2;                   // <i>error: variable concept with no initializer</i>
struct S {
  template&lt;typename T&gt; 
    static concept bool C = true;    // <i>error: concept declared in class scope</i>
};</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="dcl.spec.concept.2"> No storage specifiers shall appear in a declaration with the 
      <code>concept</code> specifier. Additionally, a concept definition
      shall not include the <code>friend</code> or <code>constexpr</code>
      specifiers. </p>

      <p para_num="3" id="dcl.spec.concept.3"> Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr">C++ <span title="dcl.constexpr">§7.1.5</span></cxx-ref>). </p>

      <p para_num="4" id="dcl.spec.concept.4">A concept definition shall be unconstrained.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A concept defines a total mapping from its template arguments to the 
      values <code>true</code> and <code>false</code>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

      <p para_num="5" id="dcl.spec.concept.5"> The first declared template parameter of a concept definition is its
      <dfn>prototype parameter</dfn>. 

      A <dfn>variadic concept</dfn> is a concept whose prototype parameter
      is a template parameter pack.
      </p>

      <p para_num="6" id="dcl.spec.concept.6">A function concept has the following restrictions:
      </p><ul>
        <li> No <cxx-grammarterm><i>function-specifier</i></cxx-grammarterm>s shall
             appear in the declaration. </li>
        <li> The return type shall be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose <cxx-grammarterm><i>expression</i></cxx-grammarterm> shall be a
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>).
        </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; 
  concept int F1() { return 0; }      // <i>error: return type is not</i> bool
template&lt;typename T&gt; 
  concept bool F2(T) { return true; } // <i>error: must have no parameters</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="7" id="dcl.spec.concept.7">A variable concept has the following restrictions:
      </p><ul>
        <li> The declared type sall be <code>bool</code>. </li>
        <li> The declaration sall have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; 
  concept bool V2 = 3 + 4; // <i>error: initializer is not a constraint-expression</i>
template&lt;Integral T&gt; 
  concept bool V3 = true;  // <i>error: constrained template declared as a concept</i>
concept bool V4 = 0;       // <i>error: not a template</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="8" id="dcl.spec.concept.8">A program that declares an explicit instantiation, an explicit 
      specialization, or a partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = false;

template concept bool C&lt;char&gt;; // <i>error: explicit instantiation of a concept</i>
template&lt;&gt; 
  concept bool C&lt;int&gt; = true;  // <i>error: explicit specialization of a concept</i>
template&lt;typename T&gt; 
  concept bool C&lt;T*&gt; = true;   // <i>error: partial specialization of a concept</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="9" id="dcl.spec.concept.9">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

    
    </section>
  </cxx-section> <!-- dcl.concept -->

  
    </section>
  </cxx-section> <!-- dcl.spec -->

    </section>
  </cxx-clause> <!-- dcl.dcl -->


<cxx-clause id="dcl.decl" number="8">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Declarators">Declarators</h1> <span style="float:right"><a href="#dcl.decl">[dcl.decl]</a></span></header>
      
  

  Modify the definition of the <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  production in <cxx-ref in="cxx" to="dcl.decl">C++ <span title="dcl.decl">§8</span></cxx-ref>/1 as follows:

  <p para_num="1" id="dcl.decl.1" class="quoted">
  A declarator declares a single variable, function, or type within a 
  declaration. The <cxx-grammarterm><i>init-declarator-list</i></cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which may
  <del>have an initializer</del>
  <ins>have constraints, an initializer, or both</ins>.
  <bnf-grammar>
    
    
    <bnf-rule>
    
    init-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        <bnf-opt>initializer<sub>opt</sub></bnf-opt>
      
  </bnf-alt>
  
  </bnf-grammar>
  </p>

  Insert the following paragraphs.

  <p para_num="2" id="dcl.decl.2" class="quoted">
  A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm> shall only appear
  with a function declarator (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

  If present, the <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> associates 
  its <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> with the declared
  function (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

void f1(int x) requires C&lt;int&gt;;       // <i>OK</i>
auto n requires C&lt;decltype(n)&gt; = 'a'; // <i>error: constrained variable declaration</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="3" id="dcl.decl.3" class="quoted">
  The names of parameters in a function declarator are visible in the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

void f(auto x) requires C&lt;decltype(x)&gt;;
void g(int n) requires sizeof(n) == 4;</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <cxx-section id="dcl.meaning" number="3">
    

    <section>
      <header><span class="section-number">8.3</span> <h1 data-bookmark-label="8.3 Meaning of declarators">Meaning of declarators</h1> <span style="float:right"><a href="#dcl.meaning">[dcl.meaning]</a></span></header>
      
    

    <cxx-section id="dcl.fct" number="5">
    

    <section>
      <header><span class="section-number">8.3.5</span> <h1 data-bookmark-label="8.3.5 Functions">Functions</h1> <span style="float:right"><a href="#dcl.fct">[dcl.fct]</a></span></header>
      
      

      Refactor the grammar for 
      <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>s in
      paragraph 3 in order to support the definition of
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s in
      Clause 14.

      <p para_num="3" id="dcl.fct.3" class="quoted" number="3">

      <bnf-grammar>
    
    
      
        <bnf-rule>
    
    parameter-declaration:
  </bnf-rule>
          <bnf-alt>
    
    
            basic-parameter-declaration
          
  </bnf-alt>
          <bnf-alt>
    
    
            basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> initializer
          
  </bnf-alt>

        <bnf-rule>
    
    basic-parameter-declaration:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt>
            decl-specifier-seq 
            declarator
          
  </bnf-alt>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator<sub>opt</sub></bnf-opt>
          
  </bnf-alt>
      
  </bnf-grammar></p>

      Modify the second sentence of paragraph 5. The remainder of this
      paragraph has been omitted.

      <p para_num="5" id="dcl.fct.5" class="quoted" number="5">
      A single name can be used for several different functions in a single 
      scope; this is function overloading (<cxx-ref to="over"><a title="over" href="#over">13</a></cxx-ref>). 

      All declarations for a function shall agree exactly in <del>both</del> 
      the return type<ins>,</ins> <del>and</del> the parameter-type-list<ins>,
      and asssociated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>.
      </p>

      Modify paragraph 15. Note that the footnote reference has been
      omitted.

      <p para_num="15" id="dcl.fct.15" class="quoted" number="15">
      There is a syntactic ambiguity when an ellipsis occurs at the end of a 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> without
      a preceding comma. In this case, the ellipsis is parsed as part of the 
      <cxx-grammarterm><i>abstract-declarator</i></cxx-grammarterm> if the type of the
      parameter either names a template parameter pack that has not been 
      expanded or contains <ins>either</ins> <code>auto</code> <ins>or a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm></ins>; otherwise, 
      it is parsed as part of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>.
      </p>

      Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct">C++ <span title="dcl.fct">§8.3.5</span></cxx-ref>/15.

      <p para_num="16" id="dcl.fct.16" class="quoted" number="16">
      An <dfn>abbreviated function</dfn> is a function whose
      parameter-type-list inclues one or more placeholders 
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>,
      <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).

      An abbreviated function is equivalent to a function template 
      (<cxx-ref to="temp.fct"><a title="temp.fct" href="#temp.fct">14.5.6</a></cxx-ref>) whose
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      includes one invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
      for each occurrence of a placeholder in the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, 
      in order of appearance. 

      If the placeholder is designated by the <code>auto</code>
      <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, then the corresponding
      invented template parameter is a type 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

      Otherwise, the placeholder is designated by a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>, and
      the corresponding invented parameter matches the type and form of
      the prototype parameter (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) of 
      the concept designated by the 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

      The invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
      declares a function parameter pack and the type of the parameter 
      contains only one placeholder.

      <!-- TODO: This is up for discussion. Striking it should have
           no serious consequence. Note that there is a corresponding
           example in this section. Also, I need to modify the previous
           sentence to remove this restriction. -->
      If the type of the function parameter that declares a function
      parameter pack containing more than one placeholder, the program
      is ill-formed.

      The adjusted function parameters of an abbreviated function are derived 
      from the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> 
      by replacing each occurrence of a placeholder with the name of the 
      corresponding invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

      If the replacement of a placeholder with the name of a template parameter
      results in an invalid parameter declaration, the program is ill-formed.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(const auto&amp;, auto);
void f2(Vec&lt;auto*&gt;...);
void f3(auto (auto::*)(auto));

template&lt;typename T, typename U&gt; 
  void f1(const T&amp;, U);        // <i>redeclaration of</i> f1(const auto&amp;, auto)
template&lt;typename... T&gt; 
  void f2(Vec&lt;T*&gt;...);         // <i>redeclaration of</i> f2(Vec&lt;auto*&gt;...)
template&lt;typename T, typename U, typename V&gt;
  void f3(T (U::*)(V));        // <i>redeclaration of</i> f3(auto (auto::*)(auto))

void foo(Pair&lt;auto, auto&gt;...); // <i>error: multiple placeholder types in a parameter pack</i>

template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = true;
template&lt;typename T, typename U&gt; concept bool D = true;

void g1(const C1*, C2&amp;);
void g2(Vec&lt;C1&gt;&amp;);
void g3(C1&amp;...);
void g4(Vec&lt;D&lt;int&gt;&gt;);

template&lt;C1 T, C2 U&gt; void g1(const T*, U&amp;); // <i>redeclaration of</i> g1(const C1*, C2&amp;)
template&lt;C1 T&gt; void g2(Vec&lt;T&gt;&amp;);            // <i>redeclaration of</i> g2(Vec&lt;C1&gt;&amp;)
template&lt;C1... Ts&gt; void g3(Ts&amp;...);         // <i>redeclaration of</i> g3(C1&amp;...)
template&lt;D&lt;int&gt; T&gt; void g4(Vec&lt;T&gt;);         // <i>redeclaration of</i> g4(Vec&lt;D&lt;int&gt;&gt;)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;int N&gt; concept bool Num = true;

void h(Num*); // <i>error: invalid type in parameter declaration</i></code></pre>
  </cxx-codeblock>
The equivalent and erroneous declaration would have this form:
      <cxx-codeblock>
    
    <pre><code>template&lt;int N&gt; void h(N*); // <i>error: invalid type</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <p></p>

      <p para_num="17" id="dcl.fct.17"> All placeholders introduced using the same 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> have the 
      same invented template parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>namespace N {
  template&lt;typename T&gt; concept bool C = true;
}
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int&gt; concept bool D = true;
template&lt;typename, int = 0&gt; concept bool E = true;

void f0(C a, C b);</code></pre>
  
      The types of <code>a</code> and <code>b</code> are the same invented template
      type parameter.

      <cxx-codeblock>
    
    <pre><code>void f1(C&amp; a, C* b);</code></pre>
  </cxx-codeblock>
      The type of <code>a</code> is a reference to an invented template type parameter 
      (call it <code>T</code>), and the type of <code>b</code> is a pointer to 
      <code>T</code>.

      <cxx-codeblock>
    
    <pre><code>void f2(N::C a, C b);
void f3(D&lt;0&gt; a, D&lt;1&gt; b);</code></pre>
  </cxx-codeblock>
      In both functions, the parameters <code>a</code> and
      <code>b</code> have different invented template type parameters.

      <cxx-codeblock>
    
    <pre><code>void f4(E a, E&lt;&gt; b, E&lt;0&gt; c);</code></pre>
  </cxx-codeblock>
      The types of <code>a</code>, <code>b</code>, and <code>c</code> are
      distinct invented template type parameters even though the constraints 
      associated by the each of the 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
      (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>) are equivalent.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  <p></p>

      <!-- TODO: Move into temp.fct? -->
      <p para_num="18" id="dcl.fct.18"> A function template can be an abbreviated function. The
      invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s are
      added to the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: equivalent to f(Array&lt;auto, N&gt;*)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- dcl.fct -->
  
    </section>
  </cxx-section> <!-- dcl.meaning -->

  <cxx-section id="dcl.fct.def">
    

    <section>
      <header><span class="section-number">8.4</span> <h1 data-bookmark-label="8.4 Function definitions">Function definitions</h1> <span style="float:right"><a href="#dcl.fct.def">[dcl.fct.def]</a></span></header>
      
    

    <cxx-section id="dcl.fct.def.general">
    

    <section>
      <header><span class="section-number">8.4.1</span> <h1 data-bookmark-label="8.4.1 In general">In general</h1> <span style="float:right"><a href="#dcl.fct.def.general">[dcl.fct.def.general]</a></span></header>
      
      
    
      Modify the <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
      syntax in <cxx-ref in="cxx" to="dcl.fct.def.general">C++ <span title="dcl.fct.def.general">§8.4.1</span></cxx-ref>
      to include a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.

      <p para_num="1" id="dcl.fct.def.general.1" class="quoted">
      <bnf-grammar>
    
    
        <bnf-rule>
    
    function-definition:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt>
            <bnf-opt>decl-specifier-seq<sub>opt</sub></bnf-opt>
            declarator
            <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
            <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
            function-body
          
  </bnf-alt>
      
  </bnf-grammar>
      </p>

      Add the following paragraph.

      <p para_num="9" id="dcl.fct.def.general.9" number="9" class="quoted">
      <ins> If present, the <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
      associates its <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
      with the function (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      </ins></p>

    
    </section>
  </cxx-section> <!-- dcl.fct.def.general -->
  
    </section>
  </cxx-section> <!-- dcl.fct.def -->

    </section>
  </cxx-clause> <!-- dcl.decl -->


<cxx-clause id="class" number="9">
    

    <section>
      <header><span class="section-number">9</span> <h1 data-bookmark-label="9 Classes">Classes</h1> <span style="float:right"><a href="#class">[class]</a></span></header>
      
  

  <cxx-section id="class.mem" number="2">
    

    <section>
      <header><span class="section-number">9.2</span> <h1 data-bookmark-label="9.2 Class members">Class members</h1> <span style="float:right"><a href="#class.mem">[class.mem]</a></span></header>
      
    

    In <cxx-ref in="cxx" to="class.mem">C++ <span title="class.mem">§9.2</span></cxx-ref>, modify the
    <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm> syntax.

    <p para_num="1" id="class.mem.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    member-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator 
        <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        <bnf-opt>pure-specifier-seq<sub>opt</sub></bnf-opt>
      
  </bnf-alt>
    
  </bnf-grammar>
    </p>

    Insert the following paragraphs after <cxx-ref in="cxx" to="class.mem">C++ <span title="class.mem">§9.2</span></cxx-ref>/8.

    <p para_num="9" id="class.mem.9" class="quoted" number="9">
    A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> shall only appear
    in a <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm> if its
    <cxx-grammarterm><i>declarator</i></cxx-grammarterm> is a function declarator.

    The <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> associates its 
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> with the 
    member function.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct A {
    A(int*) requires true;  // <i>OK: constrained constructor</i>
    ~A() requires true;     // <i>OK: constrained destructor</i>
    void f() requires true; // <i>OK: constrained member function</i>
    int x requires true;    // <i>error: constrained member variable</i>
  };</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="10" id="class.mem.10" class="quoted">
    The names of parameters in a function declarator are visible in the
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>. </p>
  
    </section>
  </cxx-section> <!-- class.mem -->


    </section>
  </cxx-clause>


<cxx-clause id="class.derived" number="10">
    

    <section>
      <header><span class="section-number">10</span> <h1 data-bookmark-label="10 Derived classes">Derived classes</h1> <span style="float:right"><a href="#class.derived">[class.derived]</a></span></header>
      
  

  <cxx-section id="class.virtual" number="3">
    

    <section>
      <header><span class="section-number">10.3</span> <h1 data-bookmark-label="10.3 Virtual functions">Virtual functions</h1> <span style="float:right"><a href="#class.virtual">[class.virtual]</a></span></header>
      
    

    Insert the following paragraph after paragraph 5 in order to
    prohibit the declaration of constrained virtual functions and
    the overriding of a virtual function by a constrained member
    function.

    <p para_num="6" id="class.virtual.6" class="quoted" number="6">
    If a virtual function has associated constraints 
    (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), the program is ill-formed. If
    a constrained member function overrides a virtual function in any
    base class, the program is ill-formed.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct A {
  virtual void f() requires true; // <i>error: constrained virtual function</i>
};

struct B {
  virtual void f();
};

struct D : B {
  void f() requires true; // <i>error: constrained override</i>
}</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    
    </section>
  </cxx-section> <!-- class.virtual -->


    </section>
  </cxx-clause> <!-- class.derived -->


<cxx-clause id="over" number="13">
    

    <section>
      <header><span class="section-number">13</span> <h1 data-bookmark-label="13 Overloading">Overloading</h1> <span style="float:right"><a href="#over">[over]</a></span></header>
      
  

  Modify paragraph 1 to allow overloading based on constraints.

  <p para_num="1" id="over.1" class="quoted">
  When two or more different declarations are specified for a single name 
  in the same scope, that name is said to be overloaded. By extension, two 
  declarations in the same scope that declare the same name but with
  different types 
  <ins>or different associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
  are called <dfn>overloaded declarations</dfn>. Only function and function 
  template declarations can be overloaded; variable and type declarations 
  cannot be overloaded.
  </p>

  Update paragraph 3 to mention a function's overloaded constraints. 
  Note that the itemized list in the original text is omitted in this
  document.

  <p para_num="3" id="over.3" number="3" class="quoted">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  As specified in <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>, function declarations 
  that have equivalent parameter declarations 
  <ins>and associated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>,
  declare the same function and therefore cannot be overloaded: ...
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>


  <cxx-section id="over.dcl" number="2">
    

    <section>
      <header><span class="section-number">13.2</span> <h1 data-bookmark-label="13.2 Declaration matching">Declaration matching</h1> <span style="float:right"><a href="#over.dcl">[over.dcl]</a></span></header>
      
    

    Modify paragraph 1 to extend the notion of declaration matching to
    also include a function's associated constrains. Note that the
    example in the original text is omitted in this document.

    <p para_num="1" id="over.dcl.1" class="quoted">
    Two function declarations of the same name refer to the same function if 
    they are in the same scope and have equivalent parameter declarations 
    (<cxx-ref in="cxx" to="over.load">C++ <span title="over.load">§13.1</span></cxx-ref>)
    <ins>and equivalent associated constraints, 
    if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>.
    </p>
  
    </section>
  </cxx-section> <!-- over.dcl -->

  <cxx-section id="over.match">
    

    <section>
      <header><span class="section-number">13.3</span> <h1 data-bookmark-label="13.3 Overload resolution">Overload resolution</h1> <span style="float:right"><a href="#over.match">[over.match]</a></span></header>
      
    

    <cxx-section id="over.match.viable">
    

    <section>
      <header><span class="section-number">13.3.1</span> <h1 data-bookmark-label="13.3.1 Viable functions">Viable functions</h1> <span style="float:right"><a href="#over.match.viable">[over.match.viable]</a></span></header>
      
      

      Update paragraph 1 to require the checking of a candidate's associated
      constraints when determining if that candidate is a viable candidate
      for a function call.

      <p para_num="1" id="over.match.viable.1" class="quoted">
      From the set of candidate functions constructed for a given context 
      (<cxx-ref in="cxx" to="over.match.funcs">C++ <span title="over.match.funcs">§13.3.1</span></cxx-ref>), a set of viable 
      functions is chosen, from which the best function will be selected by 
      comparing argument conversion sequences and associated constraints
      for the best fit (<cxx-ref to="over.match.best"><a title="over.match.best" href="#over.match.best">13.3.2</a></cxx-ref>).

      The selection of viable functions considers 
      <ins>their associated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), and</ins>
      their relationships between arguments and function parameters other 
      than the ranking of conversion sequences.
      </p>

      Insert the following paragraph after paragraph 1; this introduces
      new a criterion for determining if a candidate is viable. Also, update
      the beginning of the subsequent paragraphs to account for the
      insertion.

      <p para_num="2" id="over.match.viable.2" class="quoted" number="2">
      First, for <code>F</code> to be a viable function, if <code>F</code> has 
      associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), those 
      constraints shall be satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>).
      </p>

      <p para_num="3" id="over.match.viable.3" class="quoted" number="3">
      <del>First</del><ins>Second</ins>, to be a viable function ...
      </p>

      <p para_num="4" id="over.match.viable.4" class="quoted" number="4">
      <del>Second</del><ins>Third</ins>, for <code>F</code> to be a viable function ...
      </p>

    
    </section>
  </cxx-section> <!-- over.match.viable -->

    <cxx-section id="over.match.best">
    

    <section>
      <header><span class="section-number">13.3.2</span> <h1 data-bookmark-label="13.3.2 Best viable function">Best viable function</h1> <span style="float:right"><a href="#over.match.best">[over.match.best]</a></span></header>
      
      

      Modify the last item in the list in paragraph 1 and extend it with
      a final comparison based on the associated constraints of those
      functions. This applies to both normal functions and specializations
      of function templates. Note that the preceding (unmodified) items
      in the original document are elided in this document.

      <p para_num="1" id="over.match.best.1" class="quoted">
      Define ICS<i>i</i>(<code>F</code>) as follows:
      </p><ul>
      <li> ... </li>
      <li> <code>F1</code> and <code>F2</code> are function template 
      specializations, and the function template for <code>F1</code> is more 
      specialized than the template for <code>F2</code> according to the 
      partial ordering rules described in 
      <cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref><del>.</del><ins>, or, 
      if not that,</ins> </li>
      
      <li><ins>
      <code>F1</code> is more constrained than <code>F2</code> according to
      the partial ordering of constraints described in 
      <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>.</ins></li>
      </ul>
      <!-- </p> -->
    
    </section>
  </cxx-section> <!-- over.match.best -->
  
    </section>
  </cxx-section> <!-- over.match -->

  <cxx-section id="over.over">
    

    <section>
      <header><span class="section-number">13.4</span> <h1 data-bookmark-label="13.4 Address of overloaded function">Address of overloaded function</h1> <span style="float:right"><a href="#over.over">[over.over]</a></span></header>
      
    

    The introduction of constraints modifies the rules for determining
    which function is selected when taking the address of an overloaded
    function. Insert a new paragraph before paragraph 4.

    <p para_num="4" id="over.over.4" class="quoted" number="4">
    If a single constrained function is selected, and the constraints are
    not satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>), the program
    is ill-formed. 
    </p>

    Replace the existing paragraph 4 with this paragraph.

    <!-- FIXME: This algorithm is going to be a common theme. It should
         be called out somewhere in overload resolution. -->
    <p para_num="5" id="over.over.5" class="quote" number="5">
    If more than one function, any function or function template specialization
    in that set are eliminated if their associated constraint (if any) are not 
    satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>). Among the remaining
    functions, the following rules are used to choose the  the best function. 

    A selected function <code>F1</code> is a better choice another selected 
    function <code>F2</code> if:
    </p><ul>
    <li><code>F1</code> is not a function template specialization and
    <code>F2</code>is a function template specialization, or if not that,</li>
    
    <li><code>F1</code> and <code>F2</code> are function template 
    specializations, and the function template for <code>F1</code> is more 
    specialized than the template for <code>F2</code> according to the partial 
    ordering rules described in <cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>,
    or if not that, </li>

    <li><code>F1</code> is more constrained than <code>F2</code> according
    to the partial ordering rules described in 
    <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>.
    </li></ul>
    If there is exactly one function that is better than all others, then
    that is the selected function. Otherwise, the program is ill-formed.

    Include the following examples in paragraph 5 (paragraph 6 in this
    document):

    <p para_num="6" id="over.over.6" class="quote" number="6">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>void f() { }                // <i>#1</i>
void f() requires true { }; // <i>#2</i>
void g() requires false;

void (*pf)() = &amp;f;         // <i>selects #2</i>
void (*pg)() = &amp;g;         // <i>error: g() cannot be selected</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
    
    </section>
  </cxx-section> <!-- over.over -->


    </section>
  </cxx-clause>


<cxx-clause id="temp" number="14">
    

    <section>
      <header><span class="section-number">14</span> <h1 data-bookmark-label="14 Templates">Templates</h1> <span style="float:right"><a href="#temp">[temp]</a></span></header>
      
  

  Modify the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p para_num="1" id="temp.1" number="1" class="quoted">
  <bnf-grammar>
    
    
    <bnf-rule>
    
    template-declaration:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>template</code></bnf-terminal>
        <bnf-terminal><code>&lt;</code></bnf-terminal>
        template-parameter-list
        <bnf-terminal><code>&gt;</code></bnf-terminal>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        declaration
      
  </bnf-alt>
      <ins>
      <bnf-alt>
    
    
        <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> 
        concept-name
        <bnf-terminal><code>{</code></bnf-terminal>
        introduction-list
        <bnf-terminal><code>}</code></bnf-terminal>
        declaration
      
  </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>
    
    requires-clause:
  </bnf-rule>
      <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> constraint-expression
  </bnf-alt>

    <bnf-rule>
    
    introduction-list:
  </bnf-rule>
      <bnf-alt>
    
    introduced-parameter
  </bnf-alt>
      <bnf-alt>
    
    introduction-list<bnf-terminal><code>,</code></bnf-terminal> introduced-parameter
  </bnf-alt>

      <bnf-rule>
    
    introduced-parameter:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-opt><bnf-terminal><code>...</code></bnf-terminal><sub>opt</sub></bnf-opt> identifier
  </bnf-alt>
    </ins>
  
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>/6.

  <p para_num="2" id="temp.2"> A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), or they are
  introduced by a <dfn>concept introduction</dfn>, a
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> and following
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.</p>

  <p para_num="3" id="temp.3"> The concept designated by the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
  is determined by the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.
  Let <code>C</code> be a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
  and <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code> be a 
  sequence of <cxx-grammarterm><i>identifiers</i></cxx-grammarterm> in the
  <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s of
  an <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

  If the <cxx-grammarterm><i>template-id</i></cxx-grammarterm>,
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code>, refers to a single
  concept declaration, then that concept is the one designated by
  <code>C</code>. Otherwise, the program is ill-formed.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i></code></pre>
  
  It is possible to overload function concepts in such a way that a
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> can designate multiple
  concepts.
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of</i> C{X} <i>is ambiguous</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="4" id="temp.4">Each <cxx-grammarterm><i>identifier</i></cxx-grammarterm>, <code>I</code>,
  in the <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s
  of the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> 
  is declared to be a template parameter that matches the 
  corresponding template parameter, <code>P</code>, in the 
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
  of the concept designated by the 
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>.
  <cxx-grammarterm><i>
  </i></cxx-grammarterm></p><ul>
  
  <li> If <code>P</code> is a template 
  <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> declared with either 
  the <code>class</code> or <code>typename</code> keyword, 
  <code>I</code> is declared as a template 
  <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> using the same keyword;</li>
  
  <li> if <code>P</code> is a template <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> 
  that declares a class template, <code>I</code> is declared as a
  class template with the template parameters of <code>P</code>;</li>
  
  <li> if <code>P</code> is a non-type 
  <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, <code>I</code> is
  declared as a non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
  having the same type as <code>P</code>;</li>
  
  <li> if <code>P</code> is a template parameter pack, 
  the <cxx-grammarterm><i>identifier</i></cxx-grammarterm>, <code>I</code>,
  shall be preceded by an ellipsis, and is declared as a template parameter 
  pack.</li>
  </ul>
  
  An <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> shall not contain
  an ellipsis if its corresponding template parameter does not declare
  a template parameter pack.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T, int N, typename... Xs&gt; concept bool Inscrutable = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool Unary_template = true;

Inscrutable{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;             // B <i>is declared as</i> int B
                        // C <i>is declared as</i> typename... C

Inscrutable{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

Unary_template{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

Unary_template{...X} // <i>error: the corresponding parameter is not a</i> 
  void bar();        // <i>template parameter pack</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  <p para_num="5" id="temp.5"></p>

  <p para_num="6" id="temp.6">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A concept referred to by a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> 
  may have template parameters with default template arguments. An
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> may omit 
  <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s for a corresponding template
  parameter if it has a default argument. However, only the
  <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s are declared
  as template parameters. 
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename A, typename B = bool&gt; 
  concept bool Ineffable() { return true; }

Ineffable{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                        // <i>a single template type parameter</i> T</code></pre>
  
There is no <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> 
that corresponds to the template parameter <code>B</code> in the
<code>Ineffable</code> concept, so <code>f(T)</code> is declared with only
one template parameter.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
    <span class="nowrap">— <em>end note</em> ]</span>
  
  <p></p>

  <p para_num="7" id="temp.7"> The <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> shall not
  be empty.</p>

  <p para_num="8" id="temp.8"> An introduced template parameter does not have a default template 
  argument, even if its corresponding template parameter does.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- FIXME: Does this belong here or in member functions? -->
  <p para_num="9" id="temp.9">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
    <span class="nowrap">— <em>end note</em> ]</span>
  
  <p></p>

  <p para_num="10" id="temp.10"> A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> declared
  by a concept introduction can also be an abbreviated function
  (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

  The invented template parameters introduced by the presence of
  <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s or
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in
  the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
  are added to the list of template parameters introduced by the the
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} void f(T, D);

template&lt;C T, D __D&gt; void f(T, __D); // <i>OK: redeclaration of</i> f(T, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  void f(D);
  D{U} void g(U, C);
};

C{T} void X&lt;T&gt;::f(D) { } // <i>OK: definition of</i> X&lt;T&gt;::f(D);
                         // f <i>is a function template with one invented</i>
                         // <i>template type-parameter</i>

C{T} D{U} void X&lt;T&gt;::g(U, C) { } // <i>OK: definition of</i> X&lt;T&gt;::g(U, C);
                                 // g <i>is a function template with two template</i>
                                 // <i>type parameters: one introduced (</i>U<i>) and</i>
                                 // <i>one invented</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  <p></p>

  <p para_num="11" id="temp.11"> The introduction of a sequence of template parameters,
  <code>T1, T2, ..., T<i>n</i></code>, by a 
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, <code>C</code>,
  associates a constraint with the 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. That constraint is
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;</code> when <code>C</code> designates
  a variable concept and
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;()</code> when <code>C</code> designates
  a function concept. If an <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>
  declares a template parameter pack, its corresponding template argument in the
  associated constraint is a pack expansion 
  (<cxx-ref in="cxx" to="temp.variadic">C++ <span title="temp.variadic">§14.5.3</span></cxx-ref>).

  <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename A, typename B, int C&gt; concept bool C = true;
template&lt;typename A, typename... Args&gt; concept bool D = true;

C{X, Y, Z} struct S;  // <i>associates</i> C&lt;X, Y, Z&gt; <i>with</i> S
D{P, ...Qs} struct T; // <i>associates</i> D&lt;P, Qs...&gt; <i>with</i> T</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- FIXME: This should move to a separate section? -->


  <p para_num="12" id="temp.12">A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>'s 
  <dfn>associated constraints</dfn> are a conjunction of all constraints 
  introduced by
  </p><ul>
  <li> a concept introduction,

  </li><li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>)
  in the declaration's <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,</li>

  <li> any <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
  a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>),</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> appearing after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> of an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>), or</li>

  <li>some combination these.</li>
  </ul>

  A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>T</code>, 
  whose constraints are introduced using any combination of these mechanisms is 
  equivalent to another <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>,
  <code>E</code>, whose template parameters are declared explicitly and as
  unconstrained template parameters, and <code>E</code> has a single 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> whose 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T</code> 
  (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>).

  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
     This section describes how constrained template declarations can 
  be equivalently written using alternative syntax in order to generate
  a canonical spelling of a template's associated constraints. 
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);</code></pre>
  </cxx-codeblock>
  The last declaration includes the canonical spelling of the associated 
  constraints for all declarations of <code>g(T)</code> as the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of its
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  The paragraphs below define the rules that make these declarations
  equivalent.
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  <p para_num="13" id="temp.13">

  </p><p para_num="14" id="temp.14"> When <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is
  declared by a concept introduction, it is equivalent to a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> whose
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> is defined 
  according to the rules for introducing template parameters above, and the 
  equivalent declaration has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  equivalent to constraint associated by the concept introduction.
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt;      // <i>constraint associated by</i> C4{...Qs}
    void void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p para_num="15" id="temp.15">When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>T</code>, is
  explicitly declared with <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), it
  is equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>E</code>,
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).
  
  The declaration, <code>E</code>, has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is the
  conjunction of the constraints associated by the constrained template 
  parameters in <code>T</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared. If the constraints of a redeclaration are
  functionally equivalent, but not equivalent to, those of the original,
  the program is ill-formed; no diagnostic is required
  (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>).

  If the original declaration, <code>T</code>, includes a 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, its
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>E</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename X, int Y&gt; 
  requires C2&lt;Y&gt; &amp;&amp; C1&lt;X&gt;
    struct S; // <i>error: constraints are functionally equivalent but not</i>
              // <i>equivalent to those of</i> R<i>; no diagnostic required</i>

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="16" id="temp.16"> When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>. The associated constraints of the
  abbreviated function are evaluated in the order in which they appear.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires D&lt;U&gt;() &amp;&amp; C&lt;T&gt;  
    void f(T, T, U): // <i>error: constraints are functionally equivalent</i>
                     // <i>but not equivalent to those of</i> f(C, C, D);
                     // <i>no diagnostic required</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="17" id="temp.17"> An abbreviated function can also be declared as a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in the
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> and the
  following <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

template&lt;C T, D U&gt;
  requires P&lt;T&gt;     // <i>associated constraints are</i> C&lt;T&gt; &amp;&amp; D&lt;U&gt;() &amp;&amp; P&lt;T&gt; 
    void g1(T, U);  // <i>error: ill-formed, no diagnostic required</i>;
  
C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)</code></pre>
  
  The second declaration of <code>g1(T, U)</code> is ill-formed (no diagnostic
  required) because it is functionally equivalent to the first declaration, 
  but not equivalent.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  


  <p></p><p para_num="18" id="temp.18"> A <dfn>trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm></dfn> 
  is a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> that appears after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).

  When a constrained function template or member function template 
  declared with a trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  is equivalent to a declaration in which the 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U, typename __P&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)</code></pre>
  
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    

    <section>
      <header><span class="section-number">14.1</span> <h1 data-bookmark-label="14.1 Template parameters">Template parameters</h1> <span style="float:right"><a href="#temp.param">[temp.param]</a></span></header>
      
    

    Modify the <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/1 in order
    to allow constrained template parameters.

    <p para_num="1" id="temp.param.1" number="1" class="quoted">

    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-parameter:
  </bnf-rule>
        <del><bnf-alt>
    
    parameter-declaration
  </bnf-alt></del>
        <ins><bnf-alt>
    
    non-type-or-constrained-parameter
  </bnf-alt></ins>

      <ins>
      <bnf-rule>
    
    non-type-or-constrained-parameter:
  </bnf-rule>
        <bnf-alt>
    
    basic-parameter-declaration
  </bnf-alt>

        <bnf-alt>
    
    
          basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> initializer
        
  </bnf-alt>

        <bnf-alt>
    
    
          basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> type-id
        
  </bnf-alt>

        <bnf-alt>
    
    
          basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> id-expression
        
  </bnf-alt>
      </ins>
    
  </bnf-grammar>
    </p>
    
    Update the wording in <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/2 as 
    follows.

    <p para_num="2" id="temp.param.2" number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm><i>unqualified-id</i></cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm><i>qualified-id</i></cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
    <ins><cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm></ins>. 
    </p>

    Insert the following paragraphs after paragraph 3 in order to distinguish
    between a template parameter that declares a non-type parameter and a
    template-parameter that declares a constrained parameter, which may
    declare a type parameter. 

    <p para_num="3" id="temp.param.3" number="3" class="quoted">
    When a <cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm> has
    the following form:
    <bnf-grammar>
    
    
    <bnf-alt>
    
    
    constrained-type-specifier <bnf-opt>...<sub>opt</sub></bnf-opt> <bnf-opt>identifier<sub>opt</sub></bnf-opt>
    
  </bnf-alt>
    
  </bnf-grammar>
    it declares a <dfn>constrained template parameter</dfn>.

    Otherwise the parameter is a non-type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.
    </p>

    <p para_num="4" id="temp.param.4" class="quoted">
    If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
    appears in the the parameter type of a
    <cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm>,
    the program is ill-formed. The program is also ill-formed if a
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> appears
    anywhere in the <cxx-grammarterm><i>basic-parameter-declaration</i></cxx-grammarterm> 
    and the form of that declaration does not match the form above.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S1;       // <i>OK:</i> T <i>is a constrained template parameter</i>
template&lt;int N&gt; struct S2;     // <i>OK:</i> N <i>is a non-type template parameter</i>
template&lt;auto X&gt; struct S2;    // <i>error: auto in template parameter</i>
template&lt;const D N&gt; void f1(); // <i>error:</i> D <i>is used with a const-qualifier</i>
template&lt;D* N&gt; void f2();      // <i>error:</i> N <i>declares a pointer-to-</i>D</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>


    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.


    <p para_num="5" id="temp.param.5">A constrained template parameter declares a template parameter whose
    type and form match that of the prototype parameter of the concept 
    designated by its <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
    The designated concept is found using the rules in
    <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>. 

    In particular, when 
    <code>T</code> is a template parameter declared as 
    <cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm>,
    and <code>P</code> is its corresponding prototype parameter, then
    <code>T</code> is declared as follows:
    
    </p><ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> declared with
    the <code>code</code> or <code>typename</code>, <code>T</code> is also 
    type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> . It is 
    unspecified whether <code>T</code> is declared with <code>class</code>
    or <code>typename</code>.</li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, <code>T</code> is 
    also a non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    having the same type as <code>P</code>.</li>

    <!-- TODO: A template template parameter can be declared with
         typename in addition to class. -->
    <li> If <code>P</code> is a template 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, <code>T</code> is
    also a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    having the same <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
    <code>P</code>.</li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>T</code> also declares a template parameter pack. In such cases,
    <code>T</code> shall be declared with <code>...</code> following its
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.</li>
    </ul>

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error: parameter pack declared without</i> ...
template&lt;C5... Cx&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i></code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    <p para_num="6" id="temp.param.6"></p>
  
    </section>
  </cxx-section> <!-- temp.param -->


  <!-- ==============
       Template Names 
       ============== -->

  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    

    <section>
      <header><span class="section-number">14.2</span> <h1 data-bookmark-label="14.2 Template names">Template names</h1> <span style="float:right"><a href="#temp.names">[temp.names]</a></span></header>
      
    

    Insert the following paragraphs after 
    <cxx-ref in="cxx" to="temp.names">C++ <span title="temp.names">§14.2</span></cxx-ref>/7.<p para_num="1" id="temp.names.1"></p>

    <p para_num="2" id="temp.names.2">If a <cxx-grammarterm><i>template-id</i></cxx-grammarterm> refers to a
    specialization of a constrained template declaration, the template's
    associated constraints are checked by substituting the
    <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> into the
    constraints and evaluating the resulting expression. If the substitution 
    results in an invalid type or expression, or if the associated constraints 
    evaluate to <code>false</code>, then the program is ill-formed.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool True = true;
template&lt;typename T&gt; concept bool False = false;

template&lt;False T&gt; struct S;
template&lt;True T&gt; using Ptr = T*;

S&lt;int&gt;* x;   // Error: int does not satisfy the constraints of False.
Ptr&lt;int&gt; z;  // Ok: z has type int*</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Checking the constraints of a constrained class template does not 
    require its instantiation. 
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <p></p>

    
    <p para_num="3" id="temp.names.3"></p>
  
    </section>
  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    

    <section>
      <header><span class="section-number">14.3</span> <h1 data-bookmark-label="14.3 Template arguments">Template arguments</h1> <span style="float:right"><a href="#temp.arg">[temp.arg]</a></span></header>
      
    

    <cxx-section id="temp.arg.template">
    

    <section>
      <header><span class="section-number">14.3.1</span> <h1 data-bookmark-label="14.3.1 Template template arguments">Template template arguments</h1> <span style="float:right"><a href="#temp.arg.template">[temp.arg.template]</a></span></header>
      
      

      Modify paragraph 3 to include rules for matching constrained template 
      template parameters. Note that the examples following this paragraph in
      the original document are omitted.

      <p para_num="3" id="temp.arg.template.3" number="3" class="quoted">
      A <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> matches 
      a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      the <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>)</ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>), and 
      for template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s matches, recursively. 

      When <code>P</code>’s <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic">C++ <span title="temp.variadic">§14.5.3</span></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <p para_num="3" id="temp.arg.template.3" number="3" class="quoted">
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.arg.template -->
  
    </section>
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    

    <section>
      <header><span class="section-number">14.5</span> <h1 data-bookmark-label="14.5 Template declarations">Template declarations</h1> <span style="float:right"><a href="#temp.decls">[temp.decls]</a></span></header>
      
    


    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
    

    <section>
      <header><span class="section-number">14.5.1</span> <h1 data-bookmark-label="14.5.1 Class templates">Class templates</h1> <span style="float:right"><a href="#temp.class">[temp.class]</a></span></header>
      
      

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. Note that the example
      in the original document is omitted. The example in this paragraph
      is to be added after the omitted example.

      <p para_num="3" id="temp.class.3" number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;C T&gt; void S&lt;T&gt;::f() { }        // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; 
  template&lt;D U&gt; struct S&lt;T&gt;::Inner { }; // <i>OK</i></code></pre>
  
      The declaration of <code>S&lt;T&gt;::g()</code> does not match because
      it does not have the associated constraints of <code>S</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
    

    <section>
      <header><span class="section-number">14.5.1.1</span> <h1 data-bookmark-label="14.5.1.1 Member functions of class templates">Member functions of class templates</h1> <span style="float:right"><a href="#temp.mem.func">[temp.mem.func]</a></span></header>
      
        

        Add the following example to the end of paragraph 1.

        <p para_num="1" id="temp.mem.func.1" number="1" class="quoted">
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g()                   // <i>error: no matching function in</i> S&lt;T&gt;</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>
      
    </section>
  </cxx-section> <!-- temp.mem.func -->
    
    </section>
  </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
    

    <section>
      <header><span class="section-number">14.5.2</span> <h1 data-bookmark-label="14.5.2 Member templates">Member templates</h1> <span style="float:right"><a href="#temp.mem">[temp.mem]</a></span></header>
      
      

      Modify paragraph 1 in order to account for constrained member templates
      of (possibly) constrained class templates. Add the example in this
      document after the example in the original document, which is omitted
      here.

      <p para_num="1" id="temp.mem.1" number="1" class="quoted">
      A template can be declared within a class or class template; such a 
      template is called a member template. 

      A member template can be defined within or outside its class definition 
      or class template definition. 

      A member template of a class template that is defined outside of its 
      class template definition shall be specified with the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      <ins>and associated constraints</ins>
      of the class template followed by the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s
      <ins>and associated constraints</ins>
      of the member template.

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = sizeof(T) &lt;= 4;

template&lt;C1 T&gt;
  struct S {
    template&lt;C2 U&gt; void f(U);
    template&lt;C2 U&gt; void g(U);
  };

template&lt;C1 T&gt; template&lt;C2 U&gt; 
  void S&lt;T&gt;::f(U); // <i>OK</i>
template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::g(U); // <i>error: definition does not match</i></code></pre>
  
      The associated constraints in the definition of <code>g()</code> do not
      match those in of its declaration.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.mem -->


    <!-- ============
         Friends
         ============ ->

    <!-- TODO: Rewrite friends -->
    <cxx-section id="temp.friend" number="4">
    

    <section>
      <header><span class="section-number">14.5.4</span> <h1 data-bookmark-label="14.5.4 Friends">Friends</h1> <span style="float:right"><a href="#temp.friend">[temp.friend]</a></span></header>
      
      

      <p para_num="1" id="temp.friend.1">Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend">C++ <span title="temp.friend">§14.5.4</span></cxx-ref>/9.

      </p><p para_num="2" id="temp.friend.2"> 
      A <dfn>constrained friend</dfn> of a class or class template is
      a constrained class template, constrained function template, a 
      constrained ordinary or generic (non-member) function definition.
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;         
      friend void f(X x, U u) { }    // Constrained function template

    template&lt;C W&gt;         
      friend struct Z { };           // Constrained class template

    friend bool operator==(X a, X b) // Constrained ordinary function
      requires C&lt;T&gt;() { return true; }

    friend void g(X a, C b) { }      // Constrained generic function
  };</code></pre>
  
      Note that <code>g</code> is a generic function because the the
      parameter <code>b</code> has a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="3" id="temp.friend.3">
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="temp.friend.4">
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="5" id="temp.friend.5">As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.</p>

    
    </section>
  </cxx-section> <!-- temp.friend -->


    <!-- ======================================
         Class template partial specializations
         ====================================== -->

    <cxx-section id="temp.class.spec">
    

    <section>
      <header><span class="section-number">14.5.5</span> <h1 data-bookmark-label="14.5.5 Class template partial specialization">Class template partial specialization</h1> <span style="float:right"><a href="#temp.class.spec">[temp.class.spec]</a></span></header>
      
      

      After paragraph 3, insert the following, which explains constrained
      partial specializations.

      <p para_num="4" id="temp.class.spec.4" number="4" class="quoted">
      A class template partial specialization may be constrained
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool N = N &gt; 0;

template&lt;C T1, C T2, N I&gt; class A&lt;T1, T2, I&gt;;  // <i>#6</i>
template&lt;C T, N I&gt;        class A&lt;int, T*, I&gt;; // <i>#7</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      Modify the 3rd item in the list of paragraph 8 to allow 
      constrained class template partial specializations like #6.
      Note that all other items in that list are elided.

      <p para_num="8" id="temp.class.spec.8" number="8" class="quoted">
      Within the argument list of a class template partial specialization, 
      the following restrictions apply:
      </p><ul>
      <li>...</li>
      <li><ins>In an unconstrained class template partial specialization,</ins>
      <del>The</del><ins>the</ins> argument list of the specialization shall
      not be identical to the implicit argument list of the primary template.
      </li><li>...</li>
      </ul>
      <p para_num="9" id="temp.class.spec.9"></p>


      <cxx-section id="temp.class.spec.match">
    

    <section>
      <header><span class="section-number">14.5.5.1</span> <h1 data-bookmark-label="14.5.5.1 Matching of class template partial specializations">Matching of class template partial specializations</h1> <span style="float:right"><a href="#temp.class.spec.match">[temp.class.spec.match]</a></span></header>
      
        

        Modify paragraph 2; constraints must be satisfied in order
        to match a partial specialization. Add the example given here
        to the (omitted) example in the original document.

        <p para_num="2" id="temp.class.spec.match.2" number="2" class="quoted"> 
        A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct">C++ <span title="temp.deduct">§14.8.2</span></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>)</ins>.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct S { void f(); };

A&lt;S, S, 1&gt;    a6; // <i>uses #6</i>
A&lt;S, int, 2&gt;  a7; // <i>error: constraints not satisfied</i>
A&lt;int, S*, 3&gt; a8; // <i>uses #7</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>
      
    </section>
  </cxx-section> <!-- temp.class.spec.match -->


      <cxx-section id="temp.class.order">
    

    <section>
      <header><span class="section-number">14.5.5.2</span> <h1 data-bookmark-label="14.5.5.2 Partial ordering of class template specializations">Partial ordering of class template specializations</h1> <span style="float:right"><a href="#temp.class.order">[temp.class.order]</a></span></header>
      
        

        Modify paragraph 1 so that constraints are considered in the
        partial ordering of class template specializations. Add the
        example at the end of this paragraph to the (omitted) example
        in the original document.

        <p para_num="1" id="temp.class.order.1" number="1" class="quoted">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order">C++ <span title="temp.func.order">§14.5.6.2</span></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and associated constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and associated constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;l;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;l;typename T&gt; concept bool D = C&lt;l;T&gt; &amp;&amp; requires (T t) { t.f(); };


template&lt;typename T&gt; class S { };
template&lt;C T&gt; class S&lt;T&gt; { }; // <i>#1</i>
template&lt;D T&gt; class S&lt;T&gt; { }; // <i>#2</i>

template&lt;C T&gt; void f(S&lt;T&gt;); // <i>A</i>
template&lt;D T&gt; void f(S&lt;T&gt;); // <i>B</i></code></pre>
  </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> is more specialized than <code>A</code>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      
    </section>
  </cxx-section> <!-- temp.class.order -->
    
    </section>
  </cxx-section> <!-- temp.class.spec -->


    <!-- ==================
         Function templates
         ================== --> 

    <cxx-section id="temp.fct">
    

    <section>
      <header><span class="section-number">14.5.6</span> <h1 data-bookmark-label="14.5.6 Function templates">Function templates</h1> <span style="float:right"><a href="#temp.fct">[temp.fct]</a></span></header>
      
      

      <cxx-section id="temp.over.link">
    

    <section>
      <header><span class="section-number">14.5.6.1</span> <h1 data-bookmark-label="14.5.6.1 Function template overloading">Function template overloading</h1> <span style="float:right"><a href="#temp.over.link">[temp.over.link]</a></span></header>
      
        

        Modify paragraph 6 to account for constraints on function
        templates.

        <p para_num="6" id="temp.over.link.6" number="6" class="quoted">
        <del> Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical template 
        parameter lists, and have return types and parameter lists that are 
        equivalent using the rules described above to compare expressions 
        involving template parameters.</del>
        <br>
        <ins>
        Two function templates are <dfn>equivalent</dfn> if they are:
        </ins></p><ul>
        <li> declared in the same scope,</li>
        <li> have the same name,</li>
        <li> have identical template parameter lists,</li>
        <li> have return types and parameter lists that are equivalent using
             the rules described above to compare expressions involving 
             template parameters, and</li>
        <li> have associated constraints that are equivalent using the rules 
             described in <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>.</li>
        </ul>
        

        <div class="quoted">
        Two function templates are <dfn>functionally equivalent</dfn> if they 
        are equivalent except that one or more expressions that involve 
        template parameters in the return types and parameter lists are 
        functionally equivalent using the rules described above to compare 
        expressions involving template parameters. 

        If a program contains declarations of function templates that are 
        functionally equivalent but not equivalent, the program is ill-formed; 
        no diagnostic is required.
        </div>
        <!-- </p> -->


      
    </section>
  </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
    

    <section>
      <header><span class="section-number">14.5.6.2</span> <h1 data-bookmark-label="14.5.6.2 Partial ordering of function templates">Partial ordering of function templates</h1> <span style="float:right"><a href="#temp.func.order">[temp.func.order]</a></span></header>
      
        

        Modify paragraph 2 to include constraints in the partial ordering
        of function templates.

        <p para_num="2" id="temp.func.order.2" number="2" class="quoted">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. 

        <ins>If both deductions succeed, the partial ordering selects
        the more constrained template as described by rules in
        <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>.</ins>
        </p>

      
    </section>
  </cxx-section> <!-- temp.func.order -->
    
    </section>
  </cxx-section> <!-- temp.fct -->


  <!-- ===============
       Alias templates
       =============== -->

    <cxx-section number="7" id="temp.alias">
    

    <section>
      <header><span class="section-number">14.5.7</span> <h1 data-bookmark-label="14.5.7 Alias templates">Alias templates</h1> <span style="float:right"><a href="#temp.alias">[temp.alias]</a></span></header>
      
      

      Insert the following after paragraph 2.

      <p para_num="3" id="temp.alias.3" number="3" class="quoted">
      If the alias template is constrained, and all template arguments
      are non-dependent, the <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s
      shall satisfy the template's associated constraints 
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template<typename c=""> = false;

template<c t=""> using Ptr = T*;

Ptr<int> p; // error: constraints not satisfied.
      </int></c></typename></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


    
    </section>
  </cxx-section>

  
    </section>
  </cxx-section> <!-- temp.decls -->


  <!-- =========================================
       Template instantiation and specialization
       ========================================= -->

  <cxx-section id="temp.spec" number="7">
    

    <section>
      <header><span class="section-number">14.7</span> <h1 data-bookmark-label="14.7 Template instantiation and specialization">Template instantiation and specialization</h1> <span style="float:right"><a href="#temp.spec">[temp.spec]</a></span></header>
      
    


    <cxx-section id="temp.inst">
    

    <section>
      <header><span class="section-number">14.7.1</span> <h1 data-bookmark-label="14.7.1 Implicit instantiation">Implicit instantiation</h1> <span style="float:right"><a href="#temp.inst">[temp.inst]</a></span></header>
      
      

      Add the following paragraph after paragraph 1 in order to explain
      the how constrained members are instantiated.

      <p para_num="1" id="temp.inst.1">
      When a constrained member of a class is instantiated, new constraints
      for the instantiated declaration are formed by substituting the
      template arguments into the associated constraints of that member.
      The resulting expression is not evaluated after this substitution.

      If the substitution fails, the program is ill-formed.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The evaluation of constraints happens during lookup or overload
      resolution (<cxx-ref to="over"><a title="over" href="#over">13</a></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C<t> &amp;&amp; sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { }
  S() requires D&lt;T&gt; { throw 0; }
};

S&lt;char&gt; s1;    // error: no matching constructor
S&lt;char[8]&gt; s2; // OK: but throws
      </t></code></pre>
  
      The instantiation of <code>S&lt;char&gt;</code> produces a class
      template specialization having the constructors, 
      <code>S&lt;char&gt;::S() requires C&lt;char&gt;</code> and
      <code>S&lt;char&gt;::S() requires D&lt;char&gt;</code>.

      Even though neither constructor will be selected by overload resolution,
      they remain a part of the class template specialization, and therefore
      suppress the generation of a default constructor.

      The default constructor invoked by the declaration of <code>s2</code>
      is the more constrained: the constraint
      <code>D&lt;char[8]&gt;</code> subsumes <code>C&lt;char[8]&gt;</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.inst -->


    <cxx-section id="temp.explicit">
    

    <section>
      <header><span class="section-number">14.7.2</span> <h1 data-bookmark-label="14.7.2 Explicit instantiation">Explicit instantiation</h1> <span style="float:right"><a href="#temp.explicit">[temp.explicit]</a></span></header>
      
      

      Add the following paragraph:

      <p para_num="14" id="temp.explicit.14" number="14">
      If the explicit instantiation names a constrained function template, 
      member function, or member function template, the explicit specialization 
      shall have associated constraints that are equivalent to those of the 
      template declaration (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) after substituting the
      specified or deduced template arguments into the template's associated 
      constraints.

      Explicit instantiations of class templates and variable templates
      cannot be constrained; such declarations simply refer to their 
      respective template declarations as if the templates were unconstrained.

      The template arguments of an explicit specialization shall satisfy
      the associated constraints of the template declaration, if any
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.8</a></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };

void f(C) { }
struct X { void f(); };

template void f(double);              // <i>error: no matching declaration</i>
template void f(X) requires C&lt;X&gt;;     // <i>OK</i>
template void f(int) requires C&lt;int&gt;; // <i>error: constraints not satisfied</i>

template&lt;C T&gt; struct Vec { };

template struct Vec&lt;X&gt;;   // <i>OK</i>
template struct Vec&lt;int&gt;; // <i>error: constraints not satisfied</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  struct S {
    void f();               // <i>#1</i>
    void f() requires C&lt;T&gt;; // <i>#2</i>
  };

template void S&lt;int&gt;::f();               // <i>OK: explicit specialization of #1</i>
template void S&lt;int&gt;::f() requires C&lt;T&gt;; // <i>OK: explicit specialization of #2</i></code></pre>
  </cxx-codeblock>
      In the last declaration, the <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
      is needed to determine which declaration is being explicitly instantiated.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <p></p>

      <!--
      <p>An explicit instantiation of constrained template declaration
      (<cxx-ref to="temp"></cxx-ref>)
      or constrained member function declaration 
      (<cxx-ref to="temp.mem.func"></cxx-ref>)
      shall satsify the associated constraints of that declaration
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typname T&gt;
  concept bool C = requires(T t) { t.c(); };

template&lt;typenane T&gt;
  requires C&lt;T&gt;
    struct X { }

template struct X&lt;int&gt;; // Error: int does not satisfy C.
      </cxx-codeblock>
      </cxx-example>
      </p>

      -->
    
    </section>
  </cxx-section> <!-- temp.explicit -->

    <cxx-section id="temp.expl.spec">
    

    <section>
      <header><span class="section-number">14.7.3</span> <h1 data-bookmark-label="14.7.3 Explicit specialization">Explicit specialization</h1> <span style="float:right"><a href="#temp.expl.spec">[temp.expl.spec]</a></span></header>
      
      

      <p para_num="1" id="temp.expl.spec.1">Insert the following paragraphs under 
      <cxx-ref in="cxx" to="temp.expl.spec">C++ <span title="temp.expl.spec">§14.7.3</span></cxx-ref>.</p>

      <p para_num="2" id="temp.expl.spec.2">A constrained template declaration or constrained member function
      of a class template can be declared by a declaration
      introduced by <code>template&lt;&gt;</code>.</p>

      <p para_num="3" id="temp.expl.spec.3">The <cxx-grammarterm><i>template arguments</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm> that
      names an explicit specialization of a constrained template
      declaration must satisfy that template's associated constraints
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <code>C</code> is the type concept defined in the previous
      section.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt;
  struct S1 { };

struct X { void c(); }

template&lt;&gt; S1&lt;X&gt; { };   // OK: X satisfies C
template&lt;&gt; S1&lt;int&gt; { }; // Error: int does not satisfy C</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="temp.expl.spec.4">An explicit specialization of a constrained member function
      (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>) shall not include a
      a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S2 { 
    void f(T) requires C&lt;T&gt;;
  };

template&lt;&gt; void S2&lt;X&gt;::f(T a) { }               // OK
template&lt;&gt; void S2&lt;X&gt;::f(T a) requires C&lt;X&gt; { } // Error: extra requires-clause</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.expl.spec -->
  
    </section>
  </cxx-section> <!-- temp.spec -->



  <!-- ===================
       Template constraints
       ==================== -->

  <cxx-section id="temp.constr">
    

    <section>
      <header><span class="section-number">14.8</span> <h1 data-bookmark-label="14.8 Template constraints">Template constraints</h1> <span style="float:right"><a href="#temp.constr">[temp.constr]</a></span></header>
      
    

    <p para_num="1" id="temp.constr.1">Add this as a new section under 
    <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>.</p>


    <p para_num="2" id="temp.constr.2">Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <dfn>constraint expression</dfn>s or simply 
    <dfn>constraint</dfn>s.
    <bnf-grammar>
    
    
      <bnf-rule>
    
    constraint-expression:
  </bnf-rule>
        <bnf-alt>
    
    logical-or-expression
  </bnf-alt>
    
  </bnf-grammar>

    </p><p para_num="3" id="temp.constr.3">A <cxx-grammarterm><i>logical-or-expression</i></cxx-grammarterm> is a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> if, after 
    substituting template arguments, the resulting expression
    </p><ul>
    <li>is a constant expression,</li>
    <li>has type <code>bool</code>, and</li>
    <li>both operands <code>P</code> and <code>Q</code> in every subexpression
    of a constraint of the form <code>P || Q</code> or <code>P &amp;&amp; Q</code> 
    have type <code>bool</code>.</li>
    </ul>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.
    The requirement that operands to logical operators have type
    <code>bool</code> prevents constraint expressions from finding
    user-defined overloads of those operators and possibly subverting the
    logical processing required by constraints.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <!-- </p> -->

    <p para_num="4" id="temp.constr.4">A program that includes an expression not satisfying these requirements
    in a context where a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
    is required is ill-formed.</p>

    <p para_num="5" id="temp.constr.5">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    Let <code>T</code> be a dependent type, <code>C</code> be a unary function 
    concept, <code>P</code>, <code>Q</code>, and <code>R</code> be 
    value-dependent expressions whose type is <code>bool</code>, and 
    <code>M</code> and  <code>N</code> be integral expressions. All of the 
    following expressions can be used as constraints:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>C&lt;T&gt;()
has_trait&lt;T&gt;::value // only if value is a bool member
P &amp;&amp; Q
P || (Q &amp;&amp; R)
M == N              // only if the result type is bool
has_trait&lt;T&gt;::value // only if value is a bool member
M &lt; N               // only if the result type is bool
M + N &gt;= 0
P || !(M &lt; N)
true
false</code></pre>
  
    An expression of the form <code>M + N</code> is not a valid constraint when
    the arguments have type <code>int</code> since the expression's type is not
    <code>bool</code>. Using this expression as a constraint would make the
    program ill-formed.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="6" id="temp.constr.6">A subexpression of a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept"></a></cxx-ref> is a <dfn>concept check</dfn>.
    A concept check is not evaluated; it is simplified according to the
    rules described in this section.</p>

    <p para_num="7" id="temp.constr.7">Certain subexpressions of a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> are 
    considered <dfn>atomic constraint</dfn>s. A constraint is atomic 
    if it is not:
    </p><ul>
    <li>a <cxx-grammarterm><i>logical-or-expression</i></cxx-grammarterm> of the form
        <code>P || Q</code>,</li>
    <li>a <cxx-grammarterm><i>logical-and-expression</i></cxx-grammarterm> of the form
        <code>P &amp;&amp; Q</code>,</li>
    <li>a concept check,</li>
    <li>a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>, or</li>
    <li>a subexpression of an atomic constraint.</li>
    </ul>
    The valid expression constraints, valid type constraints,
    result type constraints, and exception constraints introduced
    by a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> are
    also atomic constraints.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    <pre><code>has_trait&lt;T&gt;::value
M &lt; N
M + N &gt;= 0
true
false</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    A concept check is not an atomic expression.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <!-- </p> -->

    <p para_num="8" id="temp.constr.8">Constraints are <dfn>simplified</dfn> by reducing them to 
    expressions containing only logical operators and atomic constraints.
    Concept checks and <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s 
    are replaced by simplified expressions.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    An implementation is not required to normalize the constraint by rewriting
    in e.g., disjunctive normal form.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="9" id="temp.constr.9">A concept check that calls a 
function concept is simplified by
    substituting the explicit template arguments into the named function
    body's return expression. A concept check that refers to a variable 
concepts is simplified by substituting the template arguments into the 
variable's initializer. </p>

    <p para_num="10" id="temp.constr.10">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> is simplified
    by replacing it with the conjunction of constraints introduced by
    the <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s its 
    <cxx-grammarterm><i>requirement-list</i></cxx-grammarterm>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Certain atomic constraints introduced by a 
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm> have no explicit syntactic 
    representation in the C++.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>
 
    <p para_num="11" id="temp.constr.11">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    Let <code>P</code> and Q be variable templates
    that are atomic constraints.
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool P_and_Q() { return P&lt;T&gt; &amp;&amp; Q&lt;T&gt;; }

template&lt;typename T&gt;
  concept bool P_or_Q = P&lt;T&gt; || Q&lt;T&gt;;

template&lt;typename T&gt;
  concept bool C = P_and_Q&lt;T&gt; &amp;&amp;
                   requires(T x) { x.p() -&gt; int; };

template&lt;typename X&gt;
  requires P_and_Q&lt;X&gt;() void f();

template&lt;typename X&gt;
  requires P_or_Q&lt;X&gt; void g();

template&lt;typename X&gt;
  requires C&lt;X&gt; void h();</code></pre>
  
The associated constraints of <code>f</code> are simplified to
the expression <code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;</code>,
and the associated constraints of <code>g</code> are simplified
to <code>P&lt;X&gt; || Q&lt;X&gt;</code>. The associated constraints
of <code>h</code> are:
<cxx-codeblock>
    
    <pre><code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;
  &amp;&amp; /* requires x.p() for all x of type X* /
  &amp;&amp; /* requires that x.p() convert to int */</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
 <!-- 
    FIXME: Write a bunch of examples.


    <cxx-example class="inline"> 
    The expression 
    <code>x==y &amp;&amp; has_trait&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    The expression
    <code>requires(T a, T b) { {a==b} -> bool; }</code> has two atomic
    constraints. <code>a==b</code> must be a valid expression, and
    <code>decltype((a==b)) must be implicitly convertible to <code>bool</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>
 -->


    <p para_num="12" id="temp.constr.12">A constraint is <dfn>satisfied</dfn> if, after substituting template
    arguments, it evaluates to <code>true</code>. Otherwise, the constraint is 
    <dfn>unsatisfied</dfn>.</p>

    <p para_num="13" id="temp.constr.13">
    For a mapping <i>M</i> from a set <i>X</i> of atomic 
    constraints to boolean values, let <i>G(M)</i> be the mapping 
    from constraints to boolean values such that <i>G(M)(C)</i> is 
    the result of substituting each atomic constraint A within 
    <i>C</i> for <i>M(A)</i>.

    For two constraints <code>P</code> and <code>Q</code>, let 
    <i>X</i> be the set of all atomic constraints that
    appear in <code>P</code> and <code>Q</code>.

    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
    every mapping <i>M</i> from members of <i>X</i> to boolean 
    values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
    are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
    true (or both).
    </p>


    <!--
    FIXME: Write meaningful examples:
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example class="inline">
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>
    -->

    <p para_num="14" id="temp.constr.14">Two <cxx-grammarterm><i>constraint-expressions</i></cxx-grammarterm>
    <code>P</code> and <code>Q</code> are <dfn>logically equivalent</dfn> 
    if and only if <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>. </p>

  
    </section>
  </cxx-section> <!-- temp.constr -->


        <!-- TODO: Consider adding this to the list of non-deduced contexts
             in 14.8.2.5. -->
        <!--
        <p>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        shall not appear in the <cxx-grammarterm>template-argument-list</cxx-grammarterm>
        of a <cxx-grammarterm>patial-concept-id</cxx-grammarterm>. It is
        a non-deduced context.
        </p>
        -->




    </section>
  </cxx-clause> <!-- temp -->








</body></html>