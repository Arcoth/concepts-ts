<cxx-clause id="dcl.dcl">
  <h1>Declarations</h1>

  <cxx-section id="dcl.spec">
    <h1>Specifiers</h1>

    <p>Extend the <cxx-grammarterm>decl-specifier</cxx-grammarterm> production
    to include the <code>concept</code> specifier.
    <bnf-grammar>
      <bnf-rule>decl-specifier</bnf-rule>
        <ins><bnf-alt><bnf-terminal>concept</bnf-terminal></bnf-alt></ins>
    </bnf-grammar>
    </p>


    <cxx-section id="dcl.type.simple">
      <h1>Simple type specifiers</h1>
      <p>Extend the <cxx-grammarterm>type-name</cxx-grammarterm> production 
      to include the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
      production and its sub-rules.
      <bnf-grammar>
        <bnf-rule>type-name</bnf-rule>
          <bnf-alt>constrained-type-name</bnf-alt>

        <bnf-rule>constrained-type-name</bnf-rule>
          <bnf-alt>concept-name</bnf-alt>
          <bnf-alt>partial-concept-id</bnf-alt>

        <bnf-rule>concept-name</bnf-rule>
          <bnf-alt>identifier</bnf-alt>

        <bnf-rule>partial-concept-id</bnf-rule>
          <bnf-alt>
            concept-name 
            <bnf-terminal>&lt;</bnf-terminal> 
            template-argument-list
            <bnf-terminal>&gt;</bnf-terminal>
          </bnf-alt>
      </bnf-grammar>
      </p>
    </cxx-section>


    <cxx-section id="dcl.spec.auto">
      <h1><code>auto</code> specifier</h1>

      <p>If the <code>auto</code> 
      <cxx-grammarterm>type-specifier</cxx-grammarterm> appears as one 
      of the <cxx-grammarterm>decl-specifiers</cxx-grammarterm> in the 
      <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a 
      function declarator, then the function is a generic function 
      (<cxx-ref to="dcl.fct"></cxx-ref>).
      </p>
    </cxx-section>


    <cxx-section id="dcl.spec.constr">
      <h1>Constrained type specifiers</h1>

      <!-- NOTE: Constrained type specifiers apply only to the declaration
      of parameters and result-type constraints in requires expressions.
      Constrained template parameters extend this notion for constrained
      type and template parameters as well. -->

      <p>When an identifier is a 
      <cxx-grammarterm>concept-name</cxx-grammarterm>, it refers to a 
      function concept or variable concept 
      (<cxx-ref to="dcl.concept"></cxx-ref>).</p>

      <p>A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
      <cxx-grammarterm>concept-id</cxx-grammarterm> followed by a sequence
      of template arguments.
      A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> does not refer
      to template specialization; an additional template argument must be
      supplied (before the first template argument) before the name
      refers to a template specialization.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T, typename U&gt;
  concept bool C = ...;

C&lt;int&gt;       // A partial-concept-id
C&lt;char, int&gt; // A template-id
      </cxx-codeblock>
      The first name is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>
      and can be used as part of constrained type name as part the type 
      specifier of a parameter declaration or a template parameter. The 
      second name is a <cxx-grammarterm>template-id</cxx-grammarterm> and
      determines whether the concept is satisfied for the given arguments.
      </cxx-example>
      </p>

      <p>A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> shall not
      have an empty list of template arguments.</p>

      <p>A <cxx-grammarterm>constrained-type-name</cxx-grammarterm> introduces
      constraints for a <cxx-grammarterm>template-parameter</cxx-grammarterm>,
      placeholder type, or <cxx-grammarterm>decltype-specifier</cxx-grammarterm>,
      depending on the context in which it appears. 

      A <cxx-grammarterm>constrained-type-name</cxx-grammarterm> can be used 
      in the <cxx-grammarterm>type-specifier</cxx-grammarterm> of a
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> or in the
      <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of a
      <cxx-grammarterm>compound-requirement</cxx-grammarterm>.
      </p>

      <p>A <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
      shall not refer to a non-type concept.</p>


      <cxx-section id="dcl.constr.form">
        <h1>Constraint formation</h1>

        <!-- FIXME: Add trailing-return type for concepts -->

        <!-- FIXME: These rules can be simplified by identifying the
        source of the template argument in the constraint. It is either
        a declared template parameter, an invented template parameter,
        or decltype of a required valid expression.

        Note that the latter extends nicely when describing the source
        types for constrained variables and constrained trailing
        result types in function declarations -->
        
        <p>When a <cxx-grammarterm>template-parameter</cxx-grammarterm> 
        or parameter-declaration is declared using a 
        <cxx-grammarterm>constrained-type-name</cxx-grammarterm> in its 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>, a new constraint 
        expression is synthesized and associated with the template declaration. 
        The rules for forming that constraint depend on whether the type 
        specifier is a <cxx-grammarterm>concept-name</cxx-grammarterm> or 
        <cxx-grammarterm>partial-concept-id</cxx-grammarterm>. 
        Both cases require the synthesis of a 
        <cxx-grammarterm>template-id</cxx-grammarterm> referring that refers
        to a specialization of the named concept. The template argument list 
        is formed using the following rules. </p>

        <p>Letting <code>X</code> be the declared
        <cxx-grammarterm>template-parameter</cxx-grammarterm> or the invented type of a 
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in a generic 
        function or generic lambda: </p>
        <ul>
          <li> If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is a <cxx-grammarterm>concept-name</cxx-grammarterm>, the synthesized 
          template argument list contains only <code>X</code>.</li>

          <li> If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> whose 
          template argument list contains the arguments <code>Y1</code>, 
          <code>Y2</code>, ..., <code>Yn</code>, then the synthesized template 
          argument list contains the sequence <code>X</code>, <code>Y1</code>, 
          <code>Y2</code>, ..., <code>Yn</code>.</li>
        </ul>

        <p>If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
        refers to a function concept, then the synthesized constraint is a 
        call expression with no function arguments. </p>

        <p>
        <cxx-example class="inline">
        The following unary and binary concepts are defined as variables and
        functions.
        <cxx-codeblock>
template&lt;typename T&gt;
  concept bool V1 = ...;

template&lt;typename T, typename U&gt;
  concept bool V2 = ...;

template&lt;typename T&gt;
  concept bool F1() { return ...; }

template&lt;typename T, typename T2&gt;
  concept bool F2() { return ...; }
        </cxx-codeblock>
        Suppose <code>X</code> is a template parameter being declared, either 
        explicitly or as an invented template parameter of a 
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        in a generic function or generic lambda. The synthesized constraints 
        corresponding to each declaration are:
        <cxx-codeblock>
V1 X    // becomes V1&lt;T&gt;
V2&lt;Y&gt; X // becomes V2&lt;X, Y&gt;
F1 X    // becomes F1&lt;X&gt;()
F2&lt;Y&gt; X // becomes F2&lt;X, Y&gt;()
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- dcl.constr.form -->

      <cxx-section id="dcl.constr.meaning">
        <h1>Meaning of constrained type specifiers</h1>
        <p>The meaning of a constrained type specifier depends on the 
        context in which it is used. The different meanings of constrained 
        type specifiers are enumerated in this clause. </p>
        <ul>
          <li> If a <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is used as the <cxx-grammarterm>type-specifier</cxx-grammarterm> 
          of a <cxx-grammarterm>template-parameter</cxx-grammarterm>, the
          constraint is formed by applying the declared parameter to the 
          <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.</li>

          <li> When a <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is used as part of the 
          <cxx-grammarterm>type-specifier</cxx-grammarterm> of a 
          <cxx-grammarterm>parameter-declaration</cxx-grammarterm>, the
          parameter's type is formed by replacing the 
          <cxx-grammarterm>constrained-type-name</cxx-grammarterm> with
          <code>auto</code>, creating a generic function or generic lambda. 
          The introduced constraint is formed by applying the declared 
          parameter to the invented template parameter to the 
          <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.</li>

          <li> When a <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is used as part of a <cxx-grammarterm>type-specifier</cxx-grammarterm> 
          in a <cxx-grammarterm>result-type-requirement</cxx-grammarterm>, the
          constraint is introduced as a 
          <cxx-grammarterm>nested-requirement</cxx-grammarterm> that 
          applies the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          to the result type of the required expression.</li>
        </ul>
      </cxx-section> <!-- dcl.constr.meaning -->

    </cxx-section> <!-- dcl.spec.constr -->

    <cxx-section id="dcl.concept">
      <h1><code>concept</code> specifier</h1>

      <p>The <code>concept</code> specifier shall be applied to only the 
      definition of a function template or variable template. 
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A variable 
      template definition having the <code>concept</code> specifier is called a 
      <dfn>variable concept</dfn>. A <dfn>concept definition</dfn> refers
      to either a function concept and its corresponding definition or 
      a variable concept and its corresponding initializer.</p>

      <p>Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>).
      </p>

      <p>A function concept has the following restrictions: </p>
      <ul>
        <li> The template must be unconstrained.</li>
        <li> The result type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The declaration shall be a definition. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose expression shall be a
        <cxx-grammarterm>constraint-expr</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool C1() { return true; } // OK

      template&lt;typename T&gt;
        concept int c2() { return 0; }  // error: must return bool

      template&lt;typename T&gt;
        concept bool C3(T) { return true; } // error: must have no parameters

      concept bool p = 0; // error: not a template
      </cxx-codeblock>
      </cxx-example>

      <p>A variable template has the following restrictions:
      <ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm>constraint-expr</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool Integral = is_integral&lt;T&gt;::value; // OK

      template&lt;typename T&gt;
        concept bool C = 3 + 4; // Error: initializer is not a constraint

      template&lt;Integral T&gt;
        concept bool D = is_unsigned&lt;T&gt;::value; // Error: constrained concept definition
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>If a program declares a non-concept overload of a concept 
      definition with the same template parameters and no function 
      parameters, the program is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool Totally_ordered() { ... }

      template&lt;Graph G&gt;
        constexpr bool Totally_ordered() // error: subverts concept definition
        { return true; }
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>A program that declares an explicit or partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool C = is_iterator&lt;T&gt;::value;

      template&lt;typename T&gt;
        concept bool C&lt;T*&gt; = true; // Error: partial specialization of a concept
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      <cxx-note>
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      </cxx-note>
      </p>

    </cxx-section> <!-- dcl.concept -->

  </cxx-section> <!-- dcl.spec -->
</cxx-clause> <!-- dcl.dcl -->
