<cxx-clause id="dcl.dcl" number="7">
  <h1>Declarations</h1>

  <cxx-section id="dcl.spec">
    <h1>Specifiers</h1>

    Extend the <cxx-grammarterm>decl-specifier</cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p class="quoted">
    <bnf-grammar>
      <bnf-rule>decl-specifier</bnf-rule>
        <ins><bnf-alt><bnf-terminal>concept</bnf-terminal></bnf-alt></ins>
    </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
      <h1>Type specifiers</h1>

      <cxx-section id="dcl.type.simple" number="2">
        <h1>Simple type specifiers</h1>
        
        Add <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        to the grammar for <cxx-grammarterm>simple-type-specifier</cxx-grammarterm>s
        in <cxx-ref in="cxx" to="dcl.type.simple"></cxx-ref>.

        <p class="quoted">
        <bnf-grammar>
          <bnf-rule>simple-type-specifier</bnf-rule>
            <ins><bnf-alt>constrained-type-specifier</bnf-alt></ins>

          <ins>
          <bnf-rule>constrained-type-specifier</bnf-rule>
            <bnf-alt>
              <bnf-opt>nested-name-specifier</bnf-opt> constrained-type-name
            </bnf-alt>

          <bnf-rule>constrained-type-name</bnf-rule>
            <bnf-alt>concept-name</bnf-alt>
            <bnf-alt>partial-concept-id</bnf-alt>

          <bnf-rule>concept-name</bnf-rule>
            <bnf-alt>identifier</bnf-alt>

          <bnf-rule>partial-concept-id</bnf-rule>
            <bnf-alt>
              concept-name 
              <bnf-terminal>&lt;</bnf-terminal> 
              template-argument-list
              <bnf-terminal>&gt;</bnf-terminal>
            </bnf-alt>
          </ins>
        </bnf-grammar>
        </p>
      </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
        <h1><code>auto</code> specifier</h1>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1 as
        follows:

        <p number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.
        </p>


        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1.

        <p class="quoted">
        <ins>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        can be used to construct different forms of types, provided that
        the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        shall not appear in a non-deduced context (<cxx-ref to="temp.deduct.type"></cxx-ref>),
        and that the type containing the <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        shall have one of the following forms:
        <cxx-codeblock>
auto
<i>cv-list</i> auto
auto*
auto&amp;
auto&amp;&amp;
auto[<i>integer-constant</i>]
<i>template-name</i>&lt;auto&gt; (where <i>template-name</i> refers to a class template)
<i>type</i>(auto)
auto()
auto <i>type</i>::*
<i>type</i> auto::*
auto (<i>type</i>::*)()
<i>type</i> (auto::*)()
<i>type</i> (<i>type</i>::*)(auto)
        </cxx-codeblock>

        where <code>(auto)</code> represents a 
        <cxx-grammarterm>parameter-type-list</cxx-grammarterm>
        where at least one parameter type contains an <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>, and 
        <code>()</code> represents a
        <cxx-grammarterm>parameter-type-list</cxx-grammarterm> where no 
        parameter type contains an <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>. 

        Similarly, <code>&lt;T&gt;</code> represents template argument
        lists where at least one argument contains an
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>.

        <cxx-note>
        Placeholder types designated by the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm> are replaced by
        invented template parameters in order to facilitate the deduction
        of that type. These forms, and the use of <code>auto</code> within 
        them, are the only forms for which template type deduction may succeed.
        </cxx-note>
        </ins>
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/2 to read:

        <p number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, 
        <cxx-grammarterm>type-specifier-seq</cxx-grammarterm>,
        <cxx-grammarterm>conversion-function-id</cxx-grammarterm>, or 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>, in any 
        context where such a declarator is valid. 

        If the function declarator includes a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        (<cxx-ref to="dcl.fct"></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3 as follows:

        <p number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of</del>
        <ins>in the type of</ins>
        a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a 
        <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda is
        a <dfn>generic lambda</dfn>.

        <cxx-example>
        <cxx-codeblock>
auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i>
        </cxx-codeblock>
        </cxx-example>

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        of a function declaration, the function is an <dfn>abbreviated function</dfn> 
        (<cxx-ref to="dcl.fct"></cxx-ref>)

        <cxx-example>
        <cxx-codeblock>
void f(const auto&amp;, int); // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </ins>
        </p>

        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3.

        <p class="quoted">
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        can appear in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> 
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm> in
        a <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="req.expr"></cxx-ref>).
        
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -> const auto&amp;; // <i>OK</i>
  };
}
        </cxx-codeblock>
        </cxx-example>

        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/4. The examples
        in the original text are unchanged and therefore omitted.

        <p number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block"></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace"></cxx-ref>), and 
        in a <cxx-grammarterm>for-init-statement</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for"></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm>init-declarator</cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
( <i>expression-list</i> )
        </cxx-codeblock>
        the <cxx-grammarterm>expression-list</cxx-grammarterm> shall be a 
        single <cxx-grammarterm>assignment-expression</cxx-grammarterm>.
        </p>


        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/7.

        <p class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm>braced-init-list</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list"></cxx-ref>), the program is 
        ill-formed. 

        <!-- General rule for constructing P -->
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing 
        <del>the occurrences</del>
        <ins>each occurrence</ins>
        of <code>auto</code> with <del>either</del> a new invented type
        template parameter <del><code>U</code></del> or, 

        <!-- The much maligned init deduction -->
        if the initializer is a <cxx-grammarterm>braced-init-list</cxx-grammarterm>
        <ins>and <code>auto</code> is a <cxx-grammarterm>decl-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        the variable declaration, replace that single occurrence of
        <code>auto</code></ins><del>,</del> with <code>std::initializer_list&lt;U&gt;</code>
        <ins>where <code>U</code> is an invented template type parameter</ins>.

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call"></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; struct Vec;
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;);

auto x1 = { 1, 2 };                 // <ins><i>OK:</i> </ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = 12;                      // <i>OK:</i> decltype(x3) <i>is</i> const int&amp;
const auto* p = &x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltpye(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3});          // <i>error: cannot deduce element type</i></ins>
        </cxx-codeblock>
        </cxx-example>

        <cxx-example>
        <cxx-codeblock>
const auto<ins>&amp;</ins><del> &amp;</del>i = expr;
        </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
template &lt;class U&gt; void f(const U&amp; u);
        </cxx-codeblock>
        </cxx-example>

        <cxx-example>
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
template&lt;typename F, typename S&gt; struct Pair;

Pair&lt;const auto&, auto*&gt; p = expr;
        </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(expr)</code> of the following invented function template:
        <cxx-codeblock>
template&lt;typename U1, typename U2&gt; void g(Pair&lt;const U1&amp;, const U2*&gt; x);
        </cxx-codeblock>
        </cxx-example>
        </p>

      </cxx-section> <!-- dcl.spec.auto -->



        <!-- TODO: Rewrite this section so that it reflects and refers
             to dcl.spec.auto. In particular, we want to say where these
             are allowed, how their placeholder types are deduced, and
             what constraint is introduced. -->
      <cxx-section id="dcl.spec.constr">
        <h1>Constrained type specifiers</h1>

        Add this section to <cxx-ref in="cxx" to="dcl.type"></cxx-ref>.
        The usual formatting marks are omitted since all text is new.

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        designates a placeholder type that will be replaced later by
        deduction from the <cxx-gramarterm>expression</cxx-gramarterm> in a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> or 
        function argument. 

        This deduction succeeds only when the deduced type satisfies the
        constraints introduced by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
        also signifies that a lambda is a generic lambda or
        that a function is an abbreviated function. 
        </p>

        <!-- TODO: Maybe a little fuzzy. -->
        <p>
        Like the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"></cxx-ref>), 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        can be used to construct other types. The forms of types that
        can be constructed, and the use of 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        within them are the same as those specified for the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>.
        </p>

        <!-- TODO: Consider adding this to the list of non-deduced
             contexts. -->
        <!--
        <p>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        shall not appear in the <cxx-grammarterm>template-argument-list</cxx-grammarterm>
        of a <cxx-grammarterm>patial-concept-id</cxx-grammarterm>. It is
        a non-deduced context.
        </p>
        -->

        <p>
        If <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a 
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a
        <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda
        is a generic lambda (<cxx-ref to "expr.lambda"></cxx-ref>).

        Similarly, if a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a
        function declaration, the function is an abbreviated function
        (<cxx-ref to="dcl.fct"></cxx-ref>).

        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; class Vec;

auto gl [](C&amp; a, C* b) { a = *b; } // <i>OK: a generic lambda</i>
void af(const Vec&lt;C&gt;&amp; x);         // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can also appear in the 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> in a
        <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="expr.req"></cxx-ref>).

        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -> const C&; // OK
  };
}
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A program that uses a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in a context not explicitly allowed by this section is ill-formed.
        </p>


        <p>
        When an <cxx-grammarterm>identifier</cxx-grammarterm> is a 
        <cxx-grammarterm>concept-name</cxx-grammarterm> it refers to a set
        of concept definitions (<cxx-ref to="dcl.spec.concept"></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        The first declared <cxx-grammarterm>template-parameter</cxx-grammarterm> 
        of a concept definition is called its <dfn>prototype parameter</dfn>.

        Only concept definitions whose prototype parameter is a template
        <cxx-grammarterm>type-parameter</cxx-grammarterm> are in the
        candidate concept set referred to by a 
        <cxx-grammarterm>concept-name</cxx-grammarterm>.

        If the candidate concept set is empty, the program is ill-formed.

        <cxx-note>
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member when a <cxx-grammarterm>concept-name</cxx-grammarterm>
        refers to a variable concept has at most one member.
        </cxx-note>

        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;int N&gt; concept bool C() { return true; }                  // <i>#3</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#4</i>
template&lt;template&lt;typename&gt; class X&gt; concept bool P = true;        // <i>#5</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #4</i>
void h(P); // <i>error: no matching concept definitions for</i> P
        </cxx-codeblock>
        In the declaration of <code>f(C)</code>, the candidate concept set
        corresponding to the <cxx-grammarterm>concept-name</cxx-grammarterm>,
        <code>C</code>, does not include #3 because its first
        <cxx-grammarterm>template-parameter</cxx-grammarterm> of that
        concept definition is a non-type template parameter.
        Likewise, in the declaration of <code>h(P)</code>, #5 is not
        included because the 
        </cxx-note>
        </p>

        <p>
        A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
        <cxx-grammarterm>concept-name</cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm>template-argument</cxx-grammarterm>s.

        <!-- TODO: It could be empty -->
        The list of <cxx-grammarterm>template-arguments</cxx-grammarterm>
        shall not be empty.

        <cxx-example>
        <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N&gt; concept bool Seq = true;

void f(C<int>);
void f(Seq<3>);
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        The concept definition designated by a
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is
        determined by forming a <cxx-grammarterm>template-id</cxx-grammarterm>
        from the <cxx-grammarterm>concept-name</cxx-grammarterm> and
        a sequence of <cxx-grammarterm>template-arguments</cxx-grammarterm>
        as follows.

        Let <code>C</code> be the <cxx-grammarterm>concept-name</cxx-grammarterm>
        in the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
        and let <code>T</code> be an invented template <cxx-grammarterm>type-parameter</cxx-grammarterm>
        corresponding to the placeholder type that the
        <cxx-grammarterm>type-specifier</cxx-grammarterm> designates.

        When the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>concept-name</cxx-grammarterm>, the
        <cxx-grammarterm>template-id</cxx-grammarterm> is formed as
        <code>C&lt;T&gt;</code>.

        When the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> whose
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub></code>,
        the <cxx-grammarterm>template-id</cxx-grammarterm> is formed as
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>.

        If the <cxx-grammarterm>template-id</cxx-grammarterm> refers to a
        single concept declaration in the candidate concept set, that 
        concept is the one designated by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        </p>



        <p>The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        associates a constraint (<cxx-ref to="temp"></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a <cxx-grammarterm>lambda-expression</cxx-grammarterm>,
        the associated constraint appertains to the member function call
        operator of the closure type (<cxx-ref to="expr.prim.lambda"></cxx-ref>). 

        In the case of a function declaration, the associated constraint 
        appertains to the function itself.

        The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of
        a <cxx-grammarterm>compound-requirement</cxx-grammarterm> includes
        an associated constraint in the conjunction of constraints introduced
        by that requirement (<cxx-ref to="expr.req.compound"></cxx-ref>).
        </p>




        <p>
        When multiple
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s 
        appear in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        or a <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
        the associated or introduced constraints are a conjunction of the
        constraints of each <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        that are evaluated in the order in which they appear.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typemame T&gt; concept bool C = true;
template&lt;typemame T, typename U&gt; concept bool D = true;

void f(Pair&lt;C, D&lt;int&gt;&gt;&amp; p);
        </cxx-codeblock>
        The associated constrains associated by the parameter <code>p</code>
        are:
        <cxx-codeblock>
C&lt;T1&gt; &amp;&amp; D&lt;T2, int&gt;
        </cxx-codeblock>
        where <code>T1</code> and <code>T2</code> are the invented template
        parameters corresponding to the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        <code>C</code> and <code>D&lt;int&gt;</code>
        </p>

<!--
        <p>A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can appear in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm> or in
        any context in which the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm> appears, except:
        <ul>
          <li>in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
          a variable declaration,</li>
          <li>in the return type of a function declaration,</li>
          <li>in the <code>decltype(auto)</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>, or</li>
          <li>a <cxx-grammarterm>conversion-function-id</cxx-grammarterm>.</li>
        </ul>

        <p>If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
        appears as one of the <cxx-grammarterm>decl-specifiers</cxx-grammarterm> 
        of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in
        a <cxx-grammarterm>template-parameter-list</cxx-grammarterm>, then the
        declared parameter is a 
        <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, and its
        meaning is defined in section <cxx-ref to="temp.param"></cxx-ref>.
        Otherwise, the meaning of 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s is
        defined in this section.
        <cxx-note>A constrained template parameter can introduce type parameters
        as well as designate the type of a non-type template parameter. The
        meaning of those declarations are specified separately.
        </cxx-note>
        </p>

        <p>If the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears as one of the <cxx-grammarterm>decl-specifiers</cxx-grammarterm>
        of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
        in either a <cxx-grammarterm>lambda-expression</cxx-grammarterm> or
        function declaration then the lambda is a generic lambda 
        <cxx-ref to="expr.prim.lambda"></cxx-ref> and the function is
        a generic function <cxx-ref to="dcl.fct"></cxx-ref>.</p>

        <p>A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        designates a placeholder type that will be replaced later, and it 
        introduces an associated constraint on deduced type, called
        the <dfn>constrained type</dfn> within the enclosing declaration or 
        <cxx-grammarterm>requires-expression</cxx-grammarterm>.</p>

        <p>If the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm>, then the
        constrained type is deduced from the required valid expression.
        Otherwise, the constrained type is deduced using the rules for
        deducing <code>auto</code> (<cxx-ref to="dcl.spec.auto"></cxx-ref>).</p>
        
        <p>The <dfn>introduced constraint</dfn> is a constraint expression 
        (<cxx-ref to="temp.constr"></cxx-ref>) synthesized from the
        <cxx-grammarterm>concept-name</cxx-grammarterm> or
        <cxx-grammarterm>partial-concept-id</cxx-grammarterm> in the
        <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.</p>

        <p>When an identifier is a 
        <cxx-grammarterm>concept-name</cxx-grammarterm>, it refers to one or
        more function concepts or a single variable concept. 

        At least one concept referred
        to by the <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
        shall be a type concept (<cxx-ref to="dcl.concept"></cxx-ref>).
        <cxx-example class="inline">
        Function concepts can be overloaded to accept different numbers and
        kinds of template arguments. This is sometimes done to generalize
        a single concept for different kinds of arguments.
        <cxx-codeblock>
  template&lt;typename T&gt;
    concept bool C() { ... }
  template&lt;typename T, typename U&gt;
    concept bool C() { ... }
        </cxx-codeblock>
        </cxx-example>
        The <cxx-grammarterm>concept-name</cxx-grammarterm> <code>C</code>
        refers to both concept definitions.
        </p>

        <p>A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
        <cxx-grammarterm>concept-name</cxx-grammarterm> followed by a sequence
        of template arguments.
        
        A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> does not refer
        to template specialization; the template argument list must be
        adjusted by adding a template argument before the first of the
        initial template arguments before the name refers to a template
        specialization.
        <cxx-example class="inline">
        <cxx-codeblock>
  template&lt;typename T, typename U&gt;
    concept bool C = ...;

  C&lt;int&gt;       // A partial-concept-id
  C&lt;char, int&gt; // A template-id
        </cxx-codeblock>
        The first name is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>
        and can be used as part of constrained type name as part the type 
        specifier of a parameter declaration or a template parameter. The 
        second name is a <cxx-grammarterm>template-id</cxx-grammarterm> and
        determines whether the concept is satisfied for the given arguments.
        </cxx-example>
        </p>

        <p>A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> shall not
        have an empty list of template arguments.</p>


        <p>An introduced constraint is formed by applying the following
        rules to each concept referenced by the
        <cxx-grammarterm>concept-name</cxx-grammarterm> in the
        <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.

        Let <code>C</code> be a concept referred to by the
        <cxx-grammarterm>concept-name</cxx-grammarterm>.
        <code>T</code> be the constrained type, and 
        <code>Args</code> be a sequence of template arguments.

        If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is a
        <cxx-grammarterm>partial-concept-id</cxx-grammarterm>, then
        <code>Args</code> is its 
        <cxx-grammarterm>template-argument-list</cxx-grammarterm>, otherwise
        <code>Args</code> is an empty sequence.

        The <dfn>candidate constraint</dfn> is a 
        <cxx-grammarterm>template-id</cxx-grammarterm> having the form
        <code>C&lt;T, Args&gt;</code>. 
        <cxx-note>
        If <code>Args</code> is empty, the resulting 
        <cxx-grammarterm>template-id</cxx-grammarterm> is of the form 
        <code>C&lt;T&gt;</code>.
        </cxx-note>

        If <code>C&lt;T, Args&gt;</code> does not refer to a template 
        specialization, the candidate constraint is rejected.
        <cxx-note>
        The expression <code>C&lt;T, Args&gt;</code> may not refer to a valid
        template specialization if <code>Args</code> contains too many or to 
        few template arguments for <code>C</code>, or if <code>Args</code>
        do not match <code>C's</code> template parameters.
        </cxx-note>

        <p>If, after constructing candidate constraints for each concept
        named by the <cxx-grammarterm>concept-name</cxx-grammarterm>, there
        are no candidates or more than one candidate, the program is 
        ill-formed.</p>

        <p>The introduced constraint is constructed from the remaining candidate. 
        If <code>C</code> is a function concept, then the
        resulting constraint is a function call of the form
        <code>C&lt;T, Args&gt;()</code>. Otherwise, the introduced constraint
        is the same as the remaining candidate.
        </p>

        <p>
        <cxx-example>
        The following unary and binary concepts are defined as variables and
        functions.
        <cxx-codeblock>
  template&lt;typename T&gt;
  concept bool V1 = ...;

  template&lt;typename T, typename U&gt;
  concept bool V2 = ...;

  template&lt;typename T&gt;
  concept bool F1() { return ...; }

  template&lt;typename T, typename T2&gt;
  concept bool F2() { return ...; }
        </cxx-codeblock>
        Suppose <code>X</code> is a template parameter being declared, either 
        explicitly or as an invented template parameter of a 
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        in a generic function or generic lambda. The synthesized constraints 
        corresponding to each declaration are:
        <cxx-codeblock>
  V1 X    // becomes V1&lt;T&gt;
  V2&lt;Y&gt; X // becomes V2&lt;X, Y&gt;
  F1 X    // becomes F1&lt;X&gt;()
  F2&lt;Y&gt; X // becomes F2&lt;X, Y&gt;()
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>The meaning of the introduced constraint depends on the context
        in which the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears. 

        If it appears in the <cxx-grammarterm>decl-specifiers</cxx-grammarterm> 
        of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a 
        generic lambda (<cxx-ref to="expr.prim.lambda"></cxx-ref>) or
        generic function (<cxx-ref to="dcl.fct"></cxx-ref>),
        the the introduced constraint is associated with the corresponding 
        template declaration (<cxx-ref to="temp"></cxx-ref>).

        If it appears  in <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm>, the
        introduced constraint is evaluated as part of the enclosing 
        <cxx-grammarterm>requires-expression</cxx-grammarterm> 
        (<cxx-ref to="expr.req"></cxx-ref>). </p>
-->

      </cxx-section> <!-- dcl.spec.constr -->

    </cxx-section> <!-- dcl.type -->



    <cxx-section id="dcl.spec.concept">
      <h1><code>concept</code> specifier</h1>

      <p>The <code>concept</code> specifier shall be applied to only the 
      definition of a function template or variable template. 
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A variable 
      template definition having the <code>concept</code> specifier is called a 
      <dfn>variable concept</dfn>. A <dfn>concept definition</dfn> refers
      to either a function concept and its definition or 
      a variable concept and its initializer.</p>

      <p>A <dfn>type concept</dfn> is a concept whose first template
      parameter is a <cxx-grammarterm>type-parameter</cxx-grammarterm>, but 
      not a template template parameter. 

      Otherwise, the concept is a <dfn>non-type concept</dfn>.

      A <dfn>variadic concept</dfn> is a concept whose first template
      parameter is a template parameter pack.
      </p>

      <p>Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>).
      </p>

      <p>A function concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained.</li>
        <li> The result type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The declaration shall be a definition. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose expression shall be a
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C1() { return true; } // OK

template&lt;typename T&gt;
  concept int C2() { return 0; }  // error: must return bool

template&lt;typename T&gt;
  concept bool C3(T) { return true; } // error: must have no parameters

concept bool p = 0; // error: not a template
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A variable template has the following restrictions:
      <ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool D1 = has_x&lt;T&gt;::value; // OK

template&lt;typename T&gt;
  concept bool D2 = 3 + 4; // Error: initializer is not a constraint

template&lt;Integral T&gt;
  concept bool D3 = has_x&lt;T&gt;::value; // Error: constrained concept definition
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A program that declares an explicit or partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C = is_iterator&lt;T&gt;::value;

template&lt;typename T&gt;
  concept bool C&lt;T*&gt; = true; // Error: partial specialization of a concept
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      <cxx-note>
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      </cxx-note>
      </p>

    </cxx-section> <!-- dcl.concept -->

  </cxx-section> <!-- dcl.spec -->
</cxx-clause> <!-- dcl.dcl -->
